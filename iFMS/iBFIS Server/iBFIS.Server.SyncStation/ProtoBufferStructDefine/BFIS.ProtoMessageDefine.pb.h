// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BFIS.ProtoMessageDefine.proto

#ifndef PROTOBUF_BFIS_2eProtoMessageDefine_2eproto__INCLUDED
#define PROTOBUF_BFIS_2eProtoMessageDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace BFIS {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

class ClientInfo;
class RolePurviewInfo;
class BusinessInfo;
class ProduceInfo;
class BranchInfo;
class BusinessFileInfo;
class BusinessRelateInfo;
class EmployeeInfo;
class EmployeePurviewInfo;
class EmployeePurviewInfoList;
class PurviewInfo;
class RoleInfo;
class UserMapInfo;
class BusinessQueryParam;
class ProduceIdQueryParam;
class TaskPlan;
class BackupTask;
class McServer;
class MigrateLog;
class QueryCondition;
class BusinessDockMsgInfo;
class ManualSyncParameter;
class ScriptInfo;
class OperateLogInfo;
class DiskAndConnectStatus;

// ===================================================================

class ClientInfo : public ::google::protobuf::Message {
 public:
  ClientInfo();
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInfo& default_instance();

  void Swap(ClientInfo* other);

  // implements Message ----------------------------------------------

  ClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strClientId = 1;
  inline bool has_strclientid() const;
  inline void clear_strclientid();
  static const int kStrClientIdFieldNumber = 1;
  inline const ::std::string& strclientid() const;
  inline void set_strclientid(const ::std::string& value);
  inline void set_strclientid(const char* value);
  inline void set_strclientid(const char* value, size_t size);
  inline ::std::string* mutable_strclientid();
  inline ::std::string* release_strclientid();
  inline void set_allocated_strclientid(::std::string* strclientid);

  // required string strName = 2;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 2;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  inline void set_allocated_strname(::std::string* strname);

  // required string strCredenitialsType = 3;
  inline bool has_strcredenitialstype() const;
  inline void clear_strcredenitialstype();
  static const int kStrCredenitialsTypeFieldNumber = 3;
  inline const ::std::string& strcredenitialstype() const;
  inline void set_strcredenitialstype(const ::std::string& value);
  inline void set_strcredenitialstype(const char* value);
  inline void set_strcredenitialstype(const char* value, size_t size);
  inline ::std::string* mutable_strcredenitialstype();
  inline ::std::string* release_strcredenitialstype();
  inline void set_allocated_strcredenitialstype(::std::string* strcredenitialstype);

  // required string strCredenitial = 4;
  inline bool has_strcredenitial() const;
  inline void clear_strcredenitial();
  static const int kStrCredenitialFieldNumber = 4;
  inline const ::std::string& strcredenitial() const;
  inline void set_strcredenitial(const ::std::string& value);
  inline void set_strcredenitial(const char* value);
  inline void set_strcredenitial(const char* value, size_t size);
  inline ::std::string* mutable_strcredenitial();
  inline ::std::string* release_strcredenitial();
  inline void set_allocated_strcredenitial(::std::string* strcredenitial);

  // required string strPhone = 5;
  inline bool has_strphone() const;
  inline void clear_strphone();
  static const int kStrPhoneFieldNumber = 5;
  inline const ::std::string& strphone() const;
  inline void set_strphone(const ::std::string& value);
  inline void set_strphone(const char* value);
  inline void set_strphone(const char* value, size_t size);
  inline ::std::string* mutable_strphone();
  inline ::std::string* release_strphone();
  inline void set_allocated_strphone(::std::string* strphone);

  // required string strContent = 6;
  inline bool has_strcontent() const;
  inline void clear_strcontent();
  static const int kStrContentFieldNumber = 6;
  inline const ::std::string& strcontent() const;
  inline void set_strcontent(const ::std::string& value);
  inline void set_strcontent(const char* value);
  inline void set_strcontent(const char* value, size_t size);
  inline ::std::string* mutable_strcontent();
  inline ::std::string* release_strcontent();
  inline void set_allocated_strcontent(::std::string* strcontent);

  // required int32 nExtendedInfo = 7;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 7;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 8;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 8;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 9;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 9;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.ClientInfo)
 private:
  inline void set_has_strclientid();
  inline void clear_has_strclientid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strcredenitialstype();
  inline void clear_has_strcredenitialstype();
  inline void set_has_strcredenitial();
  inline void clear_has_strcredenitial();
  inline void set_has_strphone();
  inline void clear_has_strphone();
  inline void set_has_strcontent();
  inline void clear_has_strcontent();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strclientid_;
  ::std::string* strname_;
  ::std::string* strcredenitialstype_;
  ::std::string* strcredenitial_;
  ::std::string* strphone_;
  ::std::string* strcontent_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static ClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class RolePurviewInfo : public ::google::protobuf::Message {
 public:
  RolePurviewInfo();
  virtual ~RolePurviewInfo();

  RolePurviewInfo(const RolePurviewInfo& from);

  inline RolePurviewInfo& operator=(const RolePurviewInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RolePurviewInfo& default_instance();

  void Swap(RolePurviewInfo* other);

  // implements Message ----------------------------------------------

  RolePurviewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RolePurviewInfo& from);
  void MergeFrom(const RolePurviewInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strRoleInfoPurviewId = 1;
  inline bool has_strroleinfopurviewid() const;
  inline void clear_strroleinfopurviewid();
  static const int kStrRoleInfoPurviewIdFieldNumber = 1;
  inline const ::std::string& strroleinfopurviewid() const;
  inline void set_strroleinfopurviewid(const ::std::string& value);
  inline void set_strroleinfopurviewid(const char* value);
  inline void set_strroleinfopurviewid(const char* value, size_t size);
  inline ::std::string* mutable_strroleinfopurviewid();
  inline ::std::string* release_strroleinfopurviewid();
  inline void set_allocated_strroleinfopurviewid(::std::string* strroleinfopurviewid);

  // required string strRoleId = 2;
  inline bool has_strroleid() const;
  inline void clear_strroleid();
  static const int kStrRoleIdFieldNumber = 2;
  inline const ::std::string& strroleid() const;
  inline void set_strroleid(const ::std::string& value);
  inline void set_strroleid(const char* value);
  inline void set_strroleid(const char* value, size_t size);
  inline ::std::string* mutable_strroleid();
  inline ::std::string* release_strroleid();
  inline void set_allocated_strroleid(::std::string* strroleid);

  // required string strPruviewInfoId = 3;
  inline bool has_strpruviewinfoid() const;
  inline void clear_strpruviewinfoid();
  static const int kStrPruviewInfoIdFieldNumber = 3;
  inline const ::std::string& strpruviewinfoid() const;
  inline void set_strpruviewinfoid(const ::std::string& value);
  inline void set_strpruviewinfoid(const char* value);
  inline void set_strpruviewinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strpruviewinfoid();
  inline ::std::string* release_strpruviewinfoid();
  inline void set_allocated_strpruviewinfoid(::std::string* strpruviewinfoid);

  // required int32 nExtendedInfo = 4;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 4;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 5;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 5;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 6;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 6;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.RolePurviewInfo)
 private:
  inline void set_has_strroleinfopurviewid();
  inline void clear_has_strroleinfopurviewid();
  inline void set_has_strroleid();
  inline void clear_has_strroleid();
  inline void set_has_strpruviewinfoid();
  inline void clear_has_strpruviewinfoid();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strroleinfopurviewid_;
  ::std::string* strroleid_;
  ::std::string* strpruviewinfoid_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static RolePurviewInfo* default_instance_;
};
// -------------------------------------------------------------------

class BusinessInfo : public ::google::protobuf::Message {
 public:
  BusinessInfo();
  virtual ~BusinessInfo();

  BusinessInfo(const BusinessInfo& from);

  inline BusinessInfo& operator=(const BusinessInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessInfo& default_instance();

  void Swap(BusinessInfo* other);

  // implements Message ----------------------------------------------

  BusinessInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessInfo& from);
  void MergeFrom(const BusinessInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strBusinessInfoId = 1;
  inline bool has_strbusinessinfoid() const;
  inline void clear_strbusinessinfoid();
  static const int kStrBusinessInfoIdFieldNumber = 1;
  inline const ::std::string& strbusinessinfoid() const;
  inline void set_strbusinessinfoid(const ::std::string& value);
  inline void set_strbusinessinfoid(const char* value);
  inline void set_strbusinessinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessinfoid();
  inline ::std::string* release_strbusinessinfoid();
  inline void set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid);

  // required string strDateTime = 2;
  inline bool has_strdatetime() const;
  inline void clear_strdatetime();
  static const int kStrDateTimeFieldNumber = 2;
  inline const ::std::string& strdatetime() const;
  inline void set_strdatetime(const ::std::string& value);
  inline void set_strdatetime(const char* value);
  inline void set_strdatetime(const char* value, size_t size);
  inline ::std::string* mutable_strdatetime();
  inline ::std::string* release_strdatetime();
  inline void set_allocated_strdatetime(::std::string* strdatetime);

  // required string strBranchId = 3;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchIdFieldNumber = 3;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string strClientId = 4;
  inline bool has_strclientid() const;
  inline void clear_strclientid();
  static const int kStrClientIdFieldNumber = 4;
  inline const ::std::string& strclientid() const;
  inline void set_strclientid(const ::std::string& value);
  inline void set_strclientid(const char* value);
  inline void set_strclientid(const char* value, size_t size);
  inline ::std::string* mutable_strclientid();
  inline ::std::string* release_strclientid();
  inline void set_allocated_strclientid(::std::string* strclientid);

  // required string strEmployeeId = 5;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeIdFieldNumber = 5;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strProduceId = 6;
  inline bool has_strproduceid() const;
  inline void clear_strproduceid();
  static const int kStrProduceIdFieldNumber = 6;
  inline const ::std::string& strproduceid() const;
  inline void set_strproduceid(const ::std::string& value);
  inline void set_strproduceid(const char* value);
  inline void set_strproduceid(const char* value, size_t size);
  inline ::std::string* mutable_strproduceid();
  inline ::std::string* release_strproduceid();
  inline void set_allocated_strproduceid(::std::string* strproduceid);

  // required string strSubEquipmentId = 7;
  inline bool has_strsubequipmentid() const;
  inline void clear_strsubequipmentid();
  static const int kStrSubEquipmentIdFieldNumber = 7;
  inline const ::std::string& strsubequipmentid() const;
  inline void set_strsubequipmentid(const ::std::string& value);
  inline void set_strsubequipmentid(const char* value);
  inline void set_strsubequipmentid(const char* value, size_t size);
  inline ::std::string* mutable_strsubequipmentid();
  inline ::std::string* release_strsubequipmentid();
  inline void set_allocated_strsubequipmentid(::std::string* strsubequipmentid);

  // required int32 nExtendedInfo = 8;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 8;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 9;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 9;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 10;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 10;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required string strSubEquipmentIcmSign = 11;
  inline bool has_strsubequipmenticmsign() const;
  inline void clear_strsubequipmenticmsign();
  static const int kStrSubEquipmentIcmSignFieldNumber = 11;
  inline const ::std::string& strsubequipmenticmsign() const;
  inline void set_strsubequipmenticmsign(const ::std::string& value);
  inline void set_strsubequipmenticmsign(const char* value);
  inline void set_strsubequipmenticmsign(const char* value, size_t size);
  inline ::std::string* mutable_strsubequipmenticmsign();
  inline ::std::string* release_strsubequipmenticmsign();
  inline void set_allocated_strsubequipmenticmsign(::std::string* strsubequipmenticmsign);

  // required string strSerialNumber = 12;
  inline bool has_strserialnumber() const;
  inline void clear_strserialnumber();
  static const int kStrSerialNumberFieldNumber = 12;
  inline const ::std::string& strserialnumber() const;
  inline void set_strserialnumber(const ::std::string& value);
  inline void set_strserialnumber(const char* value);
  inline void set_strserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_strserialnumber();
  inline ::std::string* release_strserialnumber();
  inline void set_allocated_strserialnumber(::std::string* strserialnumber);

  // required int32 nMigrated = 13;
  inline bool has_nmigrated() const;
  inline void clear_nmigrated();
  static const int kNMigratedFieldNumber = 13;
  inline ::google::protobuf::int32 nmigrated() const;
  inline void set_nmigrated(::google::protobuf::int32 value);

  // required string strFileCenter = 14;
  inline bool has_strfilecenter() const;
  inline void clear_strfilecenter();
  static const int kStrFileCenterFieldNumber = 14;
  inline const ::std::string& strfilecenter() const;
  inline void set_strfilecenter(const ::std::string& value);
  inline void set_strfilecenter(const char* value);
  inline void set_strfilecenter(const char* value, size_t size);
  inline ::std::string* mutable_strfilecenter();
  inline ::std::string* release_strfilecenter();
  inline void set_allocated_strfilecenter(::std::string* strfilecenter);

  // required string strBusinessType = 15;
  inline bool has_strbusinesstype() const;
  inline void clear_strbusinesstype();
  static const int kStrBusinessTypeFieldNumber = 15;
  inline const ::std::string& strbusinesstype() const;
  inline void set_strbusinesstype(const ::std::string& value);
  inline void set_strbusinesstype(const char* value);
  inline void set_strbusinesstype(const char* value, size_t size);
  inline ::std::string* mutable_strbusinesstype();
  inline ::std::string* release_strbusinesstype();
  inline void set_allocated_strbusinesstype(::std::string* strbusinesstype);

  // required string strCardNumber = 16;
  inline bool has_strcardnumber() const;
  inline void clear_strcardnumber();
  static const int kStrCardNumberFieldNumber = 16;
  inline const ::std::string& strcardnumber() const;
  inline void set_strcardnumber(const ::std::string& value);
  inline void set_strcardnumber(const char* value);
  inline void set_strcardnumber(const char* value, size_t size);
  inline ::std::string* mutable_strcardnumber();
  inline ::std::string* release_strcardnumber();
  inline void set_allocated_strcardnumber(::std::string* strcardnumber);

  // required int32 nMarkerType = 17;
  inline bool has_nmarkertype() const;
  inline void clear_nmarkertype();
  static const int kNMarkerTypeFieldNumber = 17;
  inline ::google::protobuf::int32 nmarkertype() const;
  inline void set_nmarkertype(::google::protobuf::int32 value);

  // required string strCardType = 18;
  inline bool has_strcardtype() const;
  inline void clear_strcardtype();
  static const int kStrCardTypeFieldNumber = 18;
  inline const ::std::string& strcardtype() const;
  inline void set_strcardtype(const ::std::string& value);
  inline void set_strcardtype(const char* value);
  inline void set_strcardtype(const char* value, size_t size);
  inline ::std::string* mutable_strcardtype();
  inline ::std::string* release_strcardtype();
  inline void set_allocated_strcardtype(::std::string* strcardtype);

  // required string strMediumType = 19;
  inline bool has_strmediumtype() const;
  inline void clear_strmediumtype();
  static const int kStrMediumTypeFieldNumber = 19;
  inline const ::std::string& strmediumtype() const;
  inline void set_strmediumtype(const ::std::string& value);
  inline void set_strmediumtype(const char* value);
  inline void set_strmediumtype(const char* value, size_t size);
  inline ::std::string* mutable_strmediumtype();
  inline ::std::string* release_strmediumtype();
  inline void set_allocated_strmediumtype(::std::string* strmediumtype);

  // required string strMediumNum = 20;
  inline bool has_strmediumnum() const;
  inline void clear_strmediumnum();
  static const int kStrMediumNumFieldNumber = 20;
  inline const ::std::string& strmediumnum() const;
  inline void set_strmediumnum(const ::std::string& value);
  inline void set_strmediumnum(const char* value);
  inline void set_strmediumnum(const char* value, size_t size);
  inline ::std::string* mutable_strmediumnum();
  inline ::std::string* release_strmediumnum();
  inline void set_allocated_strmediumnum(::std::string* strmediumnum);

  // required string strOffDisputeTime = 21;
  inline bool has_stroffdisputetime() const;
  inline void clear_stroffdisputetime();
  static const int kStrOffDisputeTimeFieldNumber = 21;
  inline const ::std::string& stroffdisputetime() const;
  inline void set_stroffdisputetime(const ::std::string& value);
  inline void set_stroffdisputetime(const char* value);
  inline void set_stroffdisputetime(const char* value, size_t size);
  inline ::std::string* mutable_stroffdisputetime();
  inline ::std::string* release_stroffdisputetime();
  inline void set_allocated_stroffdisputetime(::std::string* stroffdisputetime);

  // @@protoc_insertion_point(class_scope:BFIS.BusinessInfo)
 private:
  inline void set_has_strbusinessinfoid();
  inline void clear_has_strbusinessinfoid();
  inline void set_has_strdatetime();
  inline void clear_has_strdatetime();
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_strclientid();
  inline void clear_has_strclientid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strproduceid();
  inline void clear_has_strproduceid();
  inline void set_has_strsubequipmentid();
  inline void clear_has_strsubequipmentid();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_strsubequipmenticmsign();
  inline void clear_has_strsubequipmenticmsign();
  inline void set_has_strserialnumber();
  inline void clear_has_strserialnumber();
  inline void set_has_nmigrated();
  inline void clear_has_nmigrated();
  inline void set_has_strfilecenter();
  inline void clear_has_strfilecenter();
  inline void set_has_strbusinesstype();
  inline void clear_has_strbusinesstype();
  inline void set_has_strcardnumber();
  inline void clear_has_strcardnumber();
  inline void set_has_nmarkertype();
  inline void clear_has_nmarkertype();
  inline void set_has_strcardtype();
  inline void clear_has_strcardtype();
  inline void set_has_strmediumtype();
  inline void clear_has_strmediumtype();
  inline void set_has_strmediumnum();
  inline void clear_has_strmediumnum();
  inline void set_has_stroffdisputetime();
  inline void clear_has_stroffdisputetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbusinessinfoid_;
  ::std::string* strdatetime_;
  ::std::string* strbranchid_;
  ::std::string* strclientid_;
  ::std::string* stremployeeid_;
  ::std::string* strproduceid_;
  ::std::string* strsubequipmentid_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;
  ::google::protobuf::int32 nmigrated_;
  ::std::string* strsubequipmenticmsign_;
  ::std::string* strserialnumber_;
  ::std::string* strfilecenter_;
  ::std::string* strbusinesstype_;
  ::std::string* strcardnumber_;
  ::std::string* strcardtype_;
  ::std::string* strmediumtype_;
  ::std::string* strmediumnum_;
  ::std::string* stroffdisputetime_;
  ::google::protobuf::int32 nmarkertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BusinessInfo* default_instance_;
};
// -------------------------------------------------------------------

class ProduceInfo : public ::google::protobuf::Message {
 public:
  ProduceInfo();
  virtual ~ProduceInfo();

  ProduceInfo(const ProduceInfo& from);

  inline ProduceInfo& operator=(const ProduceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProduceInfo& default_instance();

  void Swap(ProduceInfo* other);

  // implements Message ----------------------------------------------

  ProduceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProduceInfo& from);
  void MergeFrom(const ProduceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strProduceId = 1;
  inline bool has_strproduceid() const;
  inline void clear_strproduceid();
  static const int kStrProduceIdFieldNumber = 1;
  inline const ::std::string& strproduceid() const;
  inline void set_strproduceid(const ::std::string& value);
  inline void set_strproduceid(const char* value);
  inline void set_strproduceid(const char* value, size_t size);
  inline ::std::string* mutable_strproduceid();
  inline ::std::string* release_strproduceid();
  inline void set_allocated_strproduceid(::std::string* strproduceid);

  // required string strName = 2;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 2;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  inline void set_allocated_strname(::std::string* strname);

  // required string strProduceCode = 3;
  inline bool has_strproducecode() const;
  inline void clear_strproducecode();
  static const int kStrProduceCodeFieldNumber = 3;
  inline const ::std::string& strproducecode() const;
  inline void set_strproducecode(const ::std::string& value);
  inline void set_strproducecode(const char* value);
  inline void set_strproducecode(const char* value, size_t size);
  inline ::std::string* mutable_strproducecode();
  inline ::std::string* release_strproducecode();
  inline void set_allocated_strproducecode(::std::string* strproducecode);

  // required int32 nPeriod = 4;
  inline bool has_nperiod() const;
  inline void clear_nperiod();
  static const int kNPeriodFieldNumber = 4;
  inline ::google::protobuf::int32 nperiod() const;
  inline void set_nperiod(::google::protobuf::int32 value);

  // required string strRevenue = 5;
  inline bool has_strrevenue() const;
  inline void clear_strrevenue();
  static const int kStrRevenueFieldNumber = 5;
  inline const ::std::string& strrevenue() const;
  inline void set_strrevenue(const ::std::string& value);
  inline void set_strrevenue(const char* value);
  inline void set_strrevenue(const char* value, size_t size);
  inline ::std::string* mutable_strrevenue();
  inline ::std::string* release_strrevenue();
  inline void set_allocated_strrevenue(::std::string* strrevenue);

  // required int32 nMiniAmount = 6;
  inline bool has_nminiamount() const;
  inline void clear_nminiamount();
  static const int kNMiniAmountFieldNumber = 6;
  inline ::google::protobuf::int32 nminiamount() const;
  inline void set_nminiamount(::google::protobuf::int32 value);

  // required string strRiskLevel = 7;
  inline bool has_strrisklevel() const;
  inline void clear_strrisklevel();
  static const int kStrRiskLevelFieldNumber = 7;
  inline const ::std::string& strrisklevel() const;
  inline void set_strrisklevel(const ::std::string& value);
  inline void set_strrisklevel(const char* value);
  inline void set_strrisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strrisklevel();
  inline ::std::string* release_strrisklevel();
  inline void set_allocated_strrisklevel(::std::string* strrisklevel);

  // required string strSerialNumber = 8;
  inline bool has_strserialnumber() const;
  inline void clear_strserialnumber();
  static const int kStrSerialNumberFieldNumber = 8;
  inline const ::std::string& strserialnumber() const;
  inline void set_strserialnumber(const ::std::string& value);
  inline void set_strserialnumber(const char* value);
  inline void set_strserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_strserialnumber();
  inline ::std::string* release_strserialnumber();
  inline void set_allocated_strserialnumber(::std::string* strserialnumber);

  // required string strPublishBeinTime = 9;
  inline bool has_strpublishbeintime() const;
  inline void clear_strpublishbeintime();
  static const int kStrPublishBeinTimeFieldNumber = 9;
  inline const ::std::string& strpublishbeintime() const;
  inline void set_strpublishbeintime(const ::std::string& value);
  inline void set_strpublishbeintime(const char* value);
  inline void set_strpublishbeintime(const char* value, size_t size);
  inline ::std::string* mutable_strpublishbeintime();
  inline ::std::string* release_strpublishbeintime();
  inline void set_allocated_strpublishbeintime(::std::string* strpublishbeintime);

  // required string strPublishEndTime = 10;
  inline bool has_strpublishendtime() const;
  inline void clear_strpublishendtime();
  static const int kStrPublishEndTimeFieldNumber = 10;
  inline const ::std::string& strpublishendtime() const;
  inline void set_strpublishendtime(const ::std::string& value);
  inline void set_strpublishendtime(const char* value);
  inline void set_strpublishendtime(const char* value, size_t size);
  inline ::std::string* mutable_strpublishendtime();
  inline ::std::string* release_strpublishendtime();
  inline void set_allocated_strpublishendtime(::std::string* strpublishendtime);

  // required string strProductionType = 11;
  inline bool has_strproductiontype() const;
  inline void clear_strproductiontype();
  static const int kStrProductionTypeFieldNumber = 11;
  inline const ::std::string& strproductiontype() const;
  inline void set_strproductiontype(const ::std::string& value);
  inline void set_strproductiontype(const char* value);
  inline void set_strproductiontype(const char* value, size_t size);
  inline ::std::string* mutable_strproductiontype();
  inline ::std::string* release_strproductiontype();
  inline void set_allocated_strproductiontype(::std::string* strproductiontype);

  // required string strApplicableCustomer = 12;
  inline bool has_strapplicablecustomer() const;
  inline void clear_strapplicablecustomer();
  static const int kStrApplicableCustomerFieldNumber = 12;
  inline const ::std::string& strapplicablecustomer() const;
  inline void set_strapplicablecustomer(const ::std::string& value);
  inline void set_strapplicablecustomer(const char* value);
  inline void set_strapplicablecustomer(const char* value, size_t size);
  inline ::std::string* mutable_strapplicablecustomer();
  inline ::std::string* release_strapplicablecustomer();
  inline void set_allocated_strapplicablecustomer(::std::string* strapplicablecustomer);

  // required string strRevenueType = 13;
  inline bool has_strrevenuetype() const;
  inline void clear_strrevenuetype();
  static const int kStrRevenueTypeFieldNumber = 13;
  inline const ::std::string& strrevenuetype() const;
  inline void set_strrevenuetype(const ::std::string& value);
  inline void set_strrevenuetype(const char* value);
  inline void set_strrevenuetype(const char* value, size_t size);
  inline ::std::string* mutable_strrevenuetype();
  inline ::std::string* release_strrevenuetype();
  inline void set_allocated_strrevenuetype(::std::string* strrevenuetype);

  // required string strIncrementMoney = 14;
  inline bool has_strincrementmoney() const;
  inline void clear_strincrementmoney();
  static const int kStrIncrementMoneyFieldNumber = 14;
  inline const ::std::string& strincrementmoney() const;
  inline void set_strincrementmoney(const ::std::string& value);
  inline void set_strincrementmoney(const char* value);
  inline void set_strincrementmoney(const char* value, size_t size);
  inline ::std::string* mutable_strincrementmoney();
  inline ::std::string* release_strincrementmoney();
  inline void set_allocated_strincrementmoney(::std::string* strincrementmoney);

  // required string strCurrentyType = 15;
  inline bool has_strcurrentytype() const;
  inline void clear_strcurrentytype();
  static const int kStrCurrentyTypeFieldNumber = 15;
  inline const ::std::string& strcurrentytype() const;
  inline void set_strcurrentytype(const ::std::string& value);
  inline void set_strcurrentytype(const char* value);
  inline void set_strcurrentytype(const char* value, size_t size);
  inline ::std::string* mutable_strcurrentytype();
  inline ::std::string* release_strcurrentytype();
  inline void set_allocated_strcurrentytype(::std::string* strcurrentytype);

  // required string strSealsBranch = 16;
  inline bool has_strsealsbranch() const;
  inline void clear_strsealsbranch();
  static const int kStrSealsBranchFieldNumber = 16;
  inline const ::std::string& strsealsbranch() const;
  inline void set_strsealsbranch(const ::std::string& value);
  inline void set_strsealsbranch(const char* value);
  inline void set_strsealsbranch(const char* value, size_t size);
  inline ::std::string* mutable_strsealsbranch();
  inline ::std::string* release_strsealsbranch();
  inline void set_allocated_strsealsbranch(::std::string* strsealsbranch);

  // required string strRevenueInitialDay = 17;
  inline bool has_strrevenueinitialday() const;
  inline void clear_strrevenueinitialday();
  static const int kStrRevenueInitialDayFieldNumber = 17;
  inline const ::std::string& strrevenueinitialday() const;
  inline void set_strrevenueinitialday(const ::std::string& value);
  inline void set_strrevenueinitialday(const char* value);
  inline void set_strrevenueinitialday(const char* value, size_t size);
  inline ::std::string* mutable_strrevenueinitialday();
  inline ::std::string* release_strrevenueinitialday();
  inline void set_allocated_strrevenueinitialday(::std::string* strrevenueinitialday);

  // required string strDeadLine = 18;
  inline bool has_strdeadline() const;
  inline void clear_strdeadline();
  static const int kStrDeadLineFieldNumber = 18;
  inline const ::std::string& strdeadline() const;
  inline void set_strdeadline(const ::std::string& value);
  inline void set_strdeadline(const char* value);
  inline void set_strdeadline(const char* value, size_t size);
  inline ::std::string* mutable_strdeadline();
  inline ::std::string* release_strdeadline();
  inline void set_allocated_strdeadline(::std::string* strdeadline);

  // required string strPaymentDay = 19;
  inline bool has_strpaymentday() const;
  inline void clear_strpaymentday();
  static const int kStrPaymentDayFieldNumber = 19;
  inline const ::std::string& strpaymentday() const;
  inline void set_strpaymentday(const ::std::string& value);
  inline void set_strpaymentday(const char* value);
  inline void set_strpaymentday(const char* value, size_t size);
  inline ::std::string* mutable_strpaymentday();
  inline ::std::string* release_strpaymentday();
  inline void set_allocated_strpaymentday(::std::string* strpaymentday);

  // required string strTrusteeFee = 20;
  inline bool has_strtrusteefee() const;
  inline void clear_strtrusteefee();
  static const int kStrTrusteeFeeFieldNumber = 20;
  inline const ::std::string& strtrusteefee() const;
  inline void set_strtrusteefee(const ::std::string& value);
  inline void set_strtrusteefee(const char* value);
  inline void set_strtrusteefee(const char* value, size_t size);
  inline ::std::string* mutable_strtrusteefee();
  inline ::std::string* release_strtrusteefee();
  inline void set_allocated_strtrusteefee(::std::string* strtrusteefee);

  // required string strCommissionCharge = 21;
  inline bool has_strcommissioncharge() const;
  inline void clear_strcommissioncharge();
  static const int kStrCommissionChargeFieldNumber = 21;
  inline const ::std::string& strcommissioncharge() const;
  inline void set_strcommissioncharge(const ::std::string& value);
  inline void set_strcommissioncharge(const char* value);
  inline void set_strcommissioncharge(const char* value, size_t size);
  inline ::std::string* mutable_strcommissioncharge();
  inline ::std::string* release_strcommissioncharge();
  inline void set_allocated_strcommissioncharge(::std::string* strcommissioncharge);

  // required string strTrustee = 22;
  inline bool has_strtrustee() const;
  inline void clear_strtrustee();
  static const int kStrTrusteeFieldNumber = 22;
  inline const ::std::string& strtrustee() const;
  inline void set_strtrustee(const ::std::string& value);
  inline void set_strtrustee(const char* value);
  inline void set_strtrustee(const char* value, size_t size);
  inline ::std::string* mutable_strtrustee();
  inline ::std::string* release_strtrustee();
  inline void set_allocated_strtrustee(::std::string* strtrustee);

  // required string strOverheadCharge = 23;
  inline bool has_stroverheadcharge() const;
  inline void clear_stroverheadcharge();
  static const int kStrOverheadChargeFieldNumber = 23;
  inline const ::std::string& stroverheadcharge() const;
  inline void set_stroverheadcharge(const ::std::string& value);
  inline void set_stroverheadcharge(const char* value);
  inline void set_stroverheadcharge(const char* value, size_t size);
  inline ::std::string* mutable_stroverheadcharge();
  inline ::std::string* release_stroverheadcharge();
  inline void set_allocated_stroverheadcharge(::std::string* stroverheadcharge);

  // required string strRevenueCalculation = 24;
  inline bool has_strrevenuecalculation() const;
  inline void clear_strrevenuecalculation();
  static const int kStrRevenueCalculationFieldNumber = 24;
  inline const ::std::string& strrevenuecalculation() const;
  inline void set_strrevenuecalculation(const ::std::string& value);
  inline void set_strrevenuecalculation(const char* value);
  inline void set_strrevenuecalculation(const char* value, size_t size);
  inline ::std::string* mutable_strrevenuecalculation();
  inline ::std::string* release_strrevenuecalculation();
  inline void set_allocated_strrevenuecalculation(::std::string* strrevenuecalculation);

  // required string strContent = 25;
  inline bool has_strcontent() const;
  inline void clear_strcontent();
  static const int kStrContentFieldNumber = 25;
  inline const ::std::string& strcontent() const;
  inline void set_strcontent(const ::std::string& value);
  inline void set_strcontent(const char* value);
  inline void set_strcontent(const char* value, size_t size);
  inline ::std::string* mutable_strcontent();
  inline ::std::string* release_strcontent();
  inline void set_allocated_strcontent(::std::string* strcontent);

  // required int32 nMaxTime = 26;
  inline bool has_nmaxtime() const;
  inline void clear_nmaxtime();
  static const int kNMaxTimeFieldNumber = 26;
  inline ::google::protobuf::int32 nmaxtime() const;
  inline void set_nmaxtime(::google::protobuf::int32 value);

  // required int32 nMineTime = 27;
  inline bool has_nminetime() const;
  inline void clear_nminetime();
  static const int kNMineTimeFieldNumber = 27;
  inline ::google::protobuf::int32 nminetime() const;
  inline void set_nminetime(::google::protobuf::int32 value);

  // required int32 nStandardTime = 28;
  inline bool has_nstandardtime() const;
  inline void clear_nstandardtime();
  static const int kNStandardTimeFieldNumber = 28;
  inline ::google::protobuf::int32 nstandardtime() const;
  inline void set_nstandardtime(::google::protobuf::int32 value);

  // required string strPrequestion = 29;
  inline bool has_strprequestion() const;
  inline void clear_strprequestion();
  static const int kStrPrequestionFieldNumber = 29;
  inline const ::std::string& strprequestion() const;
  inline void set_strprequestion(const ::std::string& value);
  inline void set_strprequestion(const char* value);
  inline void set_strprequestion(const char* value, size_t size);
  inline ::std::string* mutable_strprequestion();
  inline ::std::string* release_strprequestion();
  inline void set_allocated_strprequestion(::std::string* strprequestion);

  // required int32 nIsPublished = 30;
  inline bool has_nispublished() const;
  inline void clear_nispublished();
  static const int kNIsPublishedFieldNumber = 30;
  inline ::google::protobuf::int32 nispublished() const;
  inline void set_nispublished(::google::protobuf::int32 value);

  // required int32 nIsEnabled = 31;
  inline bool has_nisenabled() const;
  inline void clear_nisenabled();
  static const int kNIsEnabledFieldNumber = 31;
  inline ::google::protobuf::int32 nisenabled() const;
  inline void set_nisenabled(::google::protobuf::int32 value);

  // required int32 nExtendedInfo = 32;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 32;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 33;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 33;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 34;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 34;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required int32 nEnableMigrated = 35;
  inline bool has_nenablemigrated() const;
  inline void clear_nenablemigrated();
  static const int kNEnableMigratedFieldNumber = 35;
  inline ::google::protobuf::int32 nenablemigrated() const;
  inline void set_nenablemigrated(::google::protobuf::int32 value);

  // required int32 nRecordExistDays = 36;
  inline bool has_nrecordexistdays() const;
  inline void clear_nrecordexistdays();
  static const int kNRecordExistDaysFieldNumber = 36;
  inline ::google::protobuf::int32 nrecordexistdays() const;
  inline void set_nrecordexistdays(::google::protobuf::int32 value);

  // required int32 nType = 37;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 37;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);

  // required string strRiskLevelDesc = 38;
  inline bool has_strriskleveldesc() const;
  inline void clear_strriskleveldesc();
  static const int kStrRiskLevelDescFieldNumber = 38;
  inline const ::std::string& strriskleveldesc() const;
  inline void set_strriskleveldesc(const ::std::string& value);
  inline void set_strriskleveldesc(const char* value);
  inline void set_strriskleveldesc(const char* value, size_t size);
  inline ::std::string* mutable_strriskleveldesc();
  inline ::std::string* release_strriskleveldesc();
  inline void set_allocated_strriskleveldesc(::std::string* strriskleveldesc);

  // required int32 nPROD_LIFECYCLE = 39;
  inline bool has_nprod_lifecycle() const;
  inline void clear_nprod_lifecycle();
  static const int kNPRODLIFECYCLEFieldNumber = 39;
  inline ::google::protobuf::int32 nprod_lifecycle() const;
  inline void set_nprod_lifecycle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.ProduceInfo)
 private:
  inline void set_has_strproduceid();
  inline void clear_has_strproduceid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strproducecode();
  inline void clear_has_strproducecode();
  inline void set_has_nperiod();
  inline void clear_has_nperiod();
  inline void set_has_strrevenue();
  inline void clear_has_strrevenue();
  inline void set_has_nminiamount();
  inline void clear_has_nminiamount();
  inline void set_has_strrisklevel();
  inline void clear_has_strrisklevel();
  inline void set_has_strserialnumber();
  inline void clear_has_strserialnumber();
  inline void set_has_strpublishbeintime();
  inline void clear_has_strpublishbeintime();
  inline void set_has_strpublishendtime();
  inline void clear_has_strpublishendtime();
  inline void set_has_strproductiontype();
  inline void clear_has_strproductiontype();
  inline void set_has_strapplicablecustomer();
  inline void clear_has_strapplicablecustomer();
  inline void set_has_strrevenuetype();
  inline void clear_has_strrevenuetype();
  inline void set_has_strincrementmoney();
  inline void clear_has_strincrementmoney();
  inline void set_has_strcurrentytype();
  inline void clear_has_strcurrentytype();
  inline void set_has_strsealsbranch();
  inline void clear_has_strsealsbranch();
  inline void set_has_strrevenueinitialday();
  inline void clear_has_strrevenueinitialday();
  inline void set_has_strdeadline();
  inline void clear_has_strdeadline();
  inline void set_has_strpaymentday();
  inline void clear_has_strpaymentday();
  inline void set_has_strtrusteefee();
  inline void clear_has_strtrusteefee();
  inline void set_has_strcommissioncharge();
  inline void clear_has_strcommissioncharge();
  inline void set_has_strtrustee();
  inline void clear_has_strtrustee();
  inline void set_has_stroverheadcharge();
  inline void clear_has_stroverheadcharge();
  inline void set_has_strrevenuecalculation();
  inline void clear_has_strrevenuecalculation();
  inline void set_has_strcontent();
  inline void clear_has_strcontent();
  inline void set_has_nmaxtime();
  inline void clear_has_nmaxtime();
  inline void set_has_nminetime();
  inline void clear_has_nminetime();
  inline void set_has_nstandardtime();
  inline void clear_has_nstandardtime();
  inline void set_has_strprequestion();
  inline void clear_has_strprequestion();
  inline void set_has_nispublished();
  inline void clear_has_nispublished();
  inline void set_has_nisenabled();
  inline void clear_has_nisenabled();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_nenablemigrated();
  inline void clear_has_nenablemigrated();
  inline void set_has_nrecordexistdays();
  inline void clear_has_nrecordexistdays();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_strriskleveldesc();
  inline void clear_has_strriskleveldesc();
  inline void set_has_nprod_lifecycle();
  inline void clear_has_nprod_lifecycle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strproduceid_;
  ::std::string* strname_;
  ::std::string* strproducecode_;
  ::std::string* strrevenue_;
  ::google::protobuf::int32 nperiod_;
  ::google::protobuf::int32 nminiamount_;
  ::std::string* strrisklevel_;
  ::std::string* strserialnumber_;
  ::std::string* strpublishbeintime_;
  ::std::string* strpublishendtime_;
  ::std::string* strproductiontype_;
  ::std::string* strapplicablecustomer_;
  ::std::string* strrevenuetype_;
  ::std::string* strincrementmoney_;
  ::std::string* strcurrentytype_;
  ::std::string* strsealsbranch_;
  ::std::string* strrevenueinitialday_;
  ::std::string* strdeadline_;
  ::std::string* strpaymentday_;
  ::std::string* strtrusteefee_;
  ::std::string* strcommissioncharge_;
  ::std::string* strtrustee_;
  ::std::string* stroverheadcharge_;
  ::std::string* strrevenuecalculation_;
  ::std::string* strcontent_;
  ::google::protobuf::int32 nmaxtime_;
  ::google::protobuf::int32 nminetime_;
  ::std::string* strprequestion_;
  ::google::protobuf::int32 nstandardtime_;
  ::google::protobuf::int32 nispublished_;
  ::google::protobuf::int32 nisenabled_;
  ::google::protobuf::int32 nextendedinfo_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nenablemigrated_;
  ::google::protobuf::int32 nrecordexistdays_;
  ::std::string* strriskleveldesc_;
  ::google::protobuf::int32 ntype_;
  ::google::protobuf::int32 nprod_lifecycle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static ProduceInfo* default_instance_;
};
// -------------------------------------------------------------------

class BranchInfo : public ::google::protobuf::Message {
 public:
  BranchInfo();
  virtual ~BranchInfo();

  BranchInfo(const BranchInfo& from);

  inline BranchInfo& operator=(const BranchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BranchInfo& default_instance();

  void Swap(BranchInfo* other);

  // implements Message ----------------------------------------------

  BranchInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BranchInfo& from);
  void MergeFrom(const BranchInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strBranchId = 1;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchIdFieldNumber = 1;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string strName = 2;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 2;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  inline void set_allocated_strname(::std::string* strname);

  // required string strAddress = 3;
  inline bool has_straddress() const;
  inline void clear_straddress();
  static const int kStrAddressFieldNumber = 3;
  inline const ::std::string& straddress() const;
  inline void set_straddress(const ::std::string& value);
  inline void set_straddress(const char* value);
  inline void set_straddress(const char* value, size_t size);
  inline ::std::string* mutable_straddress();
  inline ::std::string* release_straddress();
  inline void set_allocated_straddress(::std::string* straddress);

  // required string strContact = 4;
  inline bool has_strcontact() const;
  inline void clear_strcontact();
  static const int kStrContactFieldNumber = 4;
  inline const ::std::string& strcontact() const;
  inline void set_strcontact(const ::std::string& value);
  inline void set_strcontact(const char* value);
  inline void set_strcontact(const char* value, size_t size);
  inline ::std::string* mutable_strcontact();
  inline ::std::string* release_strcontact();
  inline void set_allocated_strcontact(::std::string* strcontact);

  // required string strPhone = 5;
  inline bool has_strphone() const;
  inline void clear_strphone();
  static const int kStrPhoneFieldNumber = 5;
  inline const ::std::string& strphone() const;
  inline void set_strphone(const ::std::string& value);
  inline void set_strphone(const char* value);
  inline void set_strphone(const char* value, size_t size);
  inline ::std::string* mutable_strphone();
  inline ::std::string* release_strphone();
  inline void set_allocated_strphone(::std::string* strphone);

  // required string strContent = 6;
  inline bool has_strcontent() const;
  inline void clear_strcontent();
  static const int kStrContentFieldNumber = 6;
  inline const ::std::string& strcontent() const;
  inline void set_strcontent(const ::std::string& value);
  inline void set_strcontent(const char* value);
  inline void set_strcontent(const char* value, size_t size);
  inline ::std::string* mutable_strcontent();
  inline ::std::string* release_strcontent();
  inline void set_allocated_strcontent(::std::string* strcontent);

  // required int32 nExtendedInfo = 7;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 7;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 8;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 8;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 9;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 9;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required string strParentId = 10;
  inline bool has_strparentid() const;
  inline void clear_strparentid();
  static const int kStrParentIdFieldNumber = 10;
  inline const ::std::string& strparentid() const;
  inline void set_strparentid(const ::std::string& value);
  inline void set_strparentid(const char* value);
  inline void set_strparentid(const char* value, size_t size);
  inline ::std::string* mutable_strparentid();
  inline ::std::string* release_strparentid();
  inline void set_allocated_strparentid(::std::string* strparentid);

  // required int32 nIsLocal = 11;
  inline bool has_nislocal() const;
  inline void clear_nislocal();
  static const int kNIsLocalFieldNumber = 11;
  inline ::google::protobuf::int32 nislocal() const;
  inline void set_nislocal(::google::protobuf::int32 value);

  // required string strJDBRID = 12;
  inline bool has_strjdbrid() const;
  inline void clear_strjdbrid();
  static const int kStrJDBRIDFieldNumber = 12;
  inline const ::std::string& strjdbrid() const;
  inline void set_strjdbrid(const ::std::string& value);
  inline void set_strjdbrid(const char* value);
  inline void set_strjdbrid(const char* value, size_t size);
  inline ::std::string* mutable_strjdbrid();
  inline ::std::string* release_strjdbrid();
  inline void set_allocated_strjdbrid(::std::string* strjdbrid);

  // required string strParentJDBRID = 13;
  inline bool has_strparentjdbrid() const;
  inline void clear_strparentjdbrid();
  static const int kStrParentJDBRIDFieldNumber = 13;
  inline const ::std::string& strparentjdbrid() const;
  inline void set_strparentjdbrid(const ::std::string& value);
  inline void set_strparentjdbrid(const char* value);
  inline void set_strparentjdbrid(const char* value, size_t size);
  inline ::std::string* mutable_strparentjdbrid();
  inline ::std::string* release_strparentjdbrid();
  inline void set_allocated_strparentjdbrid(::std::string* strparentjdbrid);

  // required string strParentName = 14;
  inline bool has_strparentname() const;
  inline void clear_strparentname();
  static const int kStrParentNameFieldNumber = 14;
  inline const ::std::string& strparentname() const;
  inline void set_strparentname(const ::std::string& value);
  inline void set_strparentname(const char* value);
  inline void set_strparentname(const char* value, size_t size);
  inline ::std::string* mutable_strparentname();
  inline ::std::string* release_strparentname();
  inline void set_allocated_strparentname(::std::string* strparentname);

  // required string strJDTYPE = 15;
  inline bool has_strjdtype() const;
  inline void clear_strjdtype();
  static const int kStrJDTYPEFieldNumber = 15;
  inline const ::std::string& strjdtype() const;
  inline void set_strjdtype(const ::std::string& value);
  inline void set_strjdtype(const char* value);
  inline void set_strjdtype(const char* value, size_t size);
  inline ::std::string* mutable_strjdtype();
  inline ::std::string* release_strjdtype();
  inline void set_allocated_strjdtype(::std::string* strjdtype);

  // @@protoc_insertion_point(class_scope:BFIS.BranchInfo)
 private:
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_straddress();
  inline void clear_has_straddress();
  inline void set_has_strcontact();
  inline void clear_has_strcontact();
  inline void set_has_strphone();
  inline void clear_has_strphone();
  inline void set_has_strcontent();
  inline void clear_has_strcontent();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_strparentid();
  inline void clear_has_strparentid();
  inline void set_has_nislocal();
  inline void clear_has_nislocal();
  inline void set_has_strjdbrid();
  inline void clear_has_strjdbrid();
  inline void set_has_strparentjdbrid();
  inline void clear_has_strparentjdbrid();
  inline void set_has_strparentname();
  inline void clear_has_strparentname();
  inline void set_has_strjdtype();
  inline void clear_has_strjdtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbranchid_;
  ::std::string* strname_;
  ::std::string* straddress_;
  ::std::string* strcontact_;
  ::std::string* strphone_;
  ::std::string* strcontent_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;
  ::google::protobuf::int32 nislocal_;
  ::std::string* strparentid_;
  ::std::string* strjdbrid_;
  ::std::string* strparentjdbrid_;
  ::std::string* strparentname_;
  ::std::string* strjdtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BranchInfo* default_instance_;
};
// -------------------------------------------------------------------

class BusinessFileInfo : public ::google::protobuf::Message {
 public:
  BusinessFileInfo();
  virtual ~BusinessFileInfo();

  BusinessFileInfo(const BusinessFileInfo& from);

  inline BusinessFileInfo& operator=(const BusinessFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessFileInfo& default_instance();

  void Swap(BusinessFileInfo* other);

  // implements Message ----------------------------------------------

  BusinessFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessFileInfo& from);
  void MergeFrom(const BusinessFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strRecordId = 1;
  inline bool has_strrecordid() const;
  inline void clear_strrecordid();
  static const int kStrRecordIdFieldNumber = 1;
  inline const ::std::string& strrecordid() const;
  inline void set_strrecordid(const ::std::string& value);
  inline void set_strrecordid(const char* value);
  inline void set_strrecordid(const char* value, size_t size);
  inline ::std::string* mutable_strrecordid();
  inline ::std::string* release_strrecordid();
  inline void set_allocated_strrecordid(::std::string* strrecordid);

  // required string strBusinessInfoId = 2;
  inline bool has_strbusinessinfoid() const;
  inline void clear_strbusinessinfoid();
  static const int kStrBusinessInfoIdFieldNumber = 2;
  inline const ::std::string& strbusinessinfoid() const;
  inline void set_strbusinessinfoid(const ::std::string& value);
  inline void set_strbusinessinfoid(const char* value);
  inline void set_strbusinessinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessinfoid();
  inline ::std::string* release_strbusinessinfoid();
  inline void set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid);

  // required int32 nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);

  // required string strFileId = 4;
  inline bool has_strfileid() const;
  inline void clear_strfileid();
  static const int kStrFileIdFieldNumber = 4;
  inline const ::std::string& strfileid() const;
  inline void set_strfileid(const ::std::string& value);
  inline void set_strfileid(const char* value);
  inline void set_strfileid(const char* value, size_t size);
  inline ::std::string* mutable_strfileid();
  inline ::std::string* release_strfileid();
  inline void set_allocated_strfileid(::std::string* strfileid);

  // required string strRecordBegin = 5;
  inline bool has_strrecordbegin() const;
  inline void clear_strrecordbegin();
  static const int kStrRecordBeginFieldNumber = 5;
  inline const ::std::string& strrecordbegin() const;
  inline void set_strrecordbegin(const ::std::string& value);
  inline void set_strrecordbegin(const char* value);
  inline void set_strrecordbegin(const char* value, size_t size);
  inline ::std::string* mutable_strrecordbegin();
  inline ::std::string* release_strrecordbegin();
  inline void set_allocated_strrecordbegin(::std::string* strrecordbegin);

  // required string strRecordEnd = 6;
  inline bool has_strrecordend() const;
  inline void clear_strrecordend();
  static const int kStrRecordEndFieldNumber = 6;
  inline const ::std::string& strrecordend() const;
  inline void set_strrecordend(const ::std::string& value);
  inline void set_strrecordend(const char* value);
  inline void set_strrecordend(const char* value, size_t size);
  inline ::std::string* mutable_strrecordend();
  inline ::std::string* release_strrecordend();
  inline void set_allocated_strrecordend(::std::string* strrecordend);

  // required int32 nExtendedInfo = 7;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 7;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 8;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 8;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 9;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 9;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required int32 nMigrated = 10;
  inline bool has_nmigrated() const;
  inline void clear_nmigrated();
  static const int kNMigratedFieldNumber = 10;
  inline ::google::protobuf::int32 nmigrated() const;
  inline void set_nmigrated(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.BusinessFileInfo)
 private:
  inline void set_has_strrecordid();
  inline void clear_has_strrecordid();
  inline void set_has_strbusinessinfoid();
  inline void clear_has_strbusinessinfoid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_strfileid();
  inline void clear_has_strfileid();
  inline void set_has_strrecordbegin();
  inline void clear_has_strrecordbegin();
  inline void set_has_strrecordend();
  inline void clear_has_strrecordend();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_nmigrated();
  inline void clear_has_nmigrated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strrecordid_;
  ::std::string* strbusinessinfoid_;
  ::std::string* strfileid_;
  ::std::string* strrecordbegin_;
  ::google::protobuf::int32 ntype_;
  ::google::protobuf::int32 nextendedinfo_;
  ::std::string* strrecordend_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nmigrated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BusinessFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class BusinessRelateInfo : public ::google::protobuf::Message {
 public:
  BusinessRelateInfo();
  virtual ~BusinessRelateInfo();

  BusinessRelateInfo(const BusinessRelateInfo& from);

  inline BusinessRelateInfo& operator=(const BusinessRelateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessRelateInfo& default_instance();

  void Swap(BusinessRelateInfo* other);

  // implements Message ----------------------------------------------

  BusinessRelateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessRelateInfo& from);
  void MergeFrom(const BusinessRelateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strBusinessRelateInfoId = 1;
  inline bool has_strbusinessrelateinfoid() const;
  inline void clear_strbusinessrelateinfoid();
  static const int kStrBusinessRelateInfoIdFieldNumber = 1;
  inline const ::std::string& strbusinessrelateinfoid() const;
  inline void set_strbusinessrelateinfoid(const ::std::string& value);
  inline void set_strbusinessrelateinfoid(const char* value);
  inline void set_strbusinessrelateinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessrelateinfoid();
  inline ::std::string* release_strbusinessrelateinfoid();
  inline void set_allocated_strbusinessrelateinfoid(::std::string* strbusinessrelateinfoid);

  // required string strBusinessInfoId = 2;
  inline bool has_strbusinessinfoid() const;
  inline void clear_strbusinessinfoid();
  static const int kStrBusinessInfoIdFieldNumber = 2;
  inline const ::std::string& strbusinessinfoid() const;
  inline void set_strbusinessinfoid(const ::std::string& value);
  inline void set_strbusinessinfoid(const char* value);
  inline void set_strbusinessinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessinfoid();
  inline ::std::string* release_strbusinessinfoid();
  inline void set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid);

  // required int32 nRelateType = 3;
  inline bool has_nrelatetype() const;
  inline void clear_nrelatetype();
  static const int kNRelateTypeFieldNumber = 3;
  inline ::google::protobuf::int32 nrelatetype() const;
  inline void set_nrelatetype(::google::protobuf::int32 value);

  // required string strRelate1 = 4;
  inline bool has_strrelate1() const;
  inline void clear_strrelate1();
  static const int kStrRelate1FieldNumber = 4;
  inline const ::std::string& strrelate1() const;
  inline void set_strrelate1(const ::std::string& value);
  inline void set_strrelate1(const char* value);
  inline void set_strrelate1(const char* value, size_t size);
  inline ::std::string* mutable_strrelate1();
  inline ::std::string* release_strrelate1();
  inline void set_allocated_strrelate1(::std::string* strrelate1);

  // required string strRelate2 = 5;
  inline bool has_strrelate2() const;
  inline void clear_strrelate2();
  static const int kStrRelate2FieldNumber = 5;
  inline const ::std::string& strrelate2() const;
  inline void set_strrelate2(const ::std::string& value);
  inline void set_strrelate2(const char* value);
  inline void set_strrelate2(const char* value, size_t size);
  inline ::std::string* mutable_strrelate2();
  inline ::std::string* release_strrelate2();
  inline void set_allocated_strrelate2(::std::string* strrelate2);

  // required string strRelate3 = 6;
  inline bool has_strrelate3() const;
  inline void clear_strrelate3();
  static const int kStrRelate3FieldNumber = 6;
  inline const ::std::string& strrelate3() const;
  inline void set_strrelate3(const ::std::string& value);
  inline void set_strrelate3(const char* value);
  inline void set_strrelate3(const char* value, size_t size);
  inline ::std::string* mutable_strrelate3();
  inline ::std::string* release_strrelate3();
  inline void set_allocated_strrelate3(::std::string* strrelate3);

  // @@protoc_insertion_point(class_scope:BFIS.BusinessRelateInfo)
 private:
  inline void set_has_strbusinessrelateinfoid();
  inline void clear_has_strbusinessrelateinfoid();
  inline void set_has_strbusinessinfoid();
  inline void clear_has_strbusinessinfoid();
  inline void set_has_nrelatetype();
  inline void clear_has_nrelatetype();
  inline void set_has_strrelate1();
  inline void clear_has_strrelate1();
  inline void set_has_strrelate2();
  inline void clear_has_strrelate2();
  inline void set_has_strrelate3();
  inline void clear_has_strrelate3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbusinessrelateinfoid_;
  ::std::string* strbusinessinfoid_;
  ::std::string* strrelate1_;
  ::std::string* strrelate2_;
  ::std::string* strrelate3_;
  ::google::protobuf::int32 nrelatetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BusinessRelateInfo* default_instance_;
};
// -------------------------------------------------------------------

class EmployeeInfo : public ::google::protobuf::Message {
 public:
  EmployeeInfo();
  virtual ~EmployeeInfo();

  EmployeeInfo(const EmployeeInfo& from);

  inline EmployeeInfo& operator=(const EmployeeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmployeeInfo& default_instance();

  void Swap(EmployeeInfo* other);

  // implements Message ----------------------------------------------

  EmployeeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmployeeInfo& from);
  void MergeFrom(const EmployeeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strEmployeeId = 1;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeIdFieldNumber = 1;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strBranchId = 2;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchIdFieldNumber = 2;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string strName = 3;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 3;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  inline void set_allocated_strname(::std::string* strname);

  // required string strPassword = 4;
  inline bool has_strpassword() const;
  inline void clear_strpassword();
  static const int kStrPasswordFieldNumber = 4;
  inline const ::std::string& strpassword() const;
  inline void set_strpassword(const ::std::string& value);
  inline void set_strpassword(const char* value);
  inline void set_strpassword(const char* value, size_t size);
  inline ::std::string* mutable_strpassword();
  inline ::std::string* release_strpassword();
  inline void set_allocated_strpassword(::std::string* strpassword);

  // required string strCardId = 5;
  inline bool has_strcardid() const;
  inline void clear_strcardid();
  static const int kStrCardIdFieldNumber = 5;
  inline const ::std::string& strcardid() const;
  inline void set_strcardid(const ::std::string& value);
  inline void set_strcardid(const char* value);
  inline void set_strcardid(const char* value, size_t size);
  inline ::std::string* mutable_strcardid();
  inline ::std::string* release_strcardid();
  inline void set_allocated_strcardid(::std::string* strcardid);

  // required string strRoleId = 6;
  inline bool has_strroleid() const;
  inline void clear_strroleid();
  static const int kStrRoleIdFieldNumber = 6;
  inline const ::std::string& strroleid() const;
  inline void set_strroleid(const ::std::string& value);
  inline void set_strroleid(const char* value);
  inline void set_strroleid(const char* value, size_t size);
  inline ::std::string* mutable_strroleid();
  inline ::std::string* release_strroleid();
  inline void set_allocated_strroleid(::std::string* strroleid);

  // required string strPhone = 7;
  inline bool has_strphone() const;
  inline void clear_strphone();
  static const int kStrPhoneFieldNumber = 7;
  inline const ::std::string& strphone() const;
  inline void set_strphone(const ::std::string& value);
  inline void set_strphone(const char* value);
  inline void set_strphone(const char* value, size_t size);
  inline ::std::string* mutable_strphone();
  inline ::std::string* release_strphone();
  inline void set_allocated_strphone(::std::string* strphone);

  // required int32 nExtendedInfo = 8;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 8;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 9;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 9;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 10;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 10;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required int32 nFlag = 11;
  inline bool has_nflag() const;
  inline void clear_nflag();
  static const int kNFlagFieldNumber = 11;
  inline ::google::protobuf::int32 nflag() const;
  inline void set_nflag(::google::protobuf::int32 value);

  // required string stPasswordEidtTime = 12;
  inline bool has_stpasswordeidttime() const;
  inline void clear_stpasswordeidttime();
  static const int kStPasswordEidtTimeFieldNumber = 12;
  inline const ::std::string& stpasswordeidttime() const;
  inline void set_stpasswordeidttime(const ::std::string& value);
  inline void set_stpasswordeidttime(const char* value);
  inline void set_stpasswordeidttime(const char* value, size_t size);
  inline ::std::string* mutable_stpasswordeidttime();
  inline ::std::string* release_stpasswordeidttime();
  inline void set_allocated_stpasswordeidttime(::std::string* stpasswordeidttime);

  // required string strJDBRID = 13;
  inline bool has_strjdbrid() const;
  inline void clear_strjdbrid();
  static const int kStrJDBRIDFieldNumber = 13;
  inline const ::std::string& strjdbrid() const;
  inline void set_strjdbrid(const ::std::string& value);
  inline void set_strjdbrid(const char* value);
  inline void set_strjdbrid(const char* value, size_t size);
  inline ::std::string* mutable_strjdbrid();
  inline ::std::string* release_strjdbrid();
  inline void set_allocated_strjdbrid(::std::string* strjdbrid);

  // required string strTLNUM = 14;
  inline bool has_strtlnum() const;
  inline void clear_strtlnum();
  static const int kStrTLNUMFieldNumber = 14;
  inline const ::std::string& strtlnum() const;
  inline void set_strtlnum(const ::std::string& value);
  inline void set_strtlnum(const char* value);
  inline void set_strtlnum(const char* value, size_t size);
  inline ::std::string* mutable_strtlnum();
  inline ::std::string* release_strtlnum();
  inline void set_allocated_strtlnum(::std::string* strtlnum);

  // required string strTEL = 15;
  inline bool has_strtel() const;
  inline void clear_strtel();
  static const int kStrTELFieldNumber = 15;
  inline const ::std::string& strtel() const;
  inline void set_strtel(const ::std::string& value);
  inline void set_strtel(const char* value);
  inline void set_strtel(const char* value, size_t size);
  inline ::std::string* mutable_strtel();
  inline ::std::string* release_strtel();
  inline void set_allocated_strtel(::std::string* strtel);

  // required string strGW = 16;
  inline bool has_strgw() const;
  inline void clear_strgw();
  static const int kStrGWFieldNumber = 16;
  inline const ::std::string& strgw() const;
  inline void set_strgw(const ::std::string& value);
  inline void set_strgw(const char* value);
  inline void set_strgw(const char* value, size_t size);
  inline ::std::string* mutable_strgw();
  inline ::std::string* release_strgw();
  inline void set_allocated_strgw(::std::string* strgw);

  // required string strSTS = 17;
  inline bool has_strsts() const;
  inline void clear_strsts();
  static const int kStrSTSFieldNumber = 17;
  inline const ::std::string& strsts() const;
  inline void set_strsts(const ::std::string& value);
  inline void set_strsts(const char* value);
  inline void set_strsts(const char* value, size_t size);
  inline ::std::string* mutable_strsts();
  inline ::std::string* release_strsts();
  inline void set_allocated_strsts(::std::string* strsts);

  // required string strTLINST = 18;
  inline bool has_strtlinst() const;
  inline void clear_strtlinst();
  static const int kStrTLINSTFieldNumber = 18;
  inline const ::std::string& strtlinst() const;
  inline void set_strtlinst(const ::std::string& value);
  inline void set_strtlinst(const char* value);
  inline void set_strtlinst(const char* value, size_t size);
  inline ::std::string* mutable_strtlinst();
  inline ::std::string* release_strtlinst();
  inline void set_allocated_strtlinst(::std::string* strtlinst);

  // required string strUSERNAME = 19;
  inline bool has_strusername() const;
  inline void clear_strusername();
  static const int kStrUSERNAMEFieldNumber = 19;
  inline const ::std::string& strusername() const;
  inline void set_strusername(const ::std::string& value);
  inline void set_strusername(const char* value);
  inline void set_strusername(const char* value, size_t size);
  inline ::std::string* mutable_strusername();
  inline ::std::string* release_strusername();
  inline void set_allocated_strusername(::std::string* strusername);

  // required string strROLENAME = 20;
  inline bool has_strrolename() const;
  inline void clear_strrolename();
  static const int kStrROLENAMEFieldNumber = 20;
  inline const ::std::string& strrolename() const;
  inline void set_strrolename(const ::std::string& value);
  inline void set_strrolename(const char* value);
  inline void set_strrolename(const char* value, size_t size);
  inline ::std::string* mutable_strrolename();
  inline ::std::string* release_strrolename();
  inline void set_allocated_strrolename(::std::string* strrolename);

  // required string strUSERSTATUS = 21;
  inline bool has_struserstatus() const;
  inline void clear_struserstatus();
  static const int kStrUSERSTATUSFieldNumber = 21;
  inline const ::std::string& struserstatus() const;
  inline void set_struserstatus(const ::std::string& value);
  inline void set_struserstatus(const char* value);
  inline void set_struserstatus(const char* value, size_t size);
  inline ::std::string* mutable_struserstatus();
  inline ::std::string* release_struserstatus();
  inline void set_allocated_struserstatus(::std::string* struserstatus);

  // required int32 nPassErrorCount = 22;
  inline bool has_npasserrorcount() const;
  inline void clear_npasserrorcount();
  static const int kNPassErrorCountFieldNumber = 22;
  inline ::google::protobuf::int32 npasserrorcount() const;
  inline void set_npasserrorcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.EmployeeInfo)
 private:
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strpassword();
  inline void clear_has_strpassword();
  inline void set_has_strcardid();
  inline void clear_has_strcardid();
  inline void set_has_strroleid();
  inline void clear_has_strroleid();
  inline void set_has_strphone();
  inline void clear_has_strphone();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_nflag();
  inline void clear_has_nflag();
  inline void set_has_stpasswordeidttime();
  inline void clear_has_stpasswordeidttime();
  inline void set_has_strjdbrid();
  inline void clear_has_strjdbrid();
  inline void set_has_strtlnum();
  inline void clear_has_strtlnum();
  inline void set_has_strtel();
  inline void clear_has_strtel();
  inline void set_has_strgw();
  inline void clear_has_strgw();
  inline void set_has_strsts();
  inline void clear_has_strsts();
  inline void set_has_strtlinst();
  inline void clear_has_strtlinst();
  inline void set_has_strusername();
  inline void clear_has_strusername();
  inline void set_has_strrolename();
  inline void clear_has_strrolename();
  inline void set_has_struserstatus();
  inline void clear_has_struserstatus();
  inline void set_has_npasserrorcount();
  inline void clear_has_npasserrorcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stremployeeid_;
  ::std::string* strbranchid_;
  ::std::string* strname_;
  ::std::string* strpassword_;
  ::std::string* strcardid_;
  ::std::string* strroleid_;
  ::std::string* strphone_;
  ::std::string* strextendedinfo1_;
  ::google::protobuf::int32 nextendedinfo_;
  ::google::protobuf::int32 nflag_;
  ::std::string* strextendedinfo2_;
  ::std::string* stpasswordeidttime_;
  ::std::string* strjdbrid_;
  ::std::string* strtlnum_;
  ::std::string* strtel_;
  ::std::string* strgw_;
  ::std::string* strsts_;
  ::std::string* strtlinst_;
  ::std::string* strusername_;
  ::std::string* strrolename_;
  ::std::string* struserstatus_;
  ::google::protobuf::int32 npasserrorcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static EmployeeInfo* default_instance_;
};
// -------------------------------------------------------------------

class EmployeePurviewInfo : public ::google::protobuf::Message {
 public:
  EmployeePurviewInfo();
  virtual ~EmployeePurviewInfo();

  EmployeePurviewInfo(const EmployeePurviewInfo& from);

  inline EmployeePurviewInfo& operator=(const EmployeePurviewInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmployeePurviewInfo& default_instance();

  void Swap(EmployeePurviewInfo* other);

  // implements Message ----------------------------------------------

  EmployeePurviewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmployeePurviewInfo& from);
  void MergeFrom(const EmployeePurviewInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strEmployeePurviewId = 1;
  inline bool has_stremployeepurviewid() const;
  inline void clear_stremployeepurviewid();
  static const int kStrEmployeePurviewIdFieldNumber = 1;
  inline const ::std::string& stremployeepurviewid() const;
  inline void set_stremployeepurviewid(const ::std::string& value);
  inline void set_stremployeepurviewid(const char* value);
  inline void set_stremployeepurviewid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeepurviewid();
  inline ::std::string* release_stremployeepurviewid();
  inline void set_allocated_stremployeepurviewid(::std::string* stremployeepurviewid);

  // required string strEmployeeId = 2;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeIdFieldNumber = 2;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strPurviewInfoId = 3;
  inline bool has_strpurviewinfoid() const;
  inline void clear_strpurviewinfoid();
  static const int kStrPurviewInfoIdFieldNumber = 3;
  inline const ::std::string& strpurviewinfoid() const;
  inline void set_strpurviewinfoid(const ::std::string& value);
  inline void set_strpurviewinfoid(const char* value);
  inline void set_strpurviewinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strpurviewinfoid();
  inline ::std::string* release_strpurviewinfoid();
  inline void set_allocated_strpurviewinfoid(::std::string* strpurviewinfoid);

  // required int32 nExtendedInfo = 4;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 4;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 5;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 5;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 6;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 6;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.EmployeePurviewInfo)
 private:
  inline void set_has_stremployeepurviewid();
  inline void clear_has_stremployeepurviewid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strpurviewinfoid();
  inline void clear_has_strpurviewinfoid();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stremployeepurviewid_;
  ::std::string* stremployeeid_;
  ::std::string* strpurviewinfoid_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static EmployeePurviewInfo* default_instance_;
};
// -------------------------------------------------------------------

class EmployeePurviewInfoList : public ::google::protobuf::Message {
 public:
  EmployeePurviewInfoList();
  virtual ~EmployeePurviewInfoList();

  EmployeePurviewInfoList(const EmployeePurviewInfoList& from);

  inline EmployeePurviewInfoList& operator=(const EmployeePurviewInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmployeePurviewInfoList& default_instance();

  void Swap(EmployeePurviewInfoList* other);

  // implements Message ----------------------------------------------

  EmployeePurviewInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmployeePurviewInfoList& from);
  void MergeFrom(const EmployeePurviewInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nEmployeePurviewSize = 1;
  inline bool has_nemployeepurviewsize() const;
  inline void clear_nemployeepurviewsize();
  static const int kNEmployeePurviewSizeFieldNumber = 1;
  inline ::google::protobuf::int32 nemployeepurviewsize() const;
  inline void set_nemployeepurviewsize(::google::protobuf::int32 value);

  // repeated .BFIS.EmployeePurviewInfo vecEmployeePurview = 2;
  inline int vecemployeepurview_size() const;
  inline void clear_vecemployeepurview();
  static const int kVecEmployeePurviewFieldNumber = 2;
  inline const ::BFIS::EmployeePurviewInfo& vecemployeepurview(int index) const;
  inline ::BFIS::EmployeePurviewInfo* mutable_vecemployeepurview(int index);
  inline ::BFIS::EmployeePurviewInfo* add_vecemployeepurview();
  inline const ::google::protobuf::RepeatedPtrField< ::BFIS::EmployeePurviewInfo >&
      vecemployeepurview() const;
  inline ::google::protobuf::RepeatedPtrField< ::BFIS::EmployeePurviewInfo >*
      mutable_vecemployeepurview();

  // optional int32 nStateSign = 3 [default = 0];
  inline bool has_nstatesign() const;
  inline void clear_nstatesign();
  static const int kNStateSignFieldNumber = 3;
  inline ::google::protobuf::int32 nstatesign() const;
  inline void set_nstatesign(::google::protobuf::int32 value);

  // optional int32 nReserved = 4 [default = 0];
  inline bool has_nreserved() const;
  inline void clear_nreserved();
  static const int kNReservedFieldNumber = 4;
  inline ::google::protobuf::int32 nreserved() const;
  inline void set_nreserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.EmployeePurviewInfoList)
 private:
  inline void set_has_nemployeepurviewsize();
  inline void clear_has_nemployeepurviewsize();
  inline void set_has_nstatesign();
  inline void clear_has_nstatesign();
  inline void set_has_nreserved();
  inline void clear_has_nreserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::BFIS::EmployeePurviewInfo > vecemployeepurview_;
  ::google::protobuf::int32 nemployeepurviewsize_;
  ::google::protobuf::int32 nstatesign_;
  ::google::protobuf::int32 nreserved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static EmployeePurviewInfoList* default_instance_;
};
// -------------------------------------------------------------------

class PurviewInfo : public ::google::protobuf::Message {
 public:
  PurviewInfo();
  virtual ~PurviewInfo();

  PurviewInfo(const PurviewInfo& from);

  inline PurviewInfo& operator=(const PurviewInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PurviewInfo& default_instance();

  void Swap(PurviewInfo* other);

  // implements Message ----------------------------------------------

  PurviewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PurviewInfo& from);
  void MergeFrom(const PurviewInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strPurviewInfoId = 1;
  inline bool has_strpurviewinfoid() const;
  inline void clear_strpurviewinfoid();
  static const int kStrPurviewInfoIdFieldNumber = 1;
  inline const ::std::string& strpurviewinfoid() const;
  inline void set_strpurviewinfoid(const ::std::string& value);
  inline void set_strpurviewinfoid(const char* value);
  inline void set_strpurviewinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strpurviewinfoid();
  inline ::std::string* release_strpurviewinfoid();
  inline void set_allocated_strpurviewinfoid(::std::string* strpurviewinfoid);

  // required string strParentPurviewId = 2;
  inline bool has_strparentpurviewid() const;
  inline void clear_strparentpurviewid();
  static const int kStrParentPurviewIdFieldNumber = 2;
  inline const ::std::string& strparentpurviewid() const;
  inline void set_strparentpurviewid(const ::std::string& value);
  inline void set_strparentpurviewid(const char* value);
  inline void set_strparentpurviewid(const char* value, size_t size);
  inline ::std::string* mutable_strparentpurviewid();
  inline ::std::string* release_strparentpurviewid();
  inline void set_allocated_strparentpurviewid(::std::string* strparentpurviewid);

  // required string strPurviewCode = 3;
  inline bool has_strpurviewcode() const;
  inline void clear_strpurviewcode();
  static const int kStrPurviewCodeFieldNumber = 3;
  inline const ::std::string& strpurviewcode() const;
  inline void set_strpurviewcode(const ::std::string& value);
  inline void set_strpurviewcode(const char* value);
  inline void set_strpurviewcode(const char* value, size_t size);
  inline ::std::string* mutable_strpurviewcode();
  inline ::std::string* release_strpurviewcode();
  inline void set_allocated_strpurviewcode(::std::string* strpurviewcode);

  // required string strDescription = 4;
  inline bool has_strdescription() const;
  inline void clear_strdescription();
  static const int kStrDescriptionFieldNumber = 4;
  inline const ::std::string& strdescription() const;
  inline void set_strdescription(const ::std::string& value);
  inline void set_strdescription(const char* value);
  inline void set_strdescription(const char* value, size_t size);
  inline ::std::string* mutable_strdescription();
  inline ::std::string* release_strdescription();
  inline void set_allocated_strdescription(::std::string* strdescription);

  // required string strExtendedInfo1 = 5;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 5;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 6;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 6;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.PurviewInfo)
 private:
  inline void set_has_strpurviewinfoid();
  inline void clear_has_strpurviewinfoid();
  inline void set_has_strparentpurviewid();
  inline void clear_has_strparentpurviewid();
  inline void set_has_strpurviewcode();
  inline void clear_has_strpurviewcode();
  inline void set_has_strdescription();
  inline void clear_has_strdescription();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strpurviewinfoid_;
  ::std::string* strparentpurviewid_;
  ::std::string* strpurviewcode_;
  ::std::string* strdescription_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static PurviewInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoleInfo : public ::google::protobuf::Message {
 public:
  RoleInfo();
  virtual ~RoleInfo();

  RoleInfo(const RoleInfo& from);

  inline RoleInfo& operator=(const RoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleInfo& default_instance();

  void Swap(RoleInfo* other);

  // implements Message ----------------------------------------------

  RoleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleInfo& from);
  void MergeFrom(const RoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strRoleInfoId = 1;
  inline bool has_strroleinfoid() const;
  inline void clear_strroleinfoid();
  static const int kStrRoleInfoIdFieldNumber = 1;
  inline const ::std::string& strroleinfoid() const;
  inline void set_strroleinfoid(const ::std::string& value);
  inline void set_strroleinfoid(const char* value);
  inline void set_strroleinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strroleinfoid();
  inline ::std::string* release_strroleinfoid();
  inline void set_allocated_strroleinfoid(::std::string* strroleinfoid);

  // required string strRoleName = 2;
  inline bool has_strrolename() const;
  inline void clear_strrolename();
  static const int kStrRoleNameFieldNumber = 2;
  inline const ::std::string& strrolename() const;
  inline void set_strrolename(const ::std::string& value);
  inline void set_strrolename(const char* value);
  inline void set_strrolename(const char* value, size_t size);
  inline ::std::string* mutable_strrolename();
  inline ::std::string* release_strrolename();
  inline void set_allocated_strrolename(::std::string* strrolename);

  // required int32 nRoleLevel = 3;
  inline bool has_nrolelevel() const;
  inline void clear_nrolelevel();
  static const int kNRoleLevelFieldNumber = 3;
  inline ::google::protobuf::int32 nrolelevel() const;
  inline void set_nrolelevel(::google::protobuf::int32 value);

  // required int32 nExtendedInfo = 4;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 4;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 5;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 5;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 6;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 6;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // required string strBranchInfoId = 7;
  inline bool has_strbranchinfoid() const;
  inline void clear_strbranchinfoid();
  static const int kStrBranchInfoIdFieldNumber = 7;
  inline const ::std::string& strbranchinfoid() const;
  inline void set_strbranchinfoid(const ::std::string& value);
  inline void set_strbranchinfoid(const char* value);
  inline void set_strbranchinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchinfoid();
  inline ::std::string* release_strbranchinfoid();
  inline void set_allocated_strbranchinfoid(::std::string* strbranchinfoid);

  // required int32 nFlag = 8;
  inline bool has_nflag() const;
  inline void clear_nflag();
  static const int kNFlagFieldNumber = 8;
  inline ::google::protobuf::int32 nflag() const;
  inline void set_nflag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.RoleInfo)
 private:
  inline void set_has_strroleinfoid();
  inline void clear_has_strroleinfoid();
  inline void set_has_strrolename();
  inline void clear_has_strrolename();
  inline void set_has_nrolelevel();
  inline void clear_has_nrolelevel();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();
  inline void set_has_strbranchinfoid();
  inline void clear_has_strbranchinfoid();
  inline void set_has_nflag();
  inline void clear_has_nflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strroleinfoid_;
  ::std::string* strrolename_;
  ::google::protobuf::int32 nrolelevel_;
  ::google::protobuf::int32 nextendedinfo_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::std::string* strbranchinfoid_;
  ::google::protobuf::int32 nflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static RoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserMapInfo : public ::google::protobuf::Message {
 public:
  UserMapInfo();
  virtual ~UserMapInfo();

  UserMapInfo(const UserMapInfo& from);

  inline UserMapInfo& operator=(const UserMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMapInfo& default_instance();

  void Swap(UserMapInfo* other);

  // implements Message ----------------------------------------------

  UserMapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserMapInfo& from);
  void MergeFrom(const UserMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strUsermapinfoid = 1;
  inline bool has_strusermapinfoid() const;
  inline void clear_strusermapinfoid();
  static const int kStrUsermapinfoidFieldNumber = 1;
  inline const ::std::string& strusermapinfoid() const;
  inline void set_strusermapinfoid(const ::std::string& value);
  inline void set_strusermapinfoid(const char* value);
  inline void set_strusermapinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strusermapinfoid();
  inline ::std::string* release_strusermapinfoid();
  inline void set_allocated_strusermapinfoid(::std::string* strusermapinfoid);

  // required string strEmployeeid = 2;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeidFieldNumber = 2;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strSocusername = 3;
  inline bool has_strsocusername() const;
  inline void clear_strsocusername();
  static const int kStrSocusernameFieldNumber = 3;
  inline const ::std::string& strsocusername() const;
  inline void set_strsocusername(const ::std::string& value);
  inline void set_strsocusername(const char* value);
  inline void set_strsocusername(const char* value, size_t size);
  inline ::std::string* mutable_strsocusername();
  inline ::std::string* release_strsocusername();
  inline void set_allocated_strsocusername(::std::string* strsocusername);

  // required string strSocpassword = 4;
  inline bool has_strsocpassword() const;
  inline void clear_strsocpassword();
  static const int kStrSocpasswordFieldNumber = 4;
  inline const ::std::string& strsocpassword() const;
  inline void set_strsocpassword(const ::std::string& value);
  inline void set_strsocpassword(const char* value);
  inline void set_strsocpassword(const char* value, size_t size);
  inline ::std::string* mutable_strsocpassword();
  inline ::std::string* release_strsocpassword();
  inline void set_allocated_strsocpassword(::std::string* strsocpassword);

  // required string strExtendedinfo1 = 5;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedinfo1FieldNumber = 5;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedinfo2 = 6;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedinfo2FieldNumber = 6;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.UserMapInfo)
 private:
  inline void set_has_strusermapinfoid();
  inline void clear_has_strusermapinfoid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strsocusername();
  inline void clear_has_strsocusername();
  inline void set_has_strsocpassword();
  inline void clear_has_strsocpassword();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strusermapinfoid_;
  ::std::string* stremployeeid_;
  ::std::string* strsocusername_;
  ::std::string* strsocpassword_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static UserMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class BusinessQueryParam : public ::google::protobuf::Message {
 public:
  BusinessQueryParam();
  virtual ~BusinessQueryParam();

  BusinessQueryParam(const BusinessQueryParam& from);

  inline BusinessQueryParam& operator=(const BusinessQueryParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessQueryParam& default_instance();

  void Swap(BusinessQueryParam* other);

  // implements Message ----------------------------------------------

  BusinessQueryParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessQueryParam& from);
  void MergeFrom(const BusinessQueryParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strBranchid = 1;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchidFieldNumber = 1;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string strEmployeeid = 2;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeidFieldNumber = 2;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strCustomerid = 3;
  inline bool has_strcustomerid() const;
  inline void clear_strcustomerid();
  static const int kStrCustomeridFieldNumber = 3;
  inline const ::std::string& strcustomerid() const;
  inline void set_strcustomerid(const ::std::string& value);
  inline void set_strcustomerid(const char* value);
  inline void set_strcustomerid(const char* value, size_t size);
  inline ::std::string* mutable_strcustomerid();
  inline ::std::string* release_strcustomerid();
  inline void set_allocated_strcustomerid(::std::string* strcustomerid);

  // required string strProduceid = 4;
  inline bool has_strproduceid() const;
  inline void clear_strproduceid();
  static const int kStrProduceidFieldNumber = 4;
  inline const ::std::string& strproduceid() const;
  inline void set_strproduceid(const ::std::string& value);
  inline void set_strproduceid(const char* value);
  inline void set_strproduceid(const char* value, size_t size);
  inline ::std::string* mutable_strproduceid();
  inline ::std::string* release_strproduceid();
  inline void set_allocated_strproduceid(::std::string* strproduceid);

  // required string strStarttime = 5;
  inline bool has_strstarttime() const;
  inline void clear_strstarttime();
  static const int kStrStarttimeFieldNumber = 5;
  inline const ::std::string& strstarttime() const;
  inline void set_strstarttime(const ::std::string& value);
  inline void set_strstarttime(const char* value);
  inline void set_strstarttime(const char* value, size_t size);
  inline ::std::string* mutable_strstarttime();
  inline ::std::string* release_strstarttime();
  inline void set_allocated_strstarttime(::std::string* strstarttime);

  // required string strEndtime = 6;
  inline bool has_strendtime() const;
  inline void clear_strendtime();
  static const int kStrEndtimeFieldNumber = 6;
  inline const ::std::string& strendtime() const;
  inline void set_strendtime(const ::std::string& value);
  inline void set_strendtime(const char* value);
  inline void set_strendtime(const char* value, size_t size);
  inline ::std::string* mutable_strendtime();
  inline ::std::string* release_strendtime();
  inline void set_allocated_strendtime(::std::string* strendtime);

  // required int32 nPagesize = 7;
  inline bool has_npagesize() const;
  inline void clear_npagesize();
  static const int kNPagesizeFieldNumber = 7;
  inline ::google::protobuf::int32 npagesize() const;
  inline void set_npagesize(::google::protobuf::int32 value);

  // required int32 nPageindex = 8;
  inline bool has_npageindex() const;
  inline void clear_npageindex();
  static const int kNPageindexFieldNumber = 8;
  inline ::google::protobuf::int32 npageindex() const;
  inline void set_npageindex(::google::protobuf::int32 value);

  // required int32 nRecordcount = 9;
  inline bool has_nrecordcount() const;
  inline void clear_nrecordcount();
  static const int kNRecordcountFieldNumber = 9;
  inline ::google::protobuf::int32 nrecordcount() const;
  inline void set_nrecordcount(::google::protobuf::int32 value);

  // required string strSerialNumber = 10;
  inline bool has_strserialnumber() const;
  inline void clear_strserialnumber();
  static const int kStrSerialNumberFieldNumber = 10;
  inline const ::std::string& strserialnumber() const;
  inline void set_strserialnumber(const ::std::string& value);
  inline void set_strserialnumber(const char* value);
  inline void set_strserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_strserialnumber();
  inline ::std::string* release_strserialnumber();
  inline void set_allocated_strserialnumber(::std::string* strserialnumber);

  // required string strCredenitialsType = 11;
  inline bool has_strcredenitialstype() const;
  inline void clear_strcredenitialstype();
  static const int kStrCredenitialsTypeFieldNumber = 11;
  inline const ::std::string& strcredenitialstype() const;
  inline void set_strcredenitialstype(const ::std::string& value);
  inline void set_strcredenitialstype(const char* value);
  inline void set_strcredenitialstype(const char* value, size_t size);
  inline ::std::string* mutable_strcredenitialstype();
  inline ::std::string* release_strcredenitialstype();
  inline void set_allocated_strcredenitialstype(::std::string* strcredenitialstype);

  // required string strBusinessType = 12;
  inline bool has_strbusinesstype() const;
  inline void clear_strbusinesstype();
  static const int kStrBusinessTypeFieldNumber = 12;
  inline const ::std::string& strbusinesstype() const;
  inline void set_strbusinesstype(const ::std::string& value);
  inline void set_strbusinesstype(const char* value);
  inline void set_strbusinesstype(const char* value, size_t size);
  inline ::std::string* mutable_strbusinesstype();
  inline ::std::string* release_strbusinesstype();
  inline void set_allocated_strbusinesstype(::std::string* strbusinesstype);

  // required string strCardNumber = 13;
  inline bool has_strcardnumber() const;
  inline void clear_strcardnumber();
  static const int kStrCardNumberFieldNumber = 13;
  inline const ::std::string& strcardnumber() const;
  inline void set_strcardnumber(const ::std::string& value);
  inline void set_strcardnumber(const char* value);
  inline void set_strcardnumber(const char* value, size_t size);
  inline ::std::string* mutable_strcardnumber();
  inline ::std::string* release_strcardnumber();
  inline void set_allocated_strcardnumber(::std::string* strcardnumber);

  // required int32 nMarkerType = 14;
  inline bool has_nmarkertype() const;
  inline void clear_nmarkertype();
  static const int kNMarkerTypeFieldNumber = 14;
  inline ::google::protobuf::int32 nmarkertype() const;
  inline void set_nmarkertype(::google::protobuf::int32 value);

  // required string strRiskLevel = 15;
  inline bool has_strrisklevel() const;
  inline void clear_strrisklevel();
  static const int kStrRiskLevelFieldNumber = 15;
  inline const ::std::string& strrisklevel() const;
  inline void set_strrisklevel(const ::std::string& value);
  inline void set_strrisklevel(const char* value);
  inline void set_strrisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strrisklevel();
  inline ::std::string* release_strrisklevel();
  inline void set_allocated_strrisklevel(::std::string* strrisklevel);

  // required string strConditionEx = 16;
  inline bool has_strconditionex() const;
  inline void clear_strconditionex();
  static const int kStrConditionExFieldNumber = 16;
  inline const ::std::string& strconditionex() const;
  inline void set_strconditionex(const ::std::string& value);
  inline void set_strconditionex(const char* value);
  inline void set_strconditionex(const char* value, size_t size);
  inline ::std::string* mutable_strconditionex();
  inline ::std::string* release_strconditionex();
  inline void set_allocated_strconditionex(::std::string* strconditionex);

  // required string strMediumNum = 17;
  inline bool has_strmediumnum() const;
  inline void clear_strmediumnum();
  static const int kStrMediumNumFieldNumber = 17;
  inline const ::std::string& strmediumnum() const;
  inline void set_strmediumnum(const ::std::string& value);
  inline void set_strmediumnum(const char* value);
  inline void set_strmediumnum(const char* value, size_t size);
  inline ::std::string* mutable_strmediumnum();
  inline ::std::string* release_strmediumnum();
  inline void set_allocated_strmediumnum(::std::string* strmediumnum);

  // required string strExtendedInfo2 = 18;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 18;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.BusinessQueryParam)
 private:
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strcustomerid();
  inline void clear_has_strcustomerid();
  inline void set_has_strproduceid();
  inline void clear_has_strproduceid();
  inline void set_has_strstarttime();
  inline void clear_has_strstarttime();
  inline void set_has_strendtime();
  inline void clear_has_strendtime();
  inline void set_has_npagesize();
  inline void clear_has_npagesize();
  inline void set_has_npageindex();
  inline void clear_has_npageindex();
  inline void set_has_nrecordcount();
  inline void clear_has_nrecordcount();
  inline void set_has_strserialnumber();
  inline void clear_has_strserialnumber();
  inline void set_has_strcredenitialstype();
  inline void clear_has_strcredenitialstype();
  inline void set_has_strbusinesstype();
  inline void clear_has_strbusinesstype();
  inline void set_has_strcardnumber();
  inline void clear_has_strcardnumber();
  inline void set_has_nmarkertype();
  inline void clear_has_nmarkertype();
  inline void set_has_strrisklevel();
  inline void clear_has_strrisklevel();
  inline void set_has_strconditionex();
  inline void clear_has_strconditionex();
  inline void set_has_strmediumnum();
  inline void clear_has_strmediumnum();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbranchid_;
  ::std::string* stremployeeid_;
  ::std::string* strcustomerid_;
  ::std::string* strproduceid_;
  ::std::string* strstarttime_;
  ::std::string* strendtime_;
  ::google::protobuf::int32 npagesize_;
  ::google::protobuf::int32 npageindex_;
  ::std::string* strserialnumber_;
  ::std::string* strcredenitialstype_;
  ::google::protobuf::int32 nrecordcount_;
  ::google::protobuf::int32 nmarkertype_;
  ::std::string* strbusinesstype_;
  ::std::string* strcardnumber_;
  ::std::string* strrisklevel_;
  ::std::string* strconditionex_;
  ::std::string* strmediumnum_;
  ::std::string* strextendedinfo2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BusinessQueryParam* default_instance_;
};
// -------------------------------------------------------------------

class ProduceIdQueryParam : public ::google::protobuf::Message {
 public:
  ProduceIdQueryParam();
  virtual ~ProduceIdQueryParam();

  ProduceIdQueryParam(const ProduceIdQueryParam& from);

  inline ProduceIdQueryParam& operator=(const ProduceIdQueryParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProduceIdQueryParam& default_instance();

  void Swap(ProduceIdQueryParam* other);

  // implements Message ----------------------------------------------

  ProduceIdQueryParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProduceIdQueryParam& from);
  void MergeFrom(const ProduceIdQueryParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strInfoId = 1;
  inline bool has_strinfoid() const;
  inline void clear_strinfoid();
  static const int kStrInfoIdFieldNumber = 1;
  inline const ::std::string& strinfoid() const;
  inline void set_strinfoid(const ::std::string& value);
  inline void set_strinfoid(const char* value);
  inline void set_strinfoid(const char* value, size_t size);
  inline ::std::string* mutable_strinfoid();
  inline ::std::string* release_strinfoid();
  inline void set_allocated_strinfoid(::std::string* strinfoid);

  // required int32 nCount = 2;
  inline bool has_ncount() const;
  inline void clear_ncount();
  static const int kNCountFieldNumber = 2;
  inline ::google::protobuf::int32 ncount() const;
  inline void set_ncount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.ProduceIdQueryParam)
 private:
  inline void set_has_strinfoid();
  inline void clear_has_strinfoid();
  inline void set_has_ncount();
  inline void clear_has_ncount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strinfoid_;
  ::google::protobuf::int32 ncount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static ProduceIdQueryParam* default_instance_;
};
// -------------------------------------------------------------------

class TaskPlan : public ::google::protobuf::Message {
 public:
  TaskPlan();
  virtual ~TaskPlan();

  TaskPlan(const TaskPlan& from);

  inline TaskPlan& operator=(const TaskPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskPlan& default_instance();

  void Swap(TaskPlan* other);

  // implements Message ----------------------------------------------

  TaskPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskPlan& from);
  void MergeFrom(const TaskPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strPlanid = 1;
  inline bool has_strplanid() const;
  inline void clear_strplanid();
  static const int kStrPlanidFieldNumber = 1;
  inline const ::std::string& strplanid() const;
  inline void set_strplanid(const ::std::string& value);
  inline void set_strplanid(const char* value);
  inline void set_strplanid(const char* value, size_t size);
  inline ::std::string* mutable_strplanid();
  inline ::std::string* release_strplanid();
  inline void set_allocated_strplanid(::std::string* strplanid);

  // required string strBegintime = 2;
  inline bool has_strbegintime() const;
  inline void clear_strbegintime();
  static const int kStrBegintimeFieldNumber = 2;
  inline const ::std::string& strbegintime() const;
  inline void set_strbegintime(const ::std::string& value);
  inline void set_strbegintime(const char* value);
  inline void set_strbegintime(const char* value, size_t size);
  inline ::std::string* mutable_strbegintime();
  inline ::std::string* release_strbegintime();
  inline void set_allocated_strbegintime(::std::string* strbegintime);

  // required string strEndtime = 3;
  inline bool has_strendtime() const;
  inline void clear_strendtime();
  static const int kStrEndtimeFieldNumber = 3;
  inline const ::std::string& strendtime() const;
  inline void set_strendtime(const ::std::string& value);
  inline void set_strendtime(const char* value);
  inline void set_strendtime(const char* value, size_t size);
  inline ::std::string* mutable_strendtime();
  inline ::std::string* release_strendtime();
  inline void set_allocated_strendtime(::std::string* strendtime);

  // required int32 nEable = 4;
  inline bool has_neable() const;
  inline void clear_neable();
  static const int kNEableFieldNumber = 4;
  inline ::google::protobuf::int32 neable() const;
  inline void set_neable(::google::protobuf::int32 value);

  // required int32 nOrderid = 5;
  inline bool has_norderid() const;
  inline void clear_norderid();
  static const int kNOrderidFieldNumber = 5;
  inline ::google::protobuf::int32 norderid() const;
  inline void set_norderid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.TaskPlan)
 private:
  inline void set_has_strplanid();
  inline void clear_has_strplanid();
  inline void set_has_strbegintime();
  inline void clear_has_strbegintime();
  inline void set_has_strendtime();
  inline void clear_has_strendtime();
  inline void set_has_neable();
  inline void clear_has_neable();
  inline void set_has_norderid();
  inline void clear_has_norderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strplanid_;
  ::std::string* strbegintime_;
  ::std::string* strendtime_;
  ::google::protobuf::int32 neable_;
  ::google::protobuf::int32 norderid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static TaskPlan* default_instance_;
};
// -------------------------------------------------------------------

class BackupTask : public ::google::protobuf::Message {
 public:
  BackupTask();
  virtual ~BackupTask();

  BackupTask(const BackupTask& from);

  inline BackupTask& operator=(const BackupTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupTask& default_instance();

  void Swap(BackupTask* other);

  // implements Message ----------------------------------------------

  BackupTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackupTask& from);
  void MergeFrom(const BackupTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strTaskid = 1;
  inline bool has_strtaskid() const;
  inline void clear_strtaskid();
  static const int kStrTaskidFieldNumber = 1;
  inline const ::std::string& strtaskid() const;
  inline void set_strtaskid(const ::std::string& value);
  inline void set_strtaskid(const char* value);
  inline void set_strtaskid(const char* value, size_t size);
  inline ::std::string* mutable_strtaskid();
  inline ::std::string* release_strtaskid();
  inline void set_allocated_strtaskid(::std::string* strtaskid);

  // required int32 nType = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);

  // required int32 nStatus = 3;
  inline bool has_nstatus() const;
  inline void clear_nstatus();
  static const int kNStatusFieldNumber = 3;
  inline ::google::protobuf::int32 nstatus() const;
  inline void set_nstatus(::google::protobuf::int32 value);

  // required string strBusinessid = 4;
  inline bool has_strbusinessid() const;
  inline void clear_strbusinessid();
  static const int kStrBusinessidFieldNumber = 4;
  inline const ::std::string& strbusinessid() const;
  inline void set_strbusinessid(const ::std::string& value);
  inline void set_strbusinessid(const char* value);
  inline void set_strbusinessid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessid();
  inline ::std::string* release_strbusinessid();
  inline void set_allocated_strbusinessid(::std::string* strbusinessid);

  // required string strProduceid = 5;
  inline bool has_strproduceid() const;
  inline void clear_strproduceid();
  static const int kStrProduceidFieldNumber = 5;
  inline const ::std::string& strproduceid() const;
  inline void set_strproduceid(const ::std::string& value);
  inline void set_strproduceid(const char* value);
  inline void set_strproduceid(const char* value, size_t size);
  inline ::std::string* mutable_strproduceid();
  inline ::std::string* release_strproduceid();
  inline void set_allocated_strproduceid(::std::string* strproduceid);

  // required string strEmployeeid = 6;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeidFieldNumber = 6;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required .BFIS.ClientInfo stCustomer = 7;
  inline bool has_stcustomer() const;
  inline void clear_stcustomer();
  static const int kStCustomerFieldNumber = 7;
  inline const ::BFIS::ClientInfo& stcustomer() const;
  inline ::BFIS::ClientInfo* mutable_stcustomer();
  inline ::BFIS::ClientInfo* release_stcustomer();
  inline void set_allocated_stcustomer(::BFIS::ClientInfo* stcustomer);

  // required string strAutotime = 8;
  inline bool has_strautotime() const;
  inline void clear_strautotime();
  static const int kStrAutotimeFieldNumber = 8;
  inline const ::std::string& strautotime() const;
  inline void set_strautotime(const ::std::string& value);
  inline void set_strautotime(const char* value);
  inline void set_strautotime(const char* value, size_t size);
  inline ::std::string* mutable_strautotime();
  inline ::std::string* release_strautotime();
  inline void set_allocated_strautotime(::std::string* strautotime);

  // required string strBegintime = 9;
  inline bool has_strbegintime() const;
  inline void clear_strbegintime();
  static const int kStrBegintimeFieldNumber = 9;
  inline const ::std::string& strbegintime() const;
  inline void set_strbegintime(const ::std::string& value);
  inline void set_strbegintime(const char* value);
  inline void set_strbegintime(const char* value, size_t size);
  inline ::std::string* mutable_strbegintime();
  inline ::std::string* release_strbegintime();
  inline void set_allocated_strbegintime(::std::string* strbegintime);

  // required string strEndtime = 10;
  inline bool has_strendtime() const;
  inline void clear_strendtime();
  static const int kStrEndtimeFieldNumber = 10;
  inline const ::std::string& strendtime() const;
  inline void set_strendtime(const ::std::string& value);
  inline void set_strendtime(const char* value);
  inline void set_strendtime(const char* value, size_t size);
  inline ::std::string* mutable_strendtime();
  inline ::std::string* release_strendtime();
  inline void set_allocated_strendtime(::std::string* strendtime);

  // required int32 nProcess = 11;
  inline bool has_nprocess() const;
  inline void clear_nprocess();
  static const int kNProcessFieldNumber = 11;
  inline ::google::protobuf::int32 nprocess() const;
  inline void set_nprocess(::google::protobuf::int32 value);

  // required string strLaunchEmployeeID = 12;
  inline bool has_strlaunchemployeeid() const;
  inline void clear_strlaunchemployeeid();
  static const int kStrLaunchEmployeeIDFieldNumber = 12;
  inline const ::std::string& strlaunchemployeeid() const;
  inline void set_strlaunchemployeeid(const ::std::string& value);
  inline void set_strlaunchemployeeid(const char* value);
  inline void set_strlaunchemployeeid(const char* value, size_t size);
  inline ::std::string* mutable_strlaunchemployeeid();
  inline ::std::string* release_strlaunchemployeeid();
  inline void set_allocated_strlaunchemployeeid(::std::string* strlaunchemployeeid);

  // required int32 nOrderid = 13;
  inline bool has_norderid() const;
  inline void clear_norderid();
  static const int kNOrderidFieldNumber = 13;
  inline ::google::protobuf::int32 norderid() const;
  inline void set_norderid(::google::protobuf::int32 value);

  // required string strTimeForBusiness = 14;
  inline bool has_strtimeforbusiness() const;
  inline void clear_strtimeforbusiness();
  static const int kStrTimeForBusinessFieldNumber = 14;
  inline const ::std::string& strtimeforbusiness() const;
  inline void set_strtimeforbusiness(const ::std::string& value);
  inline void set_strtimeforbusiness(const char* value);
  inline void set_strtimeforbusiness(const char* value, size_t size);
  inline ::std::string* mutable_strtimeforbusiness();
  inline ::std::string* release_strtimeforbusiness();
  inline void set_allocated_strtimeforbusiness(::std::string* strtimeforbusiness);

  // required string strExtendedInfo2 = 15;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 15;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.BackupTask)
 private:
  inline void set_has_strtaskid();
  inline void clear_has_strtaskid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_nstatus();
  inline void clear_has_nstatus();
  inline void set_has_strbusinessid();
  inline void clear_has_strbusinessid();
  inline void set_has_strproduceid();
  inline void clear_has_strproduceid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_stcustomer();
  inline void clear_has_stcustomer();
  inline void set_has_strautotime();
  inline void clear_has_strautotime();
  inline void set_has_strbegintime();
  inline void clear_has_strbegintime();
  inline void set_has_strendtime();
  inline void clear_has_strendtime();
  inline void set_has_nprocess();
  inline void clear_has_nprocess();
  inline void set_has_strlaunchemployeeid();
  inline void clear_has_strlaunchemployeeid();
  inline void set_has_norderid();
  inline void clear_has_norderid();
  inline void set_has_strtimeforbusiness();
  inline void clear_has_strtimeforbusiness();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strtaskid_;
  ::google::protobuf::int32 ntype_;
  ::google::protobuf::int32 nstatus_;
  ::std::string* strbusinessid_;
  ::std::string* strproduceid_;
  ::std::string* stremployeeid_;
  ::BFIS::ClientInfo* stcustomer_;
  ::std::string* strautotime_;
  ::std::string* strbegintime_;
  ::std::string* strendtime_;
  ::std::string* strlaunchemployeeid_;
  ::google::protobuf::int32 nprocess_;
  ::google::protobuf::int32 norderid_;
  ::std::string* strtimeforbusiness_;
  ::std::string* strextendedinfo2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BackupTask* default_instance_;
};
// -------------------------------------------------------------------

class McServer : public ::google::protobuf::Message {
 public:
  McServer();
  virtual ~McServer();

  McServer(const McServer& from);

  inline McServer& operator=(const McServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const McServer& default_instance();

  void Swap(McServer* other);

  // implements Message ----------------------------------------------

  McServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const McServer& from);
  void MergeFrom(const McServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strBranchID = 1;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchIDFieldNumber = 1;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string strBranchName = 2;
  inline bool has_strbranchname() const;
  inline void clear_strbranchname();
  static const int kStrBranchNameFieldNumber = 2;
  inline const ::std::string& strbranchname() const;
  inline void set_strbranchname(const ::std::string& value);
  inline void set_strbranchname(const char* value);
  inline void set_strbranchname(const char* value, size_t size);
  inline ::std::string* mutable_strbranchname();
  inline ::std::string* release_strbranchname();
  inline void set_allocated_strbranchname(::std::string* strbranchname);

  // required string strMCIP = 3;
  inline bool has_strmcip() const;
  inline void clear_strmcip();
  static const int kStrMCIPFieldNumber = 3;
  inline const ::std::string& strmcip() const;
  inline void set_strmcip(const ::std::string& value);
  inline void set_strmcip(const char* value);
  inline void set_strmcip(const char* value, size_t size);
  inline ::std::string* mutable_strmcip();
  inline ::std::string* release_strmcip();
  inline void set_allocated_strmcip(::std::string* strmcip);

  // required int32 nPort = 4;
  inline bool has_nport() const;
  inline void clear_nport();
  static const int kNPortFieldNumber = 4;
  inline ::google::protobuf::int32 nport() const;
  inline void set_nport(::google::protobuf::int32 value);

  // required string strMCUserName = 5;
  inline bool has_strmcusername() const;
  inline void clear_strmcusername();
  static const int kStrMCUserNameFieldNumber = 5;
  inline const ::std::string& strmcusername() const;
  inline void set_strmcusername(const ::std::string& value);
  inline void set_strmcusername(const char* value);
  inline void set_strmcusername(const char* value, size_t size);
  inline ::std::string* mutable_strmcusername();
  inline ::std::string* release_strmcusername();
  inline void set_allocated_strmcusername(::std::string* strmcusername);

  // required string strMCUserPwd = 6;
  inline bool has_strmcuserpwd() const;
  inline void clear_strmcuserpwd();
  static const int kStrMCUserPwdFieldNumber = 6;
  inline const ::std::string& strmcuserpwd() const;
  inline void set_strmcuserpwd(const ::std::string& value);
  inline void set_strmcuserpwd(const char* value);
  inline void set_strmcuserpwd(const char* value, size_t size);
  inline ::std::string* mutable_strmcuserpwd();
  inline ::std::string* release_strmcuserpwd();
  inline void set_allocated_strmcuserpwd(::std::string* strmcuserpwd);

  // required int32 nIsLocal = 7;
  inline bool has_nislocal() const;
  inline void clear_nislocal();
  static const int kNIsLocalFieldNumber = 7;
  inline ::google::protobuf::int32 nislocal() const;
  inline void set_nislocal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.McServer)
 private:
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_strbranchname();
  inline void clear_has_strbranchname();
  inline void set_has_strmcip();
  inline void clear_has_strmcip();
  inline void set_has_nport();
  inline void clear_has_nport();
  inline void set_has_strmcusername();
  inline void clear_has_strmcusername();
  inline void set_has_strmcuserpwd();
  inline void clear_has_strmcuserpwd();
  inline void set_has_nislocal();
  inline void clear_has_nislocal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbranchid_;
  ::std::string* strbranchname_;
  ::std::string* strmcip_;
  ::std::string* strmcusername_;
  ::google::protobuf::int32 nport_;
  ::google::protobuf::int32 nislocal_;
  ::std::string* strmcuserpwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static McServer* default_instance_;
};
// -------------------------------------------------------------------

class MigrateLog : public ::google::protobuf::Message {
 public:
  MigrateLog();
  virtual ~MigrateLog();

  MigrateLog(const MigrateLog& from);

  inline MigrateLog& operator=(const MigrateLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MigrateLog& default_instance();

  void Swap(MigrateLog* other);

  // implements Message ----------------------------------------------

  MigrateLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MigrateLog& from);
  void MergeFrom(const MigrateLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strMigrateTaskID = 1;
  inline bool has_strmigratetaskid() const;
  inline void clear_strmigratetaskid();
  static const int kStrMigrateTaskIDFieldNumber = 1;
  inline const ::std::string& strmigratetaskid() const;
  inline void set_strmigratetaskid(const ::std::string& value);
  inline void set_strmigratetaskid(const char* value);
  inline void set_strmigratetaskid(const char* value, size_t size);
  inline ::std::string* mutable_strmigratetaskid();
  inline ::std::string* release_strmigratetaskid();
  inline void set_allocated_strmigratetaskid(::std::string* strmigratetaskid);

  // required string strBusinessID = 2;
  inline bool has_strbusinessid() const;
  inline void clear_strbusinessid();
  static const int kStrBusinessIDFieldNumber = 2;
  inline const ::std::string& strbusinessid() const;
  inline void set_strbusinessid(const ::std::string& value);
  inline void set_strbusinessid(const char* value);
  inline void set_strbusinessid(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessid();
  inline ::std::string* release_strbusinessid();
  inline void set_allocated_strbusinessid(::std::string* strbusinessid);

  // required string strProduceID = 3;
  inline bool has_strproduceid() const;
  inline void clear_strproduceid();
  static const int kStrProduceIDFieldNumber = 3;
  inline const ::std::string& strproduceid() const;
  inline void set_strproduceid(const ::std::string& value);
  inline void set_strproduceid(const char* value);
  inline void set_strproduceid(const char* value, size_t size);
  inline ::std::string* mutable_strproduceid();
  inline ::std::string* release_strproduceid();
  inline void set_allocated_strproduceid(::std::string* strproduceid);

  // required string strEmployeeID = 4;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeIDFieldNumber = 4;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required int32 nType = 5;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 5;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);

  // required int32 nStatus = 6;
  inline bool has_nstatus() const;
  inline void clear_nstatus();
  static const int kNStatusFieldNumber = 6;
  inline ::google::protobuf::int32 nstatus() const;
  inline void set_nstatus(::google::protobuf::int32 value);

  // required string strAutoTime = 7;
  inline bool has_strautotime() const;
  inline void clear_strautotime();
  static const int kStrAutoTimeFieldNumber = 7;
  inline const ::std::string& strautotime() const;
  inline void set_strautotime(const ::std::string& value);
  inline void set_strautotime(const char* value);
  inline void set_strautotime(const char* value, size_t size);
  inline ::std::string* mutable_strautotime();
  inline ::std::string* release_strautotime();
  inline void set_allocated_strautotime(::std::string* strautotime);

  // required string strBeginTime = 8;
  inline bool has_strbegintime() const;
  inline void clear_strbegintime();
  static const int kStrBeginTimeFieldNumber = 8;
  inline const ::std::string& strbegintime() const;
  inline void set_strbegintime(const ::std::string& value);
  inline void set_strbegintime(const char* value);
  inline void set_strbegintime(const char* value, size_t size);
  inline ::std::string* mutable_strbegintime();
  inline ::std::string* release_strbegintime();
  inline void set_allocated_strbegintime(::std::string* strbegintime);

  // required string strEndTime = 9;
  inline bool has_strendtime() const;
  inline void clear_strendtime();
  static const int kStrEndTimeFieldNumber = 9;
  inline const ::std::string& strendtime() const;
  inline void set_strendtime(const ::std::string& value);
  inline void set_strendtime(const char* value);
  inline void set_strendtime(const char* value, size_t size);
  inline ::std::string* mutable_strendtime();
  inline ::std::string* release_strendtime();
  inline void set_allocated_strendtime(::std::string* strendtime);

  // required string strLaunchEmployeeID = 10;
  inline bool has_strlaunchemployeeid() const;
  inline void clear_strlaunchemployeeid();
  static const int kStrLaunchEmployeeIDFieldNumber = 10;
  inline const ::std::string& strlaunchemployeeid() const;
  inline void set_strlaunchemployeeid(const ::std::string& value);
  inline void set_strlaunchemployeeid(const char* value);
  inline void set_strlaunchemployeeid(const char* value, size_t size);
  inline ::std::string* mutable_strlaunchemployeeid();
  inline ::std::string* release_strlaunchemployeeid();
  inline void set_allocated_strlaunchemployeeid(::std::string* strlaunchemployeeid);

  // required int32 nOrderID = 11;
  inline bool has_norderid() const;
  inline void clear_norderid();
  static const int kNOrderIDFieldNumber = 11;
  inline ::google::protobuf::int32 norderid() const;
  inline void set_norderid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.MigrateLog)
 private:
  inline void set_has_strmigratetaskid();
  inline void clear_has_strmigratetaskid();
  inline void set_has_strbusinessid();
  inline void clear_has_strbusinessid();
  inline void set_has_strproduceid();
  inline void clear_has_strproduceid();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_nstatus();
  inline void clear_has_nstatus();
  inline void set_has_strautotime();
  inline void clear_has_strautotime();
  inline void set_has_strbegintime();
  inline void clear_has_strbegintime();
  inline void set_has_strendtime();
  inline void clear_has_strendtime();
  inline void set_has_strlaunchemployeeid();
  inline void clear_has_strlaunchemployeeid();
  inline void set_has_norderid();
  inline void clear_has_norderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strmigratetaskid_;
  ::std::string* strbusinessid_;
  ::std::string* strproduceid_;
  ::std::string* stremployeeid_;
  ::google::protobuf::int32 ntype_;
  ::google::protobuf::int32 nstatus_;
  ::std::string* strautotime_;
  ::std::string* strbegintime_;
  ::std::string* strendtime_;
  ::std::string* strlaunchemployeeid_;
  ::google::protobuf::int32 norderid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static MigrateLog* default_instance_;
};
// -------------------------------------------------------------------

class QueryCondition : public ::google::protobuf::Message {
 public:
  QueryCondition();
  virtual ~QueryCondition();

  QueryCondition(const QueryCondition& from);

  inline QueryCondition& operator=(const QueryCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryCondition& default_instance();

  void Swap(QueryCondition* other);

  // implements Message ----------------------------------------------

  QueryCondition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryCondition& from);
  void MergeFrom(const QueryCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strCon1 = 1;
  inline bool has_strcon1() const;
  inline void clear_strcon1();
  static const int kStrCon1FieldNumber = 1;
  inline const ::std::string& strcon1() const;
  inline void set_strcon1(const ::std::string& value);
  inline void set_strcon1(const char* value);
  inline void set_strcon1(const char* value, size_t size);
  inline ::std::string* mutable_strcon1();
  inline ::std::string* release_strcon1();
  inline void set_allocated_strcon1(::std::string* strcon1);

  // required string strCon2 = 2;
  inline bool has_strcon2() const;
  inline void clear_strcon2();
  static const int kStrCon2FieldNumber = 2;
  inline const ::std::string& strcon2() const;
  inline void set_strcon2(const ::std::string& value);
  inline void set_strcon2(const char* value);
  inline void set_strcon2(const char* value, size_t size);
  inline ::std::string* mutable_strcon2();
  inline ::std::string* release_strcon2();
  inline void set_allocated_strcon2(::std::string* strcon2);

  // required int32 nPageSize = 3;
  inline bool has_npagesize() const;
  inline void clear_npagesize();
  static const int kNPageSizeFieldNumber = 3;
  inline ::google::protobuf::int32 npagesize() const;
  inline void set_npagesize(::google::protobuf::int32 value);

  // required int32 nPageIndex = 4;
  inline bool has_npageindex() const;
  inline void clear_npageindex();
  static const int kNPageIndexFieldNumber = 4;
  inline ::google::protobuf::int32 npageindex() const;
  inline void set_npageindex(::google::protobuf::int32 value);

  // required int32 nReserved = 5;
  inline bool has_nreserved() const;
  inline void clear_nreserved();
  static const int kNReservedFieldNumber = 5;
  inline ::google::protobuf::int32 nreserved() const;
  inline void set_nreserved(::google::protobuf::int32 value);

  // required string strReserved = 6;
  inline bool has_strreserved() const;
  inline void clear_strreserved();
  static const int kStrReservedFieldNumber = 6;
  inline const ::std::string& strreserved() const;
  inline void set_strreserved(const ::std::string& value);
  inline void set_strreserved(const char* value);
  inline void set_strreserved(const char* value, size_t size);
  inline ::std::string* mutable_strreserved();
  inline ::std::string* release_strreserved();
  inline void set_allocated_strreserved(::std::string* strreserved);

  // @@protoc_insertion_point(class_scope:BFIS.QueryCondition)
 private:
  inline void set_has_strcon1();
  inline void clear_has_strcon1();
  inline void set_has_strcon2();
  inline void clear_has_strcon2();
  inline void set_has_npagesize();
  inline void clear_has_npagesize();
  inline void set_has_npageindex();
  inline void clear_has_npageindex();
  inline void set_has_nreserved();
  inline void clear_has_nreserved();
  inline void set_has_strreserved();
  inline void clear_has_strreserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strcon1_;
  ::std::string* strcon2_;
  ::google::protobuf::int32 npagesize_;
  ::google::protobuf::int32 npageindex_;
  ::std::string* strreserved_;
  ::google::protobuf::int32 nreserved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static QueryCondition* default_instance_;
};
// -------------------------------------------------------------------

class BusinessDockMsgInfo : public ::google::protobuf::Message {
 public:
  BusinessDockMsgInfo();
  virtual ~BusinessDockMsgInfo();

  BusinessDockMsgInfo(const BusinessDockMsgInfo& from);

  inline BusinessDockMsgInfo& operator=(const BusinessDockMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessDockMsgInfo& default_instance();

  void Swap(BusinessDockMsgInfo* other);

  // implements Message ----------------------------------------------

  BusinessDockMsgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessDockMsgInfo& from);
  void MergeFrom(const BusinessDockMsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strChannelCode = 1;
  inline bool has_strchannelcode() const;
  inline void clear_strchannelcode();
  static const int kStrChannelCodeFieldNumber = 1;
  inline const ::std::string& strchannelcode() const;
  inline void set_strchannelcode(const ::std::string& value);
  inline void set_strchannelcode(const char* value);
  inline void set_strchannelcode(const char* value, size_t size);
  inline ::std::string* mutable_strchannelcode();
  inline ::std::string* release_strchannelcode();
  inline void set_allocated_strchannelcode(::std::string* strchannelcode);

  // required string strServiceCode = 2;
  inline bool has_strservicecode() const;
  inline void clear_strservicecode();
  static const int kStrServiceCodeFieldNumber = 2;
  inline const ::std::string& strservicecode() const;
  inline void set_strservicecode(const ::std::string& value);
  inline void set_strservicecode(const char* value);
  inline void set_strservicecode(const char* value, size_t size);
  inline ::std::string* mutable_strservicecode();
  inline ::std::string* release_strservicecode();
  inline void set_allocated_strservicecode(::std::string* strservicecode);

  // required string strJDBRID = 3;
  inline bool has_strjdbrid() const;
  inline void clear_strjdbrid();
  static const int kStrJDBRIDFieldNumber = 3;
  inline const ::std::string& strjdbrid() const;
  inline void set_strjdbrid(const ::std::string& value);
  inline void set_strjdbrid(const char* value);
  inline void set_strjdbrid(const char* value, size_t size);
  inline ::std::string* mutable_strjdbrid();
  inline ::std::string* release_strjdbrid();
  inline void set_allocated_strjdbrid(::std::string* strjdbrid);

  // required string strOperatorId = 4;
  inline bool has_stroperatorid() const;
  inline void clear_stroperatorid();
  static const int kStrOperatorIdFieldNumber = 4;
  inline const ::std::string& stroperatorid() const;
  inline void set_stroperatorid(const ::std::string& value);
  inline void set_stroperatorid(const char* value);
  inline void set_stroperatorid(const char* value, size_t size);
  inline ::std::string* mutable_stroperatorid();
  inline ::std::string* release_stroperatorid();
  inline void set_allocated_stroperatorid(::std::string* stroperatorid);

  // required string strChannelSerialNum = 5;
  inline bool has_strchannelserialnum() const;
  inline void clear_strchannelserialnum();
  static const int kStrChannelSerialNumFieldNumber = 5;
  inline const ::std::string& strchannelserialnum() const;
  inline void set_strchannelserialnum(const ::std::string& value);
  inline void set_strchannelserialnum(const char* value);
  inline void set_strchannelserialnum(const char* value, size_t size);
  inline ::std::string* mutable_strchannelserialnum();
  inline ::std::string* release_strchannelserialnum();
  inline void set_allocated_strchannelserialnum(::std::string* strchannelserialnum);

  // required string strKernelSerialNum = 6;
  inline bool has_strkernelserialnum() const;
  inline void clear_strkernelserialnum();
  static const int kStrKernelSerialNumFieldNumber = 6;
  inline const ::std::string& strkernelserialnum() const;
  inline void set_strkernelserialnum(const ::std::string& value);
  inline void set_strkernelserialnum(const char* value);
  inline void set_strkernelserialnum(const char* value, size_t size);
  inline ::std::string* mutable_strkernelserialnum();
  inline ::std::string* release_strkernelserialnum();
  inline void set_allocated_strkernelserialnum(::std::string* strkernelserialnum);

  // required string strDateTime = 7;
  inline bool has_strdatetime() const;
  inline void clear_strdatetime();
  static const int kStrDateTimeFieldNumber = 7;
  inline const ::std::string& strdatetime() const;
  inline void set_strdatetime(const ::std::string& value);
  inline void set_strdatetime(const char* value);
  inline void set_strdatetime(const char* value, size_t size);
  inline ::std::string* mutable_strdatetime();
  inline ::std::string* release_strdatetime();
  inline void set_allocated_strdatetime(::std::string* strdatetime);

  // required string strChannelDate = 8;
  inline bool has_strchanneldate() const;
  inline void clear_strchanneldate();
  static const int kStrChannelDateFieldNumber = 8;
  inline const ::std::string& strchanneldate() const;
  inline void set_strchanneldate(const ::std::string& value);
  inline void set_strchanneldate(const char* value);
  inline void set_strchanneldate(const char* value, size_t size);
  inline ::std::string* mutable_strchanneldate();
  inline ::std::string* release_strchanneldate();
  inline void set_allocated_strchanneldate(::std::string* strchanneldate);

  // required string strRepondCode = 9;
  inline bool has_strrepondcode() const;
  inline void clear_strrepondcode();
  static const int kStrRepondCodeFieldNumber = 9;
  inline const ::std::string& strrepondcode() const;
  inline void set_strrepondcode(const ::std::string& value);
  inline void set_strrepondcode(const char* value);
  inline void set_strrepondcode(const char* value, size_t size);
  inline ::std::string* mutable_strrepondcode();
  inline ::std::string* release_strrepondcode();
  inline void set_allocated_strrepondcode(::std::string* strrepondcode);

  // required string strChineseDescribeInfo = 10;
  inline bool has_strchinesedescribeinfo() const;
  inline void clear_strchinesedescribeinfo();
  static const int kStrChineseDescribeInfoFieldNumber = 10;
  inline const ::std::string& strchinesedescribeinfo() const;
  inline void set_strchinesedescribeinfo(const ::std::string& value);
  inline void set_strchinesedescribeinfo(const char* value);
  inline void set_strchinesedescribeinfo(const char* value, size_t size);
  inline ::std::string* mutable_strchinesedescribeinfo();
  inline ::std::string* release_strchinesedescribeinfo();
  inline void set_allocated_strchinesedescribeinfo(::std::string* strchinesedescribeinfo);

  // required string strBusinessCode = 11;
  inline bool has_strbusinesscode() const;
  inline void clear_strbusinesscode();
  static const int kStrBusinessCodeFieldNumber = 11;
  inline const ::std::string& strbusinesscode() const;
  inline void set_strbusinesscode(const ::std::string& value);
  inline void set_strbusinesscode(const char* value);
  inline void set_strbusinesscode(const char* value, size_t size);
  inline ::std::string* mutable_strbusinesscode();
  inline ::std::string* release_strbusinesscode();
  inline void set_allocated_strbusinesscode(::std::string* strbusinesscode);

  // required string strBusinessName = 12;
  inline bool has_strbusinessname() const;
  inline void clear_strbusinessname();
  static const int kStrBusinessNameFieldNumber = 12;
  inline const ::std::string& strbusinessname() const;
  inline void set_strbusinessname(const ::std::string& value);
  inline void set_strbusinessname(const char* value);
  inline void set_strbusinessname(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessname();
  inline ::std::string* release_strbusinessname();
  inline void set_allocated_strbusinessname(::std::string* strbusinessname);

  // required string strBusinessStatus = 13;
  inline bool has_strbusinessstatus() const;
  inline void clear_strbusinessstatus();
  static const int kStrBusinessStatusFieldNumber = 13;
  inline const ::std::string& strbusinessstatus() const;
  inline void set_strbusinessstatus(const ::std::string& value);
  inline void set_strbusinessstatus(const char* value);
  inline void set_strbusinessstatus(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessstatus();
  inline ::std::string* release_strbusinessstatus();
  inline void set_allocated_strbusinessstatus(::std::string* strbusinessstatus);

  // required string strProduceCode = 14;
  inline bool has_strproducecode() const;
  inline void clear_strproducecode();
  static const int kStrProduceCodeFieldNumber = 14;
  inline const ::std::string& strproducecode() const;
  inline void set_strproducecode(const ::std::string& value);
  inline void set_strproducecode(const char* value);
  inline void set_strproducecode(const char* value, size_t size);
  inline ::std::string* mutable_strproducecode();
  inline ::std::string* release_strproducecode();
  inline void set_allocated_strproducecode(::std::string* strproducecode);

  // required string strObjectProduceCode = 15;
  inline bool has_strobjectproducecode() const;
  inline void clear_strobjectproducecode();
  static const int kStrObjectProduceCodeFieldNumber = 15;
  inline const ::std::string& strobjectproducecode() const;
  inline void set_strobjectproducecode(const ::std::string& value);
  inline void set_strobjectproducecode(const char* value);
  inline void set_strobjectproducecode(const char* value, size_t size);
  inline ::std::string* mutable_strobjectproducecode();
  inline ::std::string* release_strobjectproducecode();
  inline void set_allocated_strobjectproducecode(::std::string* strobjectproducecode);

  // required string strFundName = 16;
  inline bool has_strfundname() const;
  inline void clear_strfundname();
  static const int kStrFundNameFieldNumber = 16;
  inline const ::std::string& strfundname() const;
  inline void set_strfundname(const ::std::string& value);
  inline void set_strfundname(const char* value);
  inline void set_strfundname(const char* value, size_t size);
  inline ::std::string* mutable_strfundname();
  inline ::std::string* release_strfundname();
  inline void set_allocated_strfundname(::std::string* strfundname);

  // required string strProduceName = 17;
  inline bool has_strproducename() const;
  inline void clear_strproducename();
  static const int kStrProduceNameFieldNumber = 17;
  inline const ::std::string& strproducename() const;
  inline void set_strproducename(const ::std::string& value);
  inline void set_strproducename(const char* value);
  inline void set_strproducename(const char* value, size_t size);
  inline ::std::string* mutable_strproducename();
  inline ::std::string* release_strproducename();
  inline void set_allocated_strproducename(::std::string* strproducename);

  // required string strIncomeType = 18;
  inline bool has_strincometype() const;
  inline void clear_strincometype();
  static const int kStrIncomeTypeFieldNumber = 18;
  inline const ::std::string& strincometype() const;
  inline void set_strincometype(const ::std::string& value);
  inline void set_strincometype(const char* value);
  inline void set_strincometype(const char* value, size_t size);
  inline ::std::string* mutable_strincometype();
  inline ::std::string* release_strincometype();
  inline void set_allocated_strincometype(::std::string* strincometype);

  // required string strBusinessDate = 19;
  inline bool has_strbusinessdate() const;
  inline void clear_strbusinessdate();
  static const int kStrBusinessDateFieldNumber = 19;
  inline const ::std::string& strbusinessdate() const;
  inline void set_strbusinessdate(const ::std::string& value);
  inline void set_strbusinessdate(const char* value);
  inline void set_strbusinessdate(const char* value, size_t size);
  inline ::std::string* mutable_strbusinessdate();
  inline ::std::string* release_strbusinessdate();
  inline void set_allocated_strbusinessdate(::std::string* strbusinessdate);

  // required string strClientName = 20;
  inline bool has_strclientname() const;
  inline void clear_strclientname();
  static const int kStrClientNameFieldNumber = 20;
  inline const ::std::string& strclientname() const;
  inline void set_strclientname(const ::std::string& value);
  inline void set_strclientname(const char* value);
  inline void set_strclientname(const char* value, size_t size);
  inline ::std::string* mutable_strclientname();
  inline ::std::string* release_strclientname();
  inline void set_allocated_strclientname(::std::string* strclientname);

  // required string strCredenitialsType = 21;
  inline bool has_strcredenitialstype() const;
  inline void clear_strcredenitialstype();
  static const int kStrCredenitialsTypeFieldNumber = 21;
  inline const ::std::string& strcredenitialstype() const;
  inline void set_strcredenitialstype(const ::std::string& value);
  inline void set_strcredenitialstype(const char* value);
  inline void set_strcredenitialstype(const char* value, size_t size);
  inline ::std::string* mutable_strcredenitialstype();
  inline ::std::string* release_strcredenitialstype();
  inline void set_allocated_strcredenitialstype(::std::string* strcredenitialstype);

  // required string strCredenitialNum = 22;
  inline bool has_strcredenitialnum() const;
  inline void clear_strcredenitialnum();
  static const int kStrCredenitialNumFieldNumber = 22;
  inline const ::std::string& strcredenitialnum() const;
  inline void set_strcredenitialnum(const ::std::string& value);
  inline void set_strcredenitialnum(const char* value);
  inline void set_strcredenitialnum(const char* value, size_t size);
  inline ::std::string* mutable_strcredenitialnum();
  inline ::std::string* release_strcredenitialnum();
  inline void set_allocated_strcredenitialnum(::std::string* strcredenitialnum);

  // required string strMediumType = 23;
  inline bool has_strmediumtype() const;
  inline void clear_strmediumtype();
  static const int kStrMediumTypeFieldNumber = 23;
  inline const ::std::string& strmediumtype() const;
  inline void set_strmediumtype(const ::std::string& value);
  inline void set_strmediumtype(const char* value);
  inline void set_strmediumtype(const char* value, size_t size);
  inline ::std::string* mutable_strmediumtype();
  inline ::std::string* release_strmediumtype();
  inline void set_allocated_strmediumtype(::std::string* strmediumtype);

  // required string strMediumNum = 24;
  inline bool has_strmediumnum() const;
  inline void clear_strmediumnum();
  static const int kStrMediumNumFieldNumber = 24;
  inline const ::std::string& strmediumnum() const;
  inline void set_strmediumnum(const ::std::string& value);
  inline void set_strmediumnum(const char* value);
  inline void set_strmediumnum(const char* value, size_t size);
  inline ::std::string* mutable_strmediumnum();
  inline ::std::string* release_strmediumnum();
  inline void set_allocated_strmediumnum(::std::string* strmediumnum);

  // required string strClientRiskLevel = 25;
  inline bool has_strclientrisklevel() const;
  inline void clear_strclientrisklevel();
  static const int kStrClientRiskLevelFieldNumber = 25;
  inline const ::std::string& strclientrisklevel() const;
  inline void set_strclientrisklevel(const ::std::string& value);
  inline void set_strclientrisklevel(const char* value);
  inline void set_strclientrisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strclientrisklevel();
  inline ::std::string* release_strclientrisklevel();
  inline void set_allocated_strclientrisklevel(::std::string* strclientrisklevel);

  // required string strProduceRiskLevel = 26;
  inline bool has_strproducerisklevel() const;
  inline void clear_strproducerisklevel();
  static const int kStrProduceRiskLevelFieldNumber = 26;
  inline const ::std::string& strproducerisklevel() const;
  inline void set_strproducerisklevel(const ::std::string& value);
  inline void set_strproducerisklevel(const char* value);
  inline void set_strproducerisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strproducerisklevel();
  inline ::std::string* release_strproducerisklevel();
  inline void set_allocated_strproducerisklevel(::std::string* strproducerisklevel);

  // required string strFundType = 27;
  inline bool has_strfundtype() const;
  inline void clear_strfundtype();
  static const int kStrFundTypeFieldNumber = 27;
  inline const ::std::string& strfundtype() const;
  inline void set_strfundtype(const ::std::string& value);
  inline void set_strfundtype(const char* value);
  inline void set_strfundtype(const char* value, size_t size);
  inline ::std::string* mutable_strfundtype();
  inline ::std::string* release_strfundtype();
  inline void set_allocated_strfundtype(::std::string* strfundtype);

  // required string strCancelBusinessType = 28;
  inline bool has_strcancelbusinesstype() const;
  inline void clear_strcancelbusinesstype();
  static const int kStrCancelBusinessTypeFieldNumber = 28;
  inline const ::std::string& strcancelbusinesstype() const;
  inline void set_strcancelbusinesstype(const ::std::string& value);
  inline void set_strcancelbusinesstype(const char* value);
  inline void set_strcancelbusinesstype(const char* value, size_t size);
  inline ::std::string* mutable_strcancelbusinesstype();
  inline ::std::string* release_strcancelbusinesstype();
  inline void set_allocated_strcancelbusinesstype(::std::string* strcancelbusinesstype);

  // required string strTerminalIP = 29;
  inline bool has_strterminalip() const;
  inline void clear_strterminalip();
  static const int kStrTerminalIPFieldNumber = 29;
  inline const ::std::string& strterminalip() const;
  inline void set_strterminalip(const ::std::string& value);
  inline void set_strterminalip(const char* value);
  inline void set_strterminalip(const char* value, size_t size);
  inline ::std::string* mutable_strterminalip();
  inline ::std::string* release_strterminalip();
  inline void set_allocated_strterminalip(::std::string* strterminalip);

  // required string strTradeSerialNum = 30;
  inline bool has_strtradeserialnum() const;
  inline void clear_strtradeserialnum();
  static const int kStrTradeSerialNumFieldNumber = 30;
  inline const ::std::string& strtradeserialnum() const;
  inline void set_strtradeserialnum(const ::std::string& value);
  inline void set_strtradeserialnum(const char* value);
  inline void set_strtradeserialnum(const char* value, size_t size);
  inline ::std::string* mutable_strtradeserialnum();
  inline ::std::string* release_strtradeserialnum();
  inline void set_allocated_strtradeserialnum(::std::string* strtradeserialnum);

  // required string strFinancSerialNum = 31;
  inline bool has_strfinancserialnum() const;
  inline void clear_strfinancserialnum();
  static const int kStrFinancSerialNumFieldNumber = 31;
  inline const ::std::string& strfinancserialnum() const;
  inline void set_strfinancserialnum(const ::std::string& value);
  inline void set_strfinancserialnum(const char* value);
  inline void set_strfinancserialnum(const char* value, size_t size);
  inline ::std::string* mutable_strfinancserialnum();
  inline ::std::string* release_strfinancserialnum();
  inline void set_allocated_strfinancserialnum(::std::string* strfinancserialnum);

  // required int32 nSystemType = 32;
  inline bool has_nsystemtype() const;
  inline void clear_nsystemtype();
  static const int kNSystemTypeFieldNumber = 32;
  inline ::google::protobuf::int32 nsystemtype() const;
  inline void set_nsystemtype(::google::protobuf::int32 value);

  // required int32 nBootFlag = 33;
  inline bool has_nbootflag() const;
  inline void clear_nbootflag();
  static const int kNBootFlagFieldNumber = 33;
  inline ::google::protobuf::int32 nbootflag() const;
  inline void set_nbootflag(::google::protobuf::int32 value);

  // optional string strTermId = 34;
  inline bool has_strtermid() const;
  inline void clear_strtermid();
  static const int kStrTermIdFieldNumber = 34;
  inline const ::std::string& strtermid() const;
  inline void set_strtermid(const ::std::string& value);
  inline void set_strtermid(const char* value);
  inline void set_strtermid(const char* value, size_t size);
  inline ::std::string* mutable_strtermid();
  inline ::std::string* release_strtermid();
  inline void set_allocated_strtermid(::std::string* strtermid);

  // optional string strTranTime = 35;
  inline bool has_strtrantime() const;
  inline void clear_strtrantime();
  static const int kStrTranTimeFieldNumber = 35;
  inline const ::std::string& strtrantime() const;
  inline void set_strtrantime(const ::std::string& value);
  inline void set_strtrantime(const char* value);
  inline void set_strtrantime(const char* value, size_t size);
  inline ::std::string* mutable_strtrantime();
  inline ::std::string* release_strtrantime();
  inline void set_allocated_strtrantime(::std::string* strtrantime);

  // optional string strAcctNo = 36;
  inline bool has_stracctno() const;
  inline void clear_stracctno();
  static const int kStrAcctNoFieldNumber = 36;
  inline const ::std::string& stracctno() const;
  inline void set_stracctno(const ::std::string& value);
  inline void set_stracctno(const char* value);
  inline void set_stracctno(const char* value, size_t size);
  inline ::std::string* mutable_stracctno();
  inline ::std::string* release_stracctno();
  inline void set_allocated_stracctno(::std::string* stracctno);

  // optional string strIBFISSerialNum = 37;
  inline bool has_stribfisserialnum() const;
  inline void clear_stribfisserialnum();
  static const int kStrIBFISSerialNumFieldNumber = 37;
  inline const ::std::string& stribfisserialnum() const;
  inline void set_stribfisserialnum(const ::std::string& value);
  inline void set_stribfisserialnum(const char* value);
  inline void set_stribfisserialnum(const char* value, size_t size);
  inline ::std::string* mutable_stribfisserialnum();
  inline ::std::string* release_stribfisserialnum();
  inline void set_allocated_stribfisserialnum(::std::string* stribfisserialnum);

  // optional string strVideoEndDate = 38;
  inline bool has_strvideoenddate() const;
  inline void clear_strvideoenddate();
  static const int kStrVideoEndDateFieldNumber = 38;
  inline const ::std::string& strvideoenddate() const;
  inline void set_strvideoenddate(const ::std::string& value);
  inline void set_strvideoenddate(const char* value);
  inline void set_strvideoenddate(const char* value, size_t size);
  inline ::std::string* mutable_strvideoenddate();
  inline ::std::string* release_strvideoenddate();
  inline void set_allocated_strvideoenddate(::std::string* strvideoenddate);

  // optional string strExtendedInfo = 39;
  inline bool has_strextendedinfo() const;
  inline void clear_strextendedinfo();
  static const int kStrExtendedInfoFieldNumber = 39;
  inline const ::std::string& strextendedinfo() const;
  inline void set_strextendedinfo(const ::std::string& value);
  inline void set_strextendedinfo(const char* value);
  inline void set_strextendedinfo(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo();
  inline ::std::string* release_strextendedinfo();
  inline void set_allocated_strextendedinfo(::std::string* strextendedinfo);

  // @@protoc_insertion_point(class_scope:BFIS.BusinessDockMsgInfo)
 private:
  inline void set_has_strchannelcode();
  inline void clear_has_strchannelcode();
  inline void set_has_strservicecode();
  inline void clear_has_strservicecode();
  inline void set_has_strjdbrid();
  inline void clear_has_strjdbrid();
  inline void set_has_stroperatorid();
  inline void clear_has_stroperatorid();
  inline void set_has_strchannelserialnum();
  inline void clear_has_strchannelserialnum();
  inline void set_has_strkernelserialnum();
  inline void clear_has_strkernelserialnum();
  inline void set_has_strdatetime();
  inline void clear_has_strdatetime();
  inline void set_has_strchanneldate();
  inline void clear_has_strchanneldate();
  inline void set_has_strrepondcode();
  inline void clear_has_strrepondcode();
  inline void set_has_strchinesedescribeinfo();
  inline void clear_has_strchinesedescribeinfo();
  inline void set_has_strbusinesscode();
  inline void clear_has_strbusinesscode();
  inline void set_has_strbusinessname();
  inline void clear_has_strbusinessname();
  inline void set_has_strbusinessstatus();
  inline void clear_has_strbusinessstatus();
  inline void set_has_strproducecode();
  inline void clear_has_strproducecode();
  inline void set_has_strobjectproducecode();
  inline void clear_has_strobjectproducecode();
  inline void set_has_strfundname();
  inline void clear_has_strfundname();
  inline void set_has_strproducename();
  inline void clear_has_strproducename();
  inline void set_has_strincometype();
  inline void clear_has_strincometype();
  inline void set_has_strbusinessdate();
  inline void clear_has_strbusinessdate();
  inline void set_has_strclientname();
  inline void clear_has_strclientname();
  inline void set_has_strcredenitialstype();
  inline void clear_has_strcredenitialstype();
  inline void set_has_strcredenitialnum();
  inline void clear_has_strcredenitialnum();
  inline void set_has_strmediumtype();
  inline void clear_has_strmediumtype();
  inline void set_has_strmediumnum();
  inline void clear_has_strmediumnum();
  inline void set_has_strclientrisklevel();
  inline void clear_has_strclientrisklevel();
  inline void set_has_strproducerisklevel();
  inline void clear_has_strproducerisklevel();
  inline void set_has_strfundtype();
  inline void clear_has_strfundtype();
  inline void set_has_strcancelbusinesstype();
  inline void clear_has_strcancelbusinesstype();
  inline void set_has_strterminalip();
  inline void clear_has_strterminalip();
  inline void set_has_strtradeserialnum();
  inline void clear_has_strtradeserialnum();
  inline void set_has_strfinancserialnum();
  inline void clear_has_strfinancserialnum();
  inline void set_has_nsystemtype();
  inline void clear_has_nsystemtype();
  inline void set_has_nbootflag();
  inline void clear_has_nbootflag();
  inline void set_has_strtermid();
  inline void clear_has_strtermid();
  inline void set_has_strtrantime();
  inline void clear_has_strtrantime();
  inline void set_has_stracctno();
  inline void clear_has_stracctno();
  inline void set_has_stribfisserialnum();
  inline void clear_has_stribfisserialnum();
  inline void set_has_strvideoenddate();
  inline void clear_has_strvideoenddate();
  inline void set_has_strextendedinfo();
  inline void clear_has_strextendedinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strchannelcode_;
  ::std::string* strservicecode_;
  ::std::string* strjdbrid_;
  ::std::string* stroperatorid_;
  ::std::string* strchannelserialnum_;
  ::std::string* strkernelserialnum_;
  ::std::string* strdatetime_;
  ::std::string* strchanneldate_;
  ::std::string* strrepondcode_;
  ::std::string* strchinesedescribeinfo_;
  ::std::string* strbusinesscode_;
  ::std::string* strbusinessname_;
  ::std::string* strbusinessstatus_;
  ::std::string* strproducecode_;
  ::std::string* strobjectproducecode_;
  ::std::string* strfundname_;
  ::std::string* strproducename_;
  ::std::string* strincometype_;
  ::std::string* strbusinessdate_;
  ::std::string* strclientname_;
  ::std::string* strcredenitialstype_;
  ::std::string* strcredenitialnum_;
  ::std::string* strmediumtype_;
  ::std::string* strmediumnum_;
  ::std::string* strclientrisklevel_;
  ::std::string* strproducerisklevel_;
  ::std::string* strfundtype_;
  ::std::string* strcancelbusinesstype_;
  ::std::string* strterminalip_;
  ::std::string* strtradeserialnum_;
  ::std::string* strfinancserialnum_;
  ::google::protobuf::int32 nsystemtype_;
  ::google::protobuf::int32 nbootflag_;
  ::std::string* strtermid_;
  ::std::string* strtrantime_;
  ::std::string* stracctno_;
  ::std::string* stribfisserialnum_;
  ::std::string* strvideoenddate_;
  ::std::string* strextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static BusinessDockMsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class ManualSyncParameter : public ::google::protobuf::Message {
 public:
  ManualSyncParameter();
  virtual ~ManualSyncParameter();

  ManualSyncParameter(const ManualSyncParameter& from);

  inline ManualSyncParameter& operator=(const ManualSyncParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualSyncParameter& default_instance();

  void Swap(ManualSyncParameter* other);

  // implements Message ----------------------------------------------

  ManualSyncParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualSyncParameter& from);
  void MergeFrom(const ManualSyncParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nBranchInfo = 1;
  inline bool has_nbranchinfo() const;
  inline void clear_nbranchinfo();
  static const int kNBranchInfoFieldNumber = 1;
  inline ::google::protobuf::int32 nbranchinfo() const;
  inline void set_nbranchinfo(::google::protobuf::int32 value);

  // required int32 nProduceInfo = 2;
  inline bool has_nproduceinfo() const;
  inline void clear_nproduceinfo();
  static const int kNProduceInfoFieldNumber = 2;
  inline ::google::protobuf::int32 nproduceinfo() const;
  inline void set_nproduceinfo(::google::protobuf::int32 value);

  // required int32 nEmployeeInfo = 3;
  inline bool has_nemployeeinfo() const;
  inline void clear_nemployeeinfo();
  static const int kNEmployeeInfoFieldNumber = 3;
  inline ::google::protobuf::int32 nemployeeinfo() const;
  inline void set_nemployeeinfo(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.ManualSyncParameter)
 private:
  inline void set_has_nbranchinfo();
  inline void clear_has_nbranchinfo();
  inline void set_has_nproduceinfo();
  inline void clear_has_nproduceinfo();
  inline void set_has_nemployeeinfo();
  inline void clear_has_nemployeeinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 nbranchinfo_;
  ::google::protobuf::int32 nproduceinfo_;
  ::google::protobuf::int32 nemployeeinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static ManualSyncParameter* default_instance_;
};
// -------------------------------------------------------------------

class ScriptInfo : public ::google::protobuf::Message {
 public:
  ScriptInfo();
  virtual ~ScriptInfo();

  ScriptInfo(const ScriptInfo& from);

  inline ScriptInfo& operator=(const ScriptInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScriptInfo& default_instance();

  void Swap(ScriptInfo* other);

  // implements Message ----------------------------------------------

  ScriptInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScriptInfo& from);
  void MergeFrom(const ScriptInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strScriptId = 1;
  inline bool has_strscriptid() const;
  inline void clear_strscriptid();
  static const int kStrScriptIdFieldNumber = 1;
  inline const ::std::string& strscriptid() const;
  inline void set_strscriptid(const ::std::string& value);
  inline void set_strscriptid(const char* value);
  inline void set_strscriptid(const char* value, size_t size);
  inline ::std::string* mutable_strscriptid();
  inline ::std::string* release_strscriptid();
  inline void set_allocated_strscriptid(::std::string* strscriptid);

  // required string strBusinessCode = 2;
  inline bool has_strbusinesscode() const;
  inline void clear_strbusinesscode();
  static const int kStrBusinessCodeFieldNumber = 2;
  inline const ::std::string& strbusinesscode() const;
  inline void set_strbusinesscode(const ::std::string& value);
  inline void set_strbusinesscode(const char* value);
  inline void set_strbusinesscode(const char* value, size_t size);
  inline ::std::string* mutable_strbusinesscode();
  inline ::std::string* release_strbusinesscode();
  inline void set_allocated_strbusinesscode(::std::string* strbusinesscode);

  // required string strBusinessType = 3;
  inline bool has_strbusinesstype() const;
  inline void clear_strbusinesstype();
  static const int kStrBusinessTypeFieldNumber = 3;
  inline const ::std::string& strbusinesstype() const;
  inline void set_strbusinesstype(const ::std::string& value);
  inline void set_strbusinesstype(const char* value);
  inline void set_strbusinesstype(const char* value, size_t size);
  inline ::std::string* mutable_strbusinesstype();
  inline ::std::string* release_strbusinesstype();
  inline void set_allocated_strbusinesstype(::std::string* strbusinesstype);

  // required string strScriptContent = 4;
  inline bool has_strscriptcontent() const;
  inline void clear_strscriptcontent();
  static const int kStrScriptContentFieldNumber = 4;
  inline const ::std::string& strscriptcontent() const;
  inline void set_strscriptcontent(const ::std::string& value);
  inline void set_strscriptcontent(const char* value);
  inline void set_strscriptcontent(const char* value, size_t size);
  inline ::std::string* mutable_strscriptcontent();
  inline ::std::string* release_strscriptcontent();
  inline void set_allocated_strscriptcontent(::std::string* strscriptcontent);

  // required int32 nExtendedInfo = 5;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 5;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 6;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 6;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // required string strExtendedInfo2 = 7;
  inline bool has_strextendedinfo2() const;
  inline void clear_strextendedinfo2();
  static const int kStrExtendedInfo2FieldNumber = 7;
  inline const ::std::string& strextendedinfo2() const;
  inline void set_strextendedinfo2(const ::std::string& value);
  inline void set_strextendedinfo2(const char* value);
  inline void set_strextendedinfo2(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo2();
  inline ::std::string* release_strextendedinfo2();
  inline void set_allocated_strextendedinfo2(::std::string* strextendedinfo2);

  // @@protoc_insertion_point(class_scope:BFIS.ScriptInfo)
 private:
  inline void set_has_strscriptid();
  inline void clear_has_strscriptid();
  inline void set_has_strbusinesscode();
  inline void clear_has_strbusinesscode();
  inline void set_has_strbusinesstype();
  inline void clear_has_strbusinesstype();
  inline void set_has_strscriptcontent();
  inline void clear_has_strscriptcontent();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();
  inline void set_has_strextendedinfo2();
  inline void clear_has_strextendedinfo2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strscriptid_;
  ::std::string* strbusinesscode_;
  ::std::string* strbusinesstype_;
  ::std::string* strscriptcontent_;
  ::std::string* strextendedinfo1_;
  ::std::string* strextendedinfo2_;
  ::google::protobuf::int32 nextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static ScriptInfo* default_instance_;
};
// -------------------------------------------------------------------

class OperateLogInfo : public ::google::protobuf::Message {
 public:
  OperateLogInfo();
  virtual ~OperateLogInfo();

  OperateLogInfo(const OperateLogInfo& from);

  inline OperateLogInfo& operator=(const OperateLogInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperateLogInfo& default_instance();

  void Swap(OperateLogInfo* other);

  // implements Message ----------------------------------------------

  OperateLogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperateLogInfo& from);
  void MergeFrom(const OperateLogInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strOperateLogId = 1;
  inline bool has_stroperatelogid() const;
  inline void clear_stroperatelogid();
  static const int kStrOperateLogIdFieldNumber = 1;
  inline const ::std::string& stroperatelogid() const;
  inline void set_stroperatelogid(const ::std::string& value);
  inline void set_stroperatelogid(const char* value);
  inline void set_stroperatelogid(const char* value, size_t size);
  inline ::std::string* mutable_stroperatelogid();
  inline ::std::string* release_stroperatelogid();
  inline void set_allocated_stroperatelogid(::std::string* stroperatelogid);

  // required string strModule = 2;
  inline bool has_strmodule() const;
  inline void clear_strmodule();
  static const int kStrModuleFieldNumber = 2;
  inline const ::std::string& strmodule() const;
  inline void set_strmodule(const ::std::string& value);
  inline void set_strmodule(const char* value);
  inline void set_strmodule(const char* value, size_t size);
  inline ::std::string* mutable_strmodule();
  inline ::std::string* release_strmodule();
  inline void set_allocated_strmodule(::std::string* strmodule);

  // required string strOperateEvent = 3;
  inline bool has_stroperateevent() const;
  inline void clear_stroperateevent();
  static const int kStrOperateEventFieldNumber = 3;
  inline const ::std::string& stroperateevent() const;
  inline void set_stroperateevent(const ::std::string& value);
  inline void set_stroperateevent(const char* value);
  inline void set_stroperateevent(const char* value, size_t size);
  inline ::std::string* mutable_stroperateevent();
  inline ::std::string* release_stroperateevent();
  inline void set_allocated_stroperateevent(::std::string* stroperateevent);

  // required string strIp = 4;
  inline bool has_strip() const;
  inline void clear_strip();
  static const int kStrIpFieldNumber = 4;
  inline const ::std::string& strip() const;
  inline void set_strip(const ::std::string& value);
  inline void set_strip(const char* value);
  inline void set_strip(const char* value, size_t size);
  inline ::std::string* mutable_strip();
  inline ::std::string* release_strip();
  inline void set_allocated_strip(::std::string* strip);

  // required string strEmployeeId = 5;
  inline bool has_stremployeeid() const;
  inline void clear_stremployeeid();
  static const int kStrEmployeeIdFieldNumber = 5;
  inline const ::std::string& stremployeeid() const;
  inline void set_stremployeeid(const ::std::string& value);
  inline void set_stremployeeid(const char* value);
  inline void set_stremployeeid(const char* value, size_t size);
  inline ::std::string* mutable_stremployeeid();
  inline ::std::string* release_stremployeeid();
  inline void set_allocated_stremployeeid(::std::string* stremployeeid);

  // required string strBranchId = 6;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrBranchIdFieldNumber = 6;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required string stOperateTime = 7;
  inline bool has_stoperatetime() const;
  inline void clear_stoperatetime();
  static const int kStOperateTimeFieldNumber = 7;
  inline const ::std::string& stoperatetime() const;
  inline void set_stoperatetime(const ::std::string& value);
  inline void set_stoperatetime(const char* value);
  inline void set_stoperatetime(const char* value, size_t size);
  inline ::std::string* mutable_stoperatetime();
  inline ::std::string* release_stoperatetime();
  inline void set_allocated_stoperatetime(::std::string* stoperatetime);

  // required int32 nExtendedInfo = 8;
  inline bool has_nextendedinfo() const;
  inline void clear_nextendedinfo();
  static const int kNExtendedInfoFieldNumber = 8;
  inline ::google::protobuf::int32 nextendedinfo() const;
  inline void set_nextendedinfo(::google::protobuf::int32 value);

  // required string strExtendedInfo1 = 9;
  inline bool has_strextendedinfo1() const;
  inline void clear_strextendedinfo1();
  static const int kStrExtendedInfo1FieldNumber = 9;
  inline const ::std::string& strextendedinfo1() const;
  inline void set_strextendedinfo1(const ::std::string& value);
  inline void set_strextendedinfo1(const char* value);
  inline void set_strextendedinfo1(const char* value, size_t size);
  inline ::std::string* mutable_strextendedinfo1();
  inline ::std::string* release_strextendedinfo1();
  inline void set_allocated_strextendedinfo1(::std::string* strextendedinfo1);

  // @@protoc_insertion_point(class_scope:BFIS.OperateLogInfo)
 private:
  inline void set_has_stroperatelogid();
  inline void clear_has_stroperatelogid();
  inline void set_has_strmodule();
  inline void clear_has_strmodule();
  inline void set_has_stroperateevent();
  inline void clear_has_stroperateevent();
  inline void set_has_strip();
  inline void clear_has_strip();
  inline void set_has_stremployeeid();
  inline void clear_has_stremployeeid();
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_stoperatetime();
  inline void clear_has_stoperatetime();
  inline void set_has_nextendedinfo();
  inline void clear_has_nextendedinfo();
  inline void set_has_strextendedinfo1();
  inline void clear_has_strextendedinfo1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stroperatelogid_;
  ::std::string* strmodule_;
  ::std::string* stroperateevent_;
  ::std::string* strip_;
  ::std::string* stremployeeid_;
  ::std::string* strbranchid_;
  ::std::string* stoperatetime_;
  ::std::string* strextendedinfo1_;
  ::google::protobuf::int32 nextendedinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static OperateLogInfo* default_instance_;
};
// -------------------------------------------------------------------

class DiskAndConnectStatus : public ::google::protobuf::Message {
 public:
  DiskAndConnectStatus();
  virtual ~DiskAndConnectStatus();

  DiskAndConnectStatus(const DiskAndConnectStatus& from);

  inline DiskAndConnectStatus& operator=(const DiskAndConnectStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskAndConnectStatus& default_instance();

  void Swap(DiskAndConnectStatus* other);

  // implements Message ----------------------------------------------

  DiskAndConnectStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskAndConnectStatus& from);
  void MergeFrom(const DiskAndConnectStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strbranchId = 1;
  inline bool has_strbranchid() const;
  inline void clear_strbranchid();
  static const int kStrbranchIdFieldNumber = 1;
  inline const ::std::string& strbranchid() const;
  inline void set_strbranchid(const ::std::string& value);
  inline void set_strbranchid(const char* value);
  inline void set_strbranchid(const char* value, size_t size);
  inline ::std::string* mutable_strbranchid();
  inline ::std::string* release_strbranchid();
  inline void set_allocated_strbranchid(::std::string* strbranchid);

  // required int32 nConnectStatus = 2;
  inline bool has_nconnectstatus() const;
  inline void clear_nconnectstatus();
  static const int kNConnectStatusFieldNumber = 2;
  inline ::google::protobuf::int32 nconnectstatus() const;
  inline void set_nconnectstatus(::google::protobuf::int32 value);

  // required int32 nDiskTatolSpace = 3;
  inline bool has_ndisktatolspace() const;
  inline void clear_ndisktatolspace();
  static const int kNDiskTatolSpaceFieldNumber = 3;
  inline ::google::protobuf::int32 ndisktatolspace() const;
  inline void set_ndisktatolspace(::google::protobuf::int32 value);

  // required int32 nDiskFreeSpace = 4;
  inline bool has_ndiskfreespace() const;
  inline void clear_ndiskfreespace();
  static const int kNDiskFreeSpaceFieldNumber = 4;
  inline ::google::protobuf::int32 ndiskfreespace() const;
  inline void set_ndiskfreespace(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BFIS.DiskAndConnectStatus)
 private:
  inline void set_has_strbranchid();
  inline void clear_has_strbranchid();
  inline void set_has_nconnectstatus();
  inline void clear_has_nconnectstatus();
  inline void set_has_ndisktatolspace();
  inline void clear_has_ndisktatolspace();
  inline void set_has_ndiskfreespace();
  inline void clear_has_ndiskfreespace();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strbranchid_;
  ::google::protobuf::int32 nconnectstatus_;
  ::google::protobuf::int32 ndisktatolspace_;
  ::google::protobuf::int32 ndiskfreespace_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_AssignDesc_BFIS_2eProtoMessageDefine_2eproto();
  friend void protobuf_ShutdownFile_BFIS_2eProtoMessageDefine_2eproto();

  void InitAsDefaultInstance();
  static DiskAndConnectStatus* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientInfo

// required string strClientId = 1;
inline bool ClientInfo::has_strclientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfo::set_has_strclientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInfo::clear_has_strclientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInfo::clear_strclientid() {
  if (strclientid_ != &::google::protobuf::internal::kEmptyString) {
    strclientid_->clear();
  }
  clear_has_strclientid();
}
inline const ::std::string& ClientInfo::strclientid() const {
  return *strclientid_;
}
inline void ClientInfo::set_strclientid(const ::std::string& value) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(value);
}
inline void ClientInfo::set_strclientid(const char* value) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(value);
}
inline void ClientInfo::set_strclientid(const char* value, size_t size) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strclientid() {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  return strclientid_;
}
inline ::std::string* ClientInfo::release_strclientid() {
  clear_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strclientid_;
    strclientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strclientid(::std::string* strclientid) {
  if (strclientid_ != &::google::protobuf::internal::kEmptyString) {
    delete strclientid_;
  }
  if (strclientid) {
    set_has_strclientid();
    strclientid_ = strclientid;
  } else {
    clear_has_strclientid();
    strclientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strName = 2;
inline bool ClientInfo::has_strname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfo::set_has_strname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInfo::clear_has_strname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInfo::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& ClientInfo::strname() const {
  return *strname_;
}
inline void ClientInfo::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ClientInfo::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ClientInfo::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* ClientInfo::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strname(::std::string* strname) {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    delete strname_;
  }
  if (strname) {
    set_has_strname();
    strname_ = strname;
  } else {
    clear_has_strname();
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCredenitialsType = 3;
inline bool ClientInfo::has_strcredenitialstype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientInfo::set_has_strcredenitialstype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientInfo::clear_has_strcredenitialstype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientInfo::clear_strcredenitialstype() {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_->clear();
  }
  clear_has_strcredenitialstype();
}
inline const ::std::string& ClientInfo::strcredenitialstype() const {
  return *strcredenitialstype_;
}
inline void ClientInfo::set_strcredenitialstype(const ::std::string& value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void ClientInfo::set_strcredenitialstype(const char* value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void ClientInfo::set_strcredenitialstype(const char* value, size_t size) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strcredenitialstype() {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  return strcredenitialstype_;
}
inline ::std::string* ClientInfo::release_strcredenitialstype() {
  clear_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcredenitialstype_;
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strcredenitialstype(::std::string* strcredenitialstype) {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcredenitialstype_;
  }
  if (strcredenitialstype) {
    set_has_strcredenitialstype();
    strcredenitialstype_ = strcredenitialstype;
  } else {
    clear_has_strcredenitialstype();
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCredenitial = 4;
inline bool ClientInfo::has_strcredenitial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientInfo::set_has_strcredenitial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientInfo::clear_has_strcredenitial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientInfo::clear_strcredenitial() {
  if (strcredenitial_ != &::google::protobuf::internal::kEmptyString) {
    strcredenitial_->clear();
  }
  clear_has_strcredenitial();
}
inline const ::std::string& ClientInfo::strcredenitial() const {
  return *strcredenitial_;
}
inline void ClientInfo::set_strcredenitial(const ::std::string& value) {
  set_has_strcredenitial();
  if (strcredenitial_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitial_ = new ::std::string;
  }
  strcredenitial_->assign(value);
}
inline void ClientInfo::set_strcredenitial(const char* value) {
  set_has_strcredenitial();
  if (strcredenitial_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitial_ = new ::std::string;
  }
  strcredenitial_->assign(value);
}
inline void ClientInfo::set_strcredenitial(const char* value, size_t size) {
  set_has_strcredenitial();
  if (strcredenitial_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitial_ = new ::std::string;
  }
  strcredenitial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strcredenitial() {
  set_has_strcredenitial();
  if (strcredenitial_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitial_ = new ::std::string;
  }
  return strcredenitial_;
}
inline ::std::string* ClientInfo::release_strcredenitial() {
  clear_has_strcredenitial();
  if (strcredenitial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcredenitial_;
    strcredenitial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strcredenitial(::std::string* strcredenitial) {
  if (strcredenitial_ != &::google::protobuf::internal::kEmptyString) {
    delete strcredenitial_;
  }
  if (strcredenitial) {
    set_has_strcredenitial();
    strcredenitial_ = strcredenitial;
  } else {
    clear_has_strcredenitial();
    strcredenitial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPhone = 5;
inline bool ClientInfo::has_strphone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientInfo::set_has_strphone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientInfo::clear_has_strphone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientInfo::clear_strphone() {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    strphone_->clear();
  }
  clear_has_strphone();
}
inline const ::std::string& ClientInfo::strphone() const {
  return *strphone_;
}
inline void ClientInfo::set_strphone(const ::std::string& value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void ClientInfo::set_strphone(const char* value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void ClientInfo::set_strphone(const char* value, size_t size) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strphone() {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  return strphone_;
}
inline ::std::string* ClientInfo::release_strphone() {
  clear_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strphone_;
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strphone(::std::string* strphone) {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    delete strphone_;
  }
  if (strphone) {
    set_has_strphone();
    strphone_ = strphone;
  } else {
    clear_has_strphone();
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strContent = 6;
inline bool ClientInfo::has_strcontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientInfo::set_has_strcontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientInfo::clear_has_strcontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientInfo::clear_strcontent() {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    strcontent_->clear();
  }
  clear_has_strcontent();
}
inline const ::std::string& ClientInfo::strcontent() const {
  return *strcontent_;
}
inline void ClientInfo::set_strcontent(const ::std::string& value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void ClientInfo::set_strcontent(const char* value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void ClientInfo::set_strcontent(const char* value, size_t size) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strcontent() {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  return strcontent_;
}
inline ::std::string* ClientInfo::release_strcontent() {
  clear_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcontent_;
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strcontent(::std::string* strcontent) {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete strcontent_;
  }
  if (strcontent) {
    set_has_strcontent();
    strcontent_ = strcontent;
  } else {
    clear_has_strcontent();
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 7;
inline bool ClientInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 ClientInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void ClientInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 8;
inline bool ClientInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& ClientInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void ClientInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ClientInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ClientInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* ClientInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 9;
inline bool ClientInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& ClientInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void ClientInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ClientInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ClientInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* ClientInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RolePurviewInfo

// required string strRoleInfoPurviewId = 1;
inline bool RolePurviewInfo::has_strroleinfopurviewid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RolePurviewInfo::set_has_strroleinfopurviewid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RolePurviewInfo::clear_has_strroleinfopurviewid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RolePurviewInfo::clear_strroleinfopurviewid() {
  if (strroleinfopurviewid_ != &::google::protobuf::internal::kEmptyString) {
    strroleinfopurviewid_->clear();
  }
  clear_has_strroleinfopurviewid();
}
inline const ::std::string& RolePurviewInfo::strroleinfopurviewid() const {
  return *strroleinfopurviewid_;
}
inline void RolePurviewInfo::set_strroleinfopurviewid(const ::std::string& value) {
  set_has_strroleinfopurviewid();
  if (strroleinfopurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfopurviewid_ = new ::std::string;
  }
  strroleinfopurviewid_->assign(value);
}
inline void RolePurviewInfo::set_strroleinfopurviewid(const char* value) {
  set_has_strroleinfopurviewid();
  if (strroleinfopurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfopurviewid_ = new ::std::string;
  }
  strroleinfopurviewid_->assign(value);
}
inline void RolePurviewInfo::set_strroleinfopurviewid(const char* value, size_t size) {
  set_has_strroleinfopurviewid();
  if (strroleinfopurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfopurviewid_ = new ::std::string;
  }
  strroleinfopurviewid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RolePurviewInfo::mutable_strroleinfopurviewid() {
  set_has_strroleinfopurviewid();
  if (strroleinfopurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfopurviewid_ = new ::std::string;
  }
  return strroleinfopurviewid_;
}
inline ::std::string* RolePurviewInfo::release_strroleinfopurviewid() {
  clear_has_strroleinfopurviewid();
  if (strroleinfopurviewid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strroleinfopurviewid_;
    strroleinfopurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RolePurviewInfo::set_allocated_strroleinfopurviewid(::std::string* strroleinfopurviewid) {
  if (strroleinfopurviewid_ != &::google::protobuf::internal::kEmptyString) {
    delete strroleinfopurviewid_;
  }
  if (strroleinfopurviewid) {
    set_has_strroleinfopurviewid();
    strroleinfopurviewid_ = strroleinfopurviewid;
  } else {
    clear_has_strroleinfopurviewid();
    strroleinfopurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRoleId = 2;
inline bool RolePurviewInfo::has_strroleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RolePurviewInfo::set_has_strroleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RolePurviewInfo::clear_has_strroleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RolePurviewInfo::clear_strroleid() {
  if (strroleid_ != &::google::protobuf::internal::kEmptyString) {
    strroleid_->clear();
  }
  clear_has_strroleid();
}
inline const ::std::string& RolePurviewInfo::strroleid() const {
  return *strroleid_;
}
inline void RolePurviewInfo::set_strroleid(const ::std::string& value) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(value);
}
inline void RolePurviewInfo::set_strroleid(const char* value) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(value);
}
inline void RolePurviewInfo::set_strroleid(const char* value, size_t size) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RolePurviewInfo::mutable_strroleid() {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  return strroleid_;
}
inline ::std::string* RolePurviewInfo::release_strroleid() {
  clear_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strroleid_;
    strroleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RolePurviewInfo::set_allocated_strroleid(::std::string* strroleid) {
  if (strroleid_ != &::google::protobuf::internal::kEmptyString) {
    delete strroleid_;
  }
  if (strroleid) {
    set_has_strroleid();
    strroleid_ = strroleid;
  } else {
    clear_has_strroleid();
    strroleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPruviewInfoId = 3;
inline bool RolePurviewInfo::has_strpruviewinfoid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RolePurviewInfo::set_has_strpruviewinfoid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RolePurviewInfo::clear_has_strpruviewinfoid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RolePurviewInfo::clear_strpruviewinfoid() {
  if (strpruviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strpruviewinfoid_->clear();
  }
  clear_has_strpruviewinfoid();
}
inline const ::std::string& RolePurviewInfo::strpruviewinfoid() const {
  return *strpruviewinfoid_;
}
inline void RolePurviewInfo::set_strpruviewinfoid(const ::std::string& value) {
  set_has_strpruviewinfoid();
  if (strpruviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpruviewinfoid_ = new ::std::string;
  }
  strpruviewinfoid_->assign(value);
}
inline void RolePurviewInfo::set_strpruviewinfoid(const char* value) {
  set_has_strpruviewinfoid();
  if (strpruviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpruviewinfoid_ = new ::std::string;
  }
  strpruviewinfoid_->assign(value);
}
inline void RolePurviewInfo::set_strpruviewinfoid(const char* value, size_t size) {
  set_has_strpruviewinfoid();
  if (strpruviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpruviewinfoid_ = new ::std::string;
  }
  strpruviewinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RolePurviewInfo::mutable_strpruviewinfoid() {
  set_has_strpruviewinfoid();
  if (strpruviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpruviewinfoid_ = new ::std::string;
  }
  return strpruviewinfoid_;
}
inline ::std::string* RolePurviewInfo::release_strpruviewinfoid() {
  clear_has_strpruviewinfoid();
  if (strpruviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpruviewinfoid_;
    strpruviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RolePurviewInfo::set_allocated_strpruviewinfoid(::std::string* strpruviewinfoid) {
  if (strpruviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strpruviewinfoid_;
  }
  if (strpruviewinfoid) {
    set_has_strpruviewinfoid();
    strpruviewinfoid_ = strpruviewinfoid;
  } else {
    clear_has_strpruviewinfoid();
    strpruviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 4;
inline bool RolePurviewInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RolePurviewInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RolePurviewInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RolePurviewInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 RolePurviewInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void RolePurviewInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 5;
inline bool RolePurviewInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RolePurviewInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RolePurviewInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RolePurviewInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& RolePurviewInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void RolePurviewInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void RolePurviewInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void RolePurviewInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RolePurviewInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* RolePurviewInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RolePurviewInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 6;
inline bool RolePurviewInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RolePurviewInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RolePurviewInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RolePurviewInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& RolePurviewInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void RolePurviewInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void RolePurviewInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void RolePurviewInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RolePurviewInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* RolePurviewInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RolePurviewInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BusinessInfo

// required string strBusinessInfoId = 1;
inline bool BusinessInfo::has_strbusinessinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessInfo::set_has_strbusinessinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessInfo::clear_has_strbusinessinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessInfo::clear_strbusinessinfoid() {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_->clear();
  }
  clear_has_strbusinessinfoid();
}
inline const ::std::string& BusinessInfo::strbusinessinfoid() const {
  return *strbusinessinfoid_;
}
inline void BusinessInfo::set_strbusinessinfoid(const ::std::string& value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessInfo::set_strbusinessinfoid(const char* value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessInfo::set_strbusinessinfoid(const char* value, size_t size) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strbusinessinfoid() {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  return strbusinessinfoid_;
}
inline ::std::string* BusinessInfo::release_strbusinessinfoid() {
  clear_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessinfoid_;
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid) {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessinfoid_;
  }
  if (strbusinessinfoid) {
    set_has_strbusinessinfoid();
    strbusinessinfoid_ = strbusinessinfoid;
  } else {
    clear_has_strbusinessinfoid();
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strDateTime = 2;
inline bool BusinessInfo::has_strdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessInfo::set_has_strdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessInfo::clear_has_strdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessInfo::clear_strdatetime() {
  if (strdatetime_ != &::google::protobuf::internal::kEmptyString) {
    strdatetime_->clear();
  }
  clear_has_strdatetime();
}
inline const ::std::string& BusinessInfo::strdatetime() const {
  return *strdatetime_;
}
inline void BusinessInfo::set_strdatetime(const ::std::string& value) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(value);
}
inline void BusinessInfo::set_strdatetime(const char* value) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(value);
}
inline void BusinessInfo::set_strdatetime(const char* value, size_t size) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strdatetime() {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  return strdatetime_;
}
inline ::std::string* BusinessInfo::release_strdatetime() {
  clear_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdatetime_;
    strdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strdatetime(::std::string* strdatetime) {
  if (strdatetime_ != &::google::protobuf::internal::kEmptyString) {
    delete strdatetime_;
  }
  if (strdatetime) {
    set_has_strdatetime();
    strdatetime_ = strdatetime;
  } else {
    clear_has_strdatetime();
    strdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBranchId = 3;
inline bool BusinessInfo::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessInfo::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessInfo::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessInfo::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& BusinessInfo::strbranchid() const {
  return *strbranchid_;
}
inline void BusinessInfo::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BusinessInfo::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BusinessInfo::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* BusinessInfo::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strClientId = 4;
inline bool BusinessInfo::has_strclientid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessInfo::set_has_strclientid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessInfo::clear_has_strclientid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessInfo::clear_strclientid() {
  if (strclientid_ != &::google::protobuf::internal::kEmptyString) {
    strclientid_->clear();
  }
  clear_has_strclientid();
}
inline const ::std::string& BusinessInfo::strclientid() const {
  return *strclientid_;
}
inline void BusinessInfo::set_strclientid(const ::std::string& value) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(value);
}
inline void BusinessInfo::set_strclientid(const char* value) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(value);
}
inline void BusinessInfo::set_strclientid(const char* value, size_t size) {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  strclientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strclientid() {
  set_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    strclientid_ = new ::std::string;
  }
  return strclientid_;
}
inline ::std::string* BusinessInfo::release_strclientid() {
  clear_has_strclientid();
  if (strclientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strclientid_;
    strclientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strclientid(::std::string* strclientid) {
  if (strclientid_ != &::google::protobuf::internal::kEmptyString) {
    delete strclientid_;
  }
  if (strclientid) {
    set_has_strclientid();
    strclientid_ = strclientid;
  } else {
    clear_has_strclientid();
    strclientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeId = 5;
inline bool BusinessInfo::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessInfo::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessInfo::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessInfo::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& BusinessInfo::stremployeeid() const {
  return *stremployeeid_;
}
inline void BusinessInfo::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BusinessInfo::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BusinessInfo::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* BusinessInfo::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceId = 6;
inline bool BusinessInfo::has_strproduceid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessInfo::set_has_strproduceid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessInfo::clear_has_strproduceid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessInfo::clear_strproduceid() {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    strproduceid_->clear();
  }
  clear_has_strproduceid();
}
inline const ::std::string& BusinessInfo::strproduceid() const {
  return *strproduceid_;
}
inline void BusinessInfo::set_strproduceid(const ::std::string& value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BusinessInfo::set_strproduceid(const char* value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BusinessInfo::set_strproduceid(const char* value, size_t size) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strproduceid() {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  return strproduceid_;
}
inline ::std::string* BusinessInfo::release_strproduceid() {
  clear_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproduceid_;
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strproduceid(::std::string* strproduceid) {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    delete strproduceid_;
  }
  if (strproduceid) {
    set_has_strproduceid();
    strproduceid_ = strproduceid;
  } else {
    clear_has_strproduceid();
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSubEquipmentId = 7;
inline bool BusinessInfo::has_strsubequipmentid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BusinessInfo::set_has_strsubequipmentid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BusinessInfo::clear_has_strsubequipmentid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BusinessInfo::clear_strsubequipmentid() {
  if (strsubequipmentid_ != &::google::protobuf::internal::kEmptyString) {
    strsubequipmentid_->clear();
  }
  clear_has_strsubequipmentid();
}
inline const ::std::string& BusinessInfo::strsubequipmentid() const {
  return *strsubequipmentid_;
}
inline void BusinessInfo::set_strsubequipmentid(const ::std::string& value) {
  set_has_strsubequipmentid();
  if (strsubequipmentid_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmentid_ = new ::std::string;
  }
  strsubequipmentid_->assign(value);
}
inline void BusinessInfo::set_strsubequipmentid(const char* value) {
  set_has_strsubequipmentid();
  if (strsubequipmentid_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmentid_ = new ::std::string;
  }
  strsubequipmentid_->assign(value);
}
inline void BusinessInfo::set_strsubequipmentid(const char* value, size_t size) {
  set_has_strsubequipmentid();
  if (strsubequipmentid_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmentid_ = new ::std::string;
  }
  strsubequipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strsubequipmentid() {
  set_has_strsubequipmentid();
  if (strsubequipmentid_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmentid_ = new ::std::string;
  }
  return strsubequipmentid_;
}
inline ::std::string* BusinessInfo::release_strsubequipmentid() {
  clear_has_strsubequipmentid();
  if (strsubequipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsubequipmentid_;
    strsubequipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strsubequipmentid(::std::string* strsubequipmentid) {
  if (strsubequipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete strsubequipmentid_;
  }
  if (strsubequipmentid) {
    set_has_strsubequipmentid();
    strsubequipmentid_ = strsubequipmentid;
  } else {
    clear_has_strsubequipmentid();
    strsubequipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 8;
inline bool BusinessInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BusinessInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BusinessInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BusinessInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 BusinessInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void BusinessInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 9;
inline bool BusinessInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BusinessInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BusinessInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BusinessInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& BusinessInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void BusinessInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BusinessInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BusinessInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* BusinessInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 10;
inline bool BusinessInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BusinessInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BusinessInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BusinessInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& BusinessInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void BusinessInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* BusinessInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSubEquipmentIcmSign = 11;
inline bool BusinessInfo::has_strsubequipmenticmsign() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BusinessInfo::set_has_strsubequipmenticmsign() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BusinessInfo::clear_has_strsubequipmenticmsign() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BusinessInfo::clear_strsubequipmenticmsign() {
  if (strsubequipmenticmsign_ != &::google::protobuf::internal::kEmptyString) {
    strsubequipmenticmsign_->clear();
  }
  clear_has_strsubequipmenticmsign();
}
inline const ::std::string& BusinessInfo::strsubequipmenticmsign() const {
  return *strsubequipmenticmsign_;
}
inline void BusinessInfo::set_strsubequipmenticmsign(const ::std::string& value) {
  set_has_strsubequipmenticmsign();
  if (strsubequipmenticmsign_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmenticmsign_ = new ::std::string;
  }
  strsubequipmenticmsign_->assign(value);
}
inline void BusinessInfo::set_strsubequipmenticmsign(const char* value) {
  set_has_strsubequipmenticmsign();
  if (strsubequipmenticmsign_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmenticmsign_ = new ::std::string;
  }
  strsubequipmenticmsign_->assign(value);
}
inline void BusinessInfo::set_strsubequipmenticmsign(const char* value, size_t size) {
  set_has_strsubequipmenticmsign();
  if (strsubequipmenticmsign_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmenticmsign_ = new ::std::string;
  }
  strsubequipmenticmsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strsubequipmenticmsign() {
  set_has_strsubequipmenticmsign();
  if (strsubequipmenticmsign_ == &::google::protobuf::internal::kEmptyString) {
    strsubequipmenticmsign_ = new ::std::string;
  }
  return strsubequipmenticmsign_;
}
inline ::std::string* BusinessInfo::release_strsubequipmenticmsign() {
  clear_has_strsubequipmenticmsign();
  if (strsubequipmenticmsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsubequipmenticmsign_;
    strsubequipmenticmsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strsubequipmenticmsign(::std::string* strsubequipmenticmsign) {
  if (strsubequipmenticmsign_ != &::google::protobuf::internal::kEmptyString) {
    delete strsubequipmenticmsign_;
  }
  if (strsubequipmenticmsign) {
    set_has_strsubequipmenticmsign();
    strsubequipmenticmsign_ = strsubequipmenticmsign;
  } else {
    clear_has_strsubequipmenticmsign();
    strsubequipmenticmsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSerialNumber = 12;
inline bool BusinessInfo::has_strserialnumber() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BusinessInfo::set_has_strserialnumber() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BusinessInfo::clear_has_strserialnumber() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BusinessInfo::clear_strserialnumber() {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    strserialnumber_->clear();
  }
  clear_has_strserialnumber();
}
inline const ::std::string& BusinessInfo::strserialnumber() const {
  return *strserialnumber_;
}
inline void BusinessInfo::set_strserialnumber(const ::std::string& value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BusinessInfo::set_strserialnumber(const char* value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BusinessInfo::set_strserialnumber(const char* value, size_t size) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strserialnumber() {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  return strserialnumber_;
}
inline ::std::string* BusinessInfo::release_strserialnumber() {
  clear_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strserialnumber_;
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strserialnumber(::std::string* strserialnumber) {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete strserialnumber_;
  }
  if (strserialnumber) {
    set_has_strserialnumber();
    strserialnumber_ = strserialnumber;
  } else {
    clear_has_strserialnumber();
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMigrated = 13;
inline bool BusinessInfo::has_nmigrated() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BusinessInfo::set_has_nmigrated() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BusinessInfo::clear_has_nmigrated() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BusinessInfo::clear_nmigrated() {
  nmigrated_ = 0;
  clear_has_nmigrated();
}
inline ::google::protobuf::int32 BusinessInfo::nmigrated() const {
  return nmigrated_;
}
inline void BusinessInfo::set_nmigrated(::google::protobuf::int32 value) {
  set_has_nmigrated();
  nmigrated_ = value;
}

// required string strFileCenter = 14;
inline bool BusinessInfo::has_strfilecenter() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BusinessInfo::set_has_strfilecenter() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BusinessInfo::clear_has_strfilecenter() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BusinessInfo::clear_strfilecenter() {
  if (strfilecenter_ != &::google::protobuf::internal::kEmptyString) {
    strfilecenter_->clear();
  }
  clear_has_strfilecenter();
}
inline const ::std::string& BusinessInfo::strfilecenter() const {
  return *strfilecenter_;
}
inline void BusinessInfo::set_strfilecenter(const ::std::string& value) {
  set_has_strfilecenter();
  if (strfilecenter_ == &::google::protobuf::internal::kEmptyString) {
    strfilecenter_ = new ::std::string;
  }
  strfilecenter_->assign(value);
}
inline void BusinessInfo::set_strfilecenter(const char* value) {
  set_has_strfilecenter();
  if (strfilecenter_ == &::google::protobuf::internal::kEmptyString) {
    strfilecenter_ = new ::std::string;
  }
  strfilecenter_->assign(value);
}
inline void BusinessInfo::set_strfilecenter(const char* value, size_t size) {
  set_has_strfilecenter();
  if (strfilecenter_ == &::google::protobuf::internal::kEmptyString) {
    strfilecenter_ = new ::std::string;
  }
  strfilecenter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strfilecenter() {
  set_has_strfilecenter();
  if (strfilecenter_ == &::google::protobuf::internal::kEmptyString) {
    strfilecenter_ = new ::std::string;
  }
  return strfilecenter_;
}
inline ::std::string* BusinessInfo::release_strfilecenter() {
  clear_has_strfilecenter();
  if (strfilecenter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strfilecenter_;
    strfilecenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strfilecenter(::std::string* strfilecenter) {
  if (strfilecenter_ != &::google::protobuf::internal::kEmptyString) {
    delete strfilecenter_;
  }
  if (strfilecenter) {
    set_has_strfilecenter();
    strfilecenter_ = strfilecenter;
  } else {
    clear_has_strfilecenter();
    strfilecenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessType = 15;
inline bool BusinessInfo::has_strbusinesstype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BusinessInfo::set_has_strbusinesstype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BusinessInfo::clear_has_strbusinesstype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BusinessInfo::clear_strbusinesstype() {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_->clear();
  }
  clear_has_strbusinesstype();
}
inline const ::std::string& BusinessInfo::strbusinesstype() const {
  return *strbusinesstype_;
}
inline void BusinessInfo::set_strbusinesstype(const ::std::string& value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void BusinessInfo::set_strbusinesstype(const char* value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void BusinessInfo::set_strbusinesstype(const char* value, size_t size) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strbusinesstype() {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  return strbusinesstype_;
}
inline ::std::string* BusinessInfo::release_strbusinesstype() {
  clear_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinesstype_;
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strbusinesstype(::std::string* strbusinesstype) {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinesstype_;
  }
  if (strbusinesstype) {
    set_has_strbusinesstype();
    strbusinesstype_ = strbusinesstype;
  } else {
    clear_has_strbusinesstype();
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCardNumber = 16;
inline bool BusinessInfo::has_strcardnumber() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BusinessInfo::set_has_strcardnumber() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BusinessInfo::clear_has_strcardnumber() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BusinessInfo::clear_strcardnumber() {
  if (strcardnumber_ != &::google::protobuf::internal::kEmptyString) {
    strcardnumber_->clear();
  }
  clear_has_strcardnumber();
}
inline const ::std::string& BusinessInfo::strcardnumber() const {
  return *strcardnumber_;
}
inline void BusinessInfo::set_strcardnumber(const ::std::string& value) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(value);
}
inline void BusinessInfo::set_strcardnumber(const char* value) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(value);
}
inline void BusinessInfo::set_strcardnumber(const char* value, size_t size) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strcardnumber() {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  return strcardnumber_;
}
inline ::std::string* BusinessInfo::release_strcardnumber() {
  clear_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcardnumber_;
    strcardnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strcardnumber(::std::string* strcardnumber) {
  if (strcardnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete strcardnumber_;
  }
  if (strcardnumber) {
    set_has_strcardnumber();
    strcardnumber_ = strcardnumber;
  } else {
    clear_has_strcardnumber();
    strcardnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMarkerType = 17;
inline bool BusinessInfo::has_nmarkertype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BusinessInfo::set_has_nmarkertype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BusinessInfo::clear_has_nmarkertype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BusinessInfo::clear_nmarkertype() {
  nmarkertype_ = 0;
  clear_has_nmarkertype();
}
inline ::google::protobuf::int32 BusinessInfo::nmarkertype() const {
  return nmarkertype_;
}
inline void BusinessInfo::set_nmarkertype(::google::protobuf::int32 value) {
  set_has_nmarkertype();
  nmarkertype_ = value;
}

// required string strCardType = 18;
inline bool BusinessInfo::has_strcardtype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BusinessInfo::set_has_strcardtype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BusinessInfo::clear_has_strcardtype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BusinessInfo::clear_strcardtype() {
  if (strcardtype_ != &::google::protobuf::internal::kEmptyString) {
    strcardtype_->clear();
  }
  clear_has_strcardtype();
}
inline const ::std::string& BusinessInfo::strcardtype() const {
  return *strcardtype_;
}
inline void BusinessInfo::set_strcardtype(const ::std::string& value) {
  set_has_strcardtype();
  if (strcardtype_ == &::google::protobuf::internal::kEmptyString) {
    strcardtype_ = new ::std::string;
  }
  strcardtype_->assign(value);
}
inline void BusinessInfo::set_strcardtype(const char* value) {
  set_has_strcardtype();
  if (strcardtype_ == &::google::protobuf::internal::kEmptyString) {
    strcardtype_ = new ::std::string;
  }
  strcardtype_->assign(value);
}
inline void BusinessInfo::set_strcardtype(const char* value, size_t size) {
  set_has_strcardtype();
  if (strcardtype_ == &::google::protobuf::internal::kEmptyString) {
    strcardtype_ = new ::std::string;
  }
  strcardtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strcardtype() {
  set_has_strcardtype();
  if (strcardtype_ == &::google::protobuf::internal::kEmptyString) {
    strcardtype_ = new ::std::string;
  }
  return strcardtype_;
}
inline ::std::string* BusinessInfo::release_strcardtype() {
  clear_has_strcardtype();
  if (strcardtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcardtype_;
    strcardtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strcardtype(::std::string* strcardtype) {
  if (strcardtype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcardtype_;
  }
  if (strcardtype) {
    set_has_strcardtype();
    strcardtype_ = strcardtype;
  } else {
    clear_has_strcardtype();
    strcardtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMediumType = 19;
inline bool BusinessInfo::has_strmediumtype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BusinessInfo::set_has_strmediumtype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BusinessInfo::clear_has_strmediumtype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BusinessInfo::clear_strmediumtype() {
  if (strmediumtype_ != &::google::protobuf::internal::kEmptyString) {
    strmediumtype_->clear();
  }
  clear_has_strmediumtype();
}
inline const ::std::string& BusinessInfo::strmediumtype() const {
  return *strmediumtype_;
}
inline void BusinessInfo::set_strmediumtype(const ::std::string& value) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(value);
}
inline void BusinessInfo::set_strmediumtype(const char* value) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(value);
}
inline void BusinessInfo::set_strmediumtype(const char* value, size_t size) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strmediumtype() {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  return strmediumtype_;
}
inline ::std::string* BusinessInfo::release_strmediumtype() {
  clear_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmediumtype_;
    strmediumtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strmediumtype(::std::string* strmediumtype) {
  if (strmediumtype_ != &::google::protobuf::internal::kEmptyString) {
    delete strmediumtype_;
  }
  if (strmediumtype) {
    set_has_strmediumtype();
    strmediumtype_ = strmediumtype;
  } else {
    clear_has_strmediumtype();
    strmediumtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMediumNum = 20;
inline bool BusinessInfo::has_strmediumnum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BusinessInfo::set_has_strmediumnum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BusinessInfo::clear_has_strmediumnum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BusinessInfo::clear_strmediumnum() {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    strmediumnum_->clear();
  }
  clear_has_strmediumnum();
}
inline const ::std::string& BusinessInfo::strmediumnum() const {
  return *strmediumnum_;
}
inline void BusinessInfo::set_strmediumnum(const ::std::string& value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessInfo::set_strmediumnum(const char* value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessInfo::set_strmediumnum(const char* value, size_t size) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_strmediumnum() {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  return strmediumnum_;
}
inline ::std::string* BusinessInfo::release_strmediumnum() {
  clear_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmediumnum_;
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_strmediumnum(::std::string* strmediumnum) {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strmediumnum_;
  }
  if (strmediumnum) {
    set_has_strmediumnum();
    strmediumnum_ = strmediumnum;
  } else {
    clear_has_strmediumnum();
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strOffDisputeTime = 21;
inline bool BusinessInfo::has_stroffdisputetime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BusinessInfo::set_has_stroffdisputetime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BusinessInfo::clear_has_stroffdisputetime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BusinessInfo::clear_stroffdisputetime() {
  if (stroffdisputetime_ != &::google::protobuf::internal::kEmptyString) {
    stroffdisputetime_->clear();
  }
  clear_has_stroffdisputetime();
}
inline const ::std::string& BusinessInfo::stroffdisputetime() const {
  return *stroffdisputetime_;
}
inline void BusinessInfo::set_stroffdisputetime(const ::std::string& value) {
  set_has_stroffdisputetime();
  if (stroffdisputetime_ == &::google::protobuf::internal::kEmptyString) {
    stroffdisputetime_ = new ::std::string;
  }
  stroffdisputetime_->assign(value);
}
inline void BusinessInfo::set_stroffdisputetime(const char* value) {
  set_has_stroffdisputetime();
  if (stroffdisputetime_ == &::google::protobuf::internal::kEmptyString) {
    stroffdisputetime_ = new ::std::string;
  }
  stroffdisputetime_->assign(value);
}
inline void BusinessInfo::set_stroffdisputetime(const char* value, size_t size) {
  set_has_stroffdisputetime();
  if (stroffdisputetime_ == &::google::protobuf::internal::kEmptyString) {
    stroffdisputetime_ = new ::std::string;
  }
  stroffdisputetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessInfo::mutable_stroffdisputetime() {
  set_has_stroffdisputetime();
  if (stroffdisputetime_ == &::google::protobuf::internal::kEmptyString) {
    stroffdisputetime_ = new ::std::string;
  }
  return stroffdisputetime_;
}
inline ::std::string* BusinessInfo::release_stroffdisputetime() {
  clear_has_stroffdisputetime();
  if (stroffdisputetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroffdisputetime_;
    stroffdisputetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessInfo::set_allocated_stroffdisputetime(::std::string* stroffdisputetime) {
  if (stroffdisputetime_ != &::google::protobuf::internal::kEmptyString) {
    delete stroffdisputetime_;
  }
  if (stroffdisputetime) {
    set_has_stroffdisputetime();
    stroffdisputetime_ = stroffdisputetime;
  } else {
    clear_has_stroffdisputetime();
    stroffdisputetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProduceInfo

// required string strProduceId = 1;
inline bool ProduceInfo::has_strproduceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProduceInfo::set_has_strproduceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProduceInfo::clear_has_strproduceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProduceInfo::clear_strproduceid() {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    strproduceid_->clear();
  }
  clear_has_strproduceid();
}
inline const ::std::string& ProduceInfo::strproduceid() const {
  return *strproduceid_;
}
inline void ProduceInfo::set_strproduceid(const ::std::string& value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void ProduceInfo::set_strproduceid(const char* value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void ProduceInfo::set_strproduceid(const char* value, size_t size) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strproduceid() {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  return strproduceid_;
}
inline ::std::string* ProduceInfo::release_strproduceid() {
  clear_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproduceid_;
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strproduceid(::std::string* strproduceid) {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    delete strproduceid_;
  }
  if (strproduceid) {
    set_has_strproduceid();
    strproduceid_ = strproduceid;
  } else {
    clear_has_strproduceid();
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strName = 2;
inline bool ProduceInfo::has_strname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProduceInfo::set_has_strname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProduceInfo::clear_has_strname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProduceInfo::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& ProduceInfo::strname() const {
  return *strname_;
}
inline void ProduceInfo::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ProduceInfo::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ProduceInfo::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* ProduceInfo::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strname(::std::string* strname) {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    delete strname_;
  }
  if (strname) {
    set_has_strname();
    strname_ = strname;
  } else {
    clear_has_strname();
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceCode = 3;
inline bool ProduceInfo::has_strproducecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProduceInfo::set_has_strproducecode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProduceInfo::clear_has_strproducecode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProduceInfo::clear_strproducecode() {
  if (strproducecode_ != &::google::protobuf::internal::kEmptyString) {
    strproducecode_->clear();
  }
  clear_has_strproducecode();
}
inline const ::std::string& ProduceInfo::strproducecode() const {
  return *strproducecode_;
}
inline void ProduceInfo::set_strproducecode(const ::std::string& value) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(value);
}
inline void ProduceInfo::set_strproducecode(const char* value) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(value);
}
inline void ProduceInfo::set_strproducecode(const char* value, size_t size) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strproducecode() {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  return strproducecode_;
}
inline ::std::string* ProduceInfo::release_strproducecode() {
  clear_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproducecode_;
    strproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strproducecode(::std::string* strproducecode) {
  if (strproducecode_ != &::google::protobuf::internal::kEmptyString) {
    delete strproducecode_;
  }
  if (strproducecode) {
    set_has_strproducecode();
    strproducecode_ = strproducecode;
  } else {
    clear_has_strproducecode();
    strproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPeriod = 4;
inline bool ProduceInfo::has_nperiod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProduceInfo::set_has_nperiod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProduceInfo::clear_has_nperiod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProduceInfo::clear_nperiod() {
  nperiod_ = 0;
  clear_has_nperiod();
}
inline ::google::protobuf::int32 ProduceInfo::nperiod() const {
  return nperiod_;
}
inline void ProduceInfo::set_nperiod(::google::protobuf::int32 value) {
  set_has_nperiod();
  nperiod_ = value;
}

// required string strRevenue = 5;
inline bool ProduceInfo::has_strrevenue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProduceInfo::set_has_strrevenue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProduceInfo::clear_has_strrevenue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProduceInfo::clear_strrevenue() {
  if (strrevenue_ != &::google::protobuf::internal::kEmptyString) {
    strrevenue_->clear();
  }
  clear_has_strrevenue();
}
inline const ::std::string& ProduceInfo::strrevenue() const {
  return *strrevenue_;
}
inline void ProduceInfo::set_strrevenue(const ::std::string& value) {
  set_has_strrevenue();
  if (strrevenue_ == &::google::protobuf::internal::kEmptyString) {
    strrevenue_ = new ::std::string;
  }
  strrevenue_->assign(value);
}
inline void ProduceInfo::set_strrevenue(const char* value) {
  set_has_strrevenue();
  if (strrevenue_ == &::google::protobuf::internal::kEmptyString) {
    strrevenue_ = new ::std::string;
  }
  strrevenue_->assign(value);
}
inline void ProduceInfo::set_strrevenue(const char* value, size_t size) {
  set_has_strrevenue();
  if (strrevenue_ == &::google::protobuf::internal::kEmptyString) {
    strrevenue_ = new ::std::string;
  }
  strrevenue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strrevenue() {
  set_has_strrevenue();
  if (strrevenue_ == &::google::protobuf::internal::kEmptyString) {
    strrevenue_ = new ::std::string;
  }
  return strrevenue_;
}
inline ::std::string* ProduceInfo::release_strrevenue() {
  clear_has_strrevenue();
  if (strrevenue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrevenue_;
    strrevenue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strrevenue(::std::string* strrevenue) {
  if (strrevenue_ != &::google::protobuf::internal::kEmptyString) {
    delete strrevenue_;
  }
  if (strrevenue) {
    set_has_strrevenue();
    strrevenue_ = strrevenue;
  } else {
    clear_has_strrevenue();
    strrevenue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMiniAmount = 6;
inline bool ProduceInfo::has_nminiamount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProduceInfo::set_has_nminiamount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProduceInfo::clear_has_nminiamount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProduceInfo::clear_nminiamount() {
  nminiamount_ = 0;
  clear_has_nminiamount();
}
inline ::google::protobuf::int32 ProduceInfo::nminiamount() const {
  return nminiamount_;
}
inline void ProduceInfo::set_nminiamount(::google::protobuf::int32 value) {
  set_has_nminiamount();
  nminiamount_ = value;
}

// required string strRiskLevel = 7;
inline bool ProduceInfo::has_strrisklevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProduceInfo::set_has_strrisklevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProduceInfo::clear_has_strrisklevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProduceInfo::clear_strrisklevel() {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strrisklevel_->clear();
  }
  clear_has_strrisklevel();
}
inline const ::std::string& ProduceInfo::strrisklevel() const {
  return *strrisklevel_;
}
inline void ProduceInfo::set_strrisklevel(const ::std::string& value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void ProduceInfo::set_strrisklevel(const char* value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void ProduceInfo::set_strrisklevel(const char* value, size_t size) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strrisklevel() {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  return strrisklevel_;
}
inline ::std::string* ProduceInfo::release_strrisklevel() {
  clear_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrisklevel_;
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strrisklevel(::std::string* strrisklevel) {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    delete strrisklevel_;
  }
  if (strrisklevel) {
    set_has_strrisklevel();
    strrisklevel_ = strrisklevel;
  } else {
    clear_has_strrisklevel();
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSerialNumber = 8;
inline bool ProduceInfo::has_strserialnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProduceInfo::set_has_strserialnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProduceInfo::clear_has_strserialnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProduceInfo::clear_strserialnumber() {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    strserialnumber_->clear();
  }
  clear_has_strserialnumber();
}
inline const ::std::string& ProduceInfo::strserialnumber() const {
  return *strserialnumber_;
}
inline void ProduceInfo::set_strserialnumber(const ::std::string& value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void ProduceInfo::set_strserialnumber(const char* value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void ProduceInfo::set_strserialnumber(const char* value, size_t size) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strserialnumber() {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  return strserialnumber_;
}
inline ::std::string* ProduceInfo::release_strserialnumber() {
  clear_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strserialnumber_;
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strserialnumber(::std::string* strserialnumber) {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete strserialnumber_;
  }
  if (strserialnumber) {
    set_has_strserialnumber();
    strserialnumber_ = strserialnumber;
  } else {
    clear_has_strserialnumber();
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPublishBeinTime = 9;
inline bool ProduceInfo::has_strpublishbeintime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProduceInfo::set_has_strpublishbeintime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProduceInfo::clear_has_strpublishbeintime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProduceInfo::clear_strpublishbeintime() {
  if (strpublishbeintime_ != &::google::protobuf::internal::kEmptyString) {
    strpublishbeintime_->clear();
  }
  clear_has_strpublishbeintime();
}
inline const ::std::string& ProduceInfo::strpublishbeintime() const {
  return *strpublishbeintime_;
}
inline void ProduceInfo::set_strpublishbeintime(const ::std::string& value) {
  set_has_strpublishbeintime();
  if (strpublishbeintime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishbeintime_ = new ::std::string;
  }
  strpublishbeintime_->assign(value);
}
inline void ProduceInfo::set_strpublishbeintime(const char* value) {
  set_has_strpublishbeintime();
  if (strpublishbeintime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishbeintime_ = new ::std::string;
  }
  strpublishbeintime_->assign(value);
}
inline void ProduceInfo::set_strpublishbeintime(const char* value, size_t size) {
  set_has_strpublishbeintime();
  if (strpublishbeintime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishbeintime_ = new ::std::string;
  }
  strpublishbeintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strpublishbeintime() {
  set_has_strpublishbeintime();
  if (strpublishbeintime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishbeintime_ = new ::std::string;
  }
  return strpublishbeintime_;
}
inline ::std::string* ProduceInfo::release_strpublishbeintime() {
  clear_has_strpublishbeintime();
  if (strpublishbeintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpublishbeintime_;
    strpublishbeintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strpublishbeintime(::std::string* strpublishbeintime) {
  if (strpublishbeintime_ != &::google::protobuf::internal::kEmptyString) {
    delete strpublishbeintime_;
  }
  if (strpublishbeintime) {
    set_has_strpublishbeintime();
    strpublishbeintime_ = strpublishbeintime;
  } else {
    clear_has_strpublishbeintime();
    strpublishbeintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPublishEndTime = 10;
inline bool ProduceInfo::has_strpublishendtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProduceInfo::set_has_strpublishendtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProduceInfo::clear_has_strpublishendtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProduceInfo::clear_strpublishendtime() {
  if (strpublishendtime_ != &::google::protobuf::internal::kEmptyString) {
    strpublishendtime_->clear();
  }
  clear_has_strpublishendtime();
}
inline const ::std::string& ProduceInfo::strpublishendtime() const {
  return *strpublishendtime_;
}
inline void ProduceInfo::set_strpublishendtime(const ::std::string& value) {
  set_has_strpublishendtime();
  if (strpublishendtime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishendtime_ = new ::std::string;
  }
  strpublishendtime_->assign(value);
}
inline void ProduceInfo::set_strpublishendtime(const char* value) {
  set_has_strpublishendtime();
  if (strpublishendtime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishendtime_ = new ::std::string;
  }
  strpublishendtime_->assign(value);
}
inline void ProduceInfo::set_strpublishendtime(const char* value, size_t size) {
  set_has_strpublishendtime();
  if (strpublishendtime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishendtime_ = new ::std::string;
  }
  strpublishendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strpublishendtime() {
  set_has_strpublishendtime();
  if (strpublishendtime_ == &::google::protobuf::internal::kEmptyString) {
    strpublishendtime_ = new ::std::string;
  }
  return strpublishendtime_;
}
inline ::std::string* ProduceInfo::release_strpublishendtime() {
  clear_has_strpublishendtime();
  if (strpublishendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpublishendtime_;
    strpublishendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strpublishendtime(::std::string* strpublishendtime) {
  if (strpublishendtime_ != &::google::protobuf::internal::kEmptyString) {
    delete strpublishendtime_;
  }
  if (strpublishendtime) {
    set_has_strpublishendtime();
    strpublishendtime_ = strpublishendtime;
  } else {
    clear_has_strpublishendtime();
    strpublishendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProductionType = 11;
inline bool ProduceInfo::has_strproductiontype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProduceInfo::set_has_strproductiontype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProduceInfo::clear_has_strproductiontype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProduceInfo::clear_strproductiontype() {
  if (strproductiontype_ != &::google::protobuf::internal::kEmptyString) {
    strproductiontype_->clear();
  }
  clear_has_strproductiontype();
}
inline const ::std::string& ProduceInfo::strproductiontype() const {
  return *strproductiontype_;
}
inline void ProduceInfo::set_strproductiontype(const ::std::string& value) {
  set_has_strproductiontype();
  if (strproductiontype_ == &::google::protobuf::internal::kEmptyString) {
    strproductiontype_ = new ::std::string;
  }
  strproductiontype_->assign(value);
}
inline void ProduceInfo::set_strproductiontype(const char* value) {
  set_has_strproductiontype();
  if (strproductiontype_ == &::google::protobuf::internal::kEmptyString) {
    strproductiontype_ = new ::std::string;
  }
  strproductiontype_->assign(value);
}
inline void ProduceInfo::set_strproductiontype(const char* value, size_t size) {
  set_has_strproductiontype();
  if (strproductiontype_ == &::google::protobuf::internal::kEmptyString) {
    strproductiontype_ = new ::std::string;
  }
  strproductiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strproductiontype() {
  set_has_strproductiontype();
  if (strproductiontype_ == &::google::protobuf::internal::kEmptyString) {
    strproductiontype_ = new ::std::string;
  }
  return strproductiontype_;
}
inline ::std::string* ProduceInfo::release_strproductiontype() {
  clear_has_strproductiontype();
  if (strproductiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproductiontype_;
    strproductiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strproductiontype(::std::string* strproductiontype) {
  if (strproductiontype_ != &::google::protobuf::internal::kEmptyString) {
    delete strproductiontype_;
  }
  if (strproductiontype) {
    set_has_strproductiontype();
    strproductiontype_ = strproductiontype;
  } else {
    clear_has_strproductiontype();
    strproductiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strApplicableCustomer = 12;
inline bool ProduceInfo::has_strapplicablecustomer() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProduceInfo::set_has_strapplicablecustomer() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProduceInfo::clear_has_strapplicablecustomer() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProduceInfo::clear_strapplicablecustomer() {
  if (strapplicablecustomer_ != &::google::protobuf::internal::kEmptyString) {
    strapplicablecustomer_->clear();
  }
  clear_has_strapplicablecustomer();
}
inline const ::std::string& ProduceInfo::strapplicablecustomer() const {
  return *strapplicablecustomer_;
}
inline void ProduceInfo::set_strapplicablecustomer(const ::std::string& value) {
  set_has_strapplicablecustomer();
  if (strapplicablecustomer_ == &::google::protobuf::internal::kEmptyString) {
    strapplicablecustomer_ = new ::std::string;
  }
  strapplicablecustomer_->assign(value);
}
inline void ProduceInfo::set_strapplicablecustomer(const char* value) {
  set_has_strapplicablecustomer();
  if (strapplicablecustomer_ == &::google::protobuf::internal::kEmptyString) {
    strapplicablecustomer_ = new ::std::string;
  }
  strapplicablecustomer_->assign(value);
}
inline void ProduceInfo::set_strapplicablecustomer(const char* value, size_t size) {
  set_has_strapplicablecustomer();
  if (strapplicablecustomer_ == &::google::protobuf::internal::kEmptyString) {
    strapplicablecustomer_ = new ::std::string;
  }
  strapplicablecustomer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strapplicablecustomer() {
  set_has_strapplicablecustomer();
  if (strapplicablecustomer_ == &::google::protobuf::internal::kEmptyString) {
    strapplicablecustomer_ = new ::std::string;
  }
  return strapplicablecustomer_;
}
inline ::std::string* ProduceInfo::release_strapplicablecustomer() {
  clear_has_strapplicablecustomer();
  if (strapplicablecustomer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strapplicablecustomer_;
    strapplicablecustomer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strapplicablecustomer(::std::string* strapplicablecustomer) {
  if (strapplicablecustomer_ != &::google::protobuf::internal::kEmptyString) {
    delete strapplicablecustomer_;
  }
  if (strapplicablecustomer) {
    set_has_strapplicablecustomer();
    strapplicablecustomer_ = strapplicablecustomer;
  } else {
    clear_has_strapplicablecustomer();
    strapplicablecustomer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRevenueType = 13;
inline bool ProduceInfo::has_strrevenuetype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProduceInfo::set_has_strrevenuetype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProduceInfo::clear_has_strrevenuetype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProduceInfo::clear_strrevenuetype() {
  if (strrevenuetype_ != &::google::protobuf::internal::kEmptyString) {
    strrevenuetype_->clear();
  }
  clear_has_strrevenuetype();
}
inline const ::std::string& ProduceInfo::strrevenuetype() const {
  return *strrevenuetype_;
}
inline void ProduceInfo::set_strrevenuetype(const ::std::string& value) {
  set_has_strrevenuetype();
  if (strrevenuetype_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuetype_ = new ::std::string;
  }
  strrevenuetype_->assign(value);
}
inline void ProduceInfo::set_strrevenuetype(const char* value) {
  set_has_strrevenuetype();
  if (strrevenuetype_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuetype_ = new ::std::string;
  }
  strrevenuetype_->assign(value);
}
inline void ProduceInfo::set_strrevenuetype(const char* value, size_t size) {
  set_has_strrevenuetype();
  if (strrevenuetype_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuetype_ = new ::std::string;
  }
  strrevenuetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strrevenuetype() {
  set_has_strrevenuetype();
  if (strrevenuetype_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuetype_ = new ::std::string;
  }
  return strrevenuetype_;
}
inline ::std::string* ProduceInfo::release_strrevenuetype() {
  clear_has_strrevenuetype();
  if (strrevenuetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrevenuetype_;
    strrevenuetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strrevenuetype(::std::string* strrevenuetype) {
  if (strrevenuetype_ != &::google::protobuf::internal::kEmptyString) {
    delete strrevenuetype_;
  }
  if (strrevenuetype) {
    set_has_strrevenuetype();
    strrevenuetype_ = strrevenuetype;
  } else {
    clear_has_strrevenuetype();
    strrevenuetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strIncrementMoney = 14;
inline bool ProduceInfo::has_strincrementmoney() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProduceInfo::set_has_strincrementmoney() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProduceInfo::clear_has_strincrementmoney() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProduceInfo::clear_strincrementmoney() {
  if (strincrementmoney_ != &::google::protobuf::internal::kEmptyString) {
    strincrementmoney_->clear();
  }
  clear_has_strincrementmoney();
}
inline const ::std::string& ProduceInfo::strincrementmoney() const {
  return *strincrementmoney_;
}
inline void ProduceInfo::set_strincrementmoney(const ::std::string& value) {
  set_has_strincrementmoney();
  if (strincrementmoney_ == &::google::protobuf::internal::kEmptyString) {
    strincrementmoney_ = new ::std::string;
  }
  strincrementmoney_->assign(value);
}
inline void ProduceInfo::set_strincrementmoney(const char* value) {
  set_has_strincrementmoney();
  if (strincrementmoney_ == &::google::protobuf::internal::kEmptyString) {
    strincrementmoney_ = new ::std::string;
  }
  strincrementmoney_->assign(value);
}
inline void ProduceInfo::set_strincrementmoney(const char* value, size_t size) {
  set_has_strincrementmoney();
  if (strincrementmoney_ == &::google::protobuf::internal::kEmptyString) {
    strincrementmoney_ = new ::std::string;
  }
  strincrementmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strincrementmoney() {
  set_has_strincrementmoney();
  if (strincrementmoney_ == &::google::protobuf::internal::kEmptyString) {
    strincrementmoney_ = new ::std::string;
  }
  return strincrementmoney_;
}
inline ::std::string* ProduceInfo::release_strincrementmoney() {
  clear_has_strincrementmoney();
  if (strincrementmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strincrementmoney_;
    strincrementmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strincrementmoney(::std::string* strincrementmoney) {
  if (strincrementmoney_ != &::google::protobuf::internal::kEmptyString) {
    delete strincrementmoney_;
  }
  if (strincrementmoney) {
    set_has_strincrementmoney();
    strincrementmoney_ = strincrementmoney;
  } else {
    clear_has_strincrementmoney();
    strincrementmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCurrentyType = 15;
inline bool ProduceInfo::has_strcurrentytype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProduceInfo::set_has_strcurrentytype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProduceInfo::clear_has_strcurrentytype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProduceInfo::clear_strcurrentytype() {
  if (strcurrentytype_ != &::google::protobuf::internal::kEmptyString) {
    strcurrentytype_->clear();
  }
  clear_has_strcurrentytype();
}
inline const ::std::string& ProduceInfo::strcurrentytype() const {
  return *strcurrentytype_;
}
inline void ProduceInfo::set_strcurrentytype(const ::std::string& value) {
  set_has_strcurrentytype();
  if (strcurrentytype_ == &::google::protobuf::internal::kEmptyString) {
    strcurrentytype_ = new ::std::string;
  }
  strcurrentytype_->assign(value);
}
inline void ProduceInfo::set_strcurrentytype(const char* value) {
  set_has_strcurrentytype();
  if (strcurrentytype_ == &::google::protobuf::internal::kEmptyString) {
    strcurrentytype_ = new ::std::string;
  }
  strcurrentytype_->assign(value);
}
inline void ProduceInfo::set_strcurrentytype(const char* value, size_t size) {
  set_has_strcurrentytype();
  if (strcurrentytype_ == &::google::protobuf::internal::kEmptyString) {
    strcurrentytype_ = new ::std::string;
  }
  strcurrentytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strcurrentytype() {
  set_has_strcurrentytype();
  if (strcurrentytype_ == &::google::protobuf::internal::kEmptyString) {
    strcurrentytype_ = new ::std::string;
  }
  return strcurrentytype_;
}
inline ::std::string* ProduceInfo::release_strcurrentytype() {
  clear_has_strcurrentytype();
  if (strcurrentytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcurrentytype_;
    strcurrentytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strcurrentytype(::std::string* strcurrentytype) {
  if (strcurrentytype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcurrentytype_;
  }
  if (strcurrentytype) {
    set_has_strcurrentytype();
    strcurrentytype_ = strcurrentytype;
  } else {
    clear_has_strcurrentytype();
    strcurrentytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSealsBranch = 16;
inline bool ProduceInfo::has_strsealsbranch() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProduceInfo::set_has_strsealsbranch() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProduceInfo::clear_has_strsealsbranch() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProduceInfo::clear_strsealsbranch() {
  if (strsealsbranch_ != &::google::protobuf::internal::kEmptyString) {
    strsealsbranch_->clear();
  }
  clear_has_strsealsbranch();
}
inline const ::std::string& ProduceInfo::strsealsbranch() const {
  return *strsealsbranch_;
}
inline void ProduceInfo::set_strsealsbranch(const ::std::string& value) {
  set_has_strsealsbranch();
  if (strsealsbranch_ == &::google::protobuf::internal::kEmptyString) {
    strsealsbranch_ = new ::std::string;
  }
  strsealsbranch_->assign(value);
}
inline void ProduceInfo::set_strsealsbranch(const char* value) {
  set_has_strsealsbranch();
  if (strsealsbranch_ == &::google::protobuf::internal::kEmptyString) {
    strsealsbranch_ = new ::std::string;
  }
  strsealsbranch_->assign(value);
}
inline void ProduceInfo::set_strsealsbranch(const char* value, size_t size) {
  set_has_strsealsbranch();
  if (strsealsbranch_ == &::google::protobuf::internal::kEmptyString) {
    strsealsbranch_ = new ::std::string;
  }
  strsealsbranch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strsealsbranch() {
  set_has_strsealsbranch();
  if (strsealsbranch_ == &::google::protobuf::internal::kEmptyString) {
    strsealsbranch_ = new ::std::string;
  }
  return strsealsbranch_;
}
inline ::std::string* ProduceInfo::release_strsealsbranch() {
  clear_has_strsealsbranch();
  if (strsealsbranch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsealsbranch_;
    strsealsbranch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strsealsbranch(::std::string* strsealsbranch) {
  if (strsealsbranch_ != &::google::protobuf::internal::kEmptyString) {
    delete strsealsbranch_;
  }
  if (strsealsbranch) {
    set_has_strsealsbranch();
    strsealsbranch_ = strsealsbranch;
  } else {
    clear_has_strsealsbranch();
    strsealsbranch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRevenueInitialDay = 17;
inline bool ProduceInfo::has_strrevenueinitialday() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProduceInfo::set_has_strrevenueinitialday() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProduceInfo::clear_has_strrevenueinitialday() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProduceInfo::clear_strrevenueinitialday() {
  if (strrevenueinitialday_ != &::google::protobuf::internal::kEmptyString) {
    strrevenueinitialday_->clear();
  }
  clear_has_strrevenueinitialday();
}
inline const ::std::string& ProduceInfo::strrevenueinitialday() const {
  return *strrevenueinitialday_;
}
inline void ProduceInfo::set_strrevenueinitialday(const ::std::string& value) {
  set_has_strrevenueinitialday();
  if (strrevenueinitialday_ == &::google::protobuf::internal::kEmptyString) {
    strrevenueinitialday_ = new ::std::string;
  }
  strrevenueinitialday_->assign(value);
}
inline void ProduceInfo::set_strrevenueinitialday(const char* value) {
  set_has_strrevenueinitialday();
  if (strrevenueinitialday_ == &::google::protobuf::internal::kEmptyString) {
    strrevenueinitialday_ = new ::std::string;
  }
  strrevenueinitialday_->assign(value);
}
inline void ProduceInfo::set_strrevenueinitialday(const char* value, size_t size) {
  set_has_strrevenueinitialday();
  if (strrevenueinitialday_ == &::google::protobuf::internal::kEmptyString) {
    strrevenueinitialday_ = new ::std::string;
  }
  strrevenueinitialday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strrevenueinitialday() {
  set_has_strrevenueinitialday();
  if (strrevenueinitialday_ == &::google::protobuf::internal::kEmptyString) {
    strrevenueinitialday_ = new ::std::string;
  }
  return strrevenueinitialday_;
}
inline ::std::string* ProduceInfo::release_strrevenueinitialday() {
  clear_has_strrevenueinitialday();
  if (strrevenueinitialday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrevenueinitialday_;
    strrevenueinitialday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strrevenueinitialday(::std::string* strrevenueinitialday) {
  if (strrevenueinitialday_ != &::google::protobuf::internal::kEmptyString) {
    delete strrevenueinitialday_;
  }
  if (strrevenueinitialday) {
    set_has_strrevenueinitialday();
    strrevenueinitialday_ = strrevenueinitialday;
  } else {
    clear_has_strrevenueinitialday();
    strrevenueinitialday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strDeadLine = 18;
inline bool ProduceInfo::has_strdeadline() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProduceInfo::set_has_strdeadline() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProduceInfo::clear_has_strdeadline() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProduceInfo::clear_strdeadline() {
  if (strdeadline_ != &::google::protobuf::internal::kEmptyString) {
    strdeadline_->clear();
  }
  clear_has_strdeadline();
}
inline const ::std::string& ProduceInfo::strdeadline() const {
  return *strdeadline_;
}
inline void ProduceInfo::set_strdeadline(const ::std::string& value) {
  set_has_strdeadline();
  if (strdeadline_ == &::google::protobuf::internal::kEmptyString) {
    strdeadline_ = new ::std::string;
  }
  strdeadline_->assign(value);
}
inline void ProduceInfo::set_strdeadline(const char* value) {
  set_has_strdeadline();
  if (strdeadline_ == &::google::protobuf::internal::kEmptyString) {
    strdeadline_ = new ::std::string;
  }
  strdeadline_->assign(value);
}
inline void ProduceInfo::set_strdeadline(const char* value, size_t size) {
  set_has_strdeadline();
  if (strdeadline_ == &::google::protobuf::internal::kEmptyString) {
    strdeadline_ = new ::std::string;
  }
  strdeadline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strdeadline() {
  set_has_strdeadline();
  if (strdeadline_ == &::google::protobuf::internal::kEmptyString) {
    strdeadline_ = new ::std::string;
  }
  return strdeadline_;
}
inline ::std::string* ProduceInfo::release_strdeadline() {
  clear_has_strdeadline();
  if (strdeadline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdeadline_;
    strdeadline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strdeadline(::std::string* strdeadline) {
  if (strdeadline_ != &::google::protobuf::internal::kEmptyString) {
    delete strdeadline_;
  }
  if (strdeadline) {
    set_has_strdeadline();
    strdeadline_ = strdeadline;
  } else {
    clear_has_strdeadline();
    strdeadline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPaymentDay = 19;
inline bool ProduceInfo::has_strpaymentday() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ProduceInfo::set_has_strpaymentday() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ProduceInfo::clear_has_strpaymentday() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ProduceInfo::clear_strpaymentday() {
  if (strpaymentday_ != &::google::protobuf::internal::kEmptyString) {
    strpaymentday_->clear();
  }
  clear_has_strpaymentday();
}
inline const ::std::string& ProduceInfo::strpaymentday() const {
  return *strpaymentday_;
}
inline void ProduceInfo::set_strpaymentday(const ::std::string& value) {
  set_has_strpaymentday();
  if (strpaymentday_ == &::google::protobuf::internal::kEmptyString) {
    strpaymentday_ = new ::std::string;
  }
  strpaymentday_->assign(value);
}
inline void ProduceInfo::set_strpaymentday(const char* value) {
  set_has_strpaymentday();
  if (strpaymentday_ == &::google::protobuf::internal::kEmptyString) {
    strpaymentday_ = new ::std::string;
  }
  strpaymentday_->assign(value);
}
inline void ProduceInfo::set_strpaymentday(const char* value, size_t size) {
  set_has_strpaymentday();
  if (strpaymentday_ == &::google::protobuf::internal::kEmptyString) {
    strpaymentday_ = new ::std::string;
  }
  strpaymentday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strpaymentday() {
  set_has_strpaymentday();
  if (strpaymentday_ == &::google::protobuf::internal::kEmptyString) {
    strpaymentday_ = new ::std::string;
  }
  return strpaymentday_;
}
inline ::std::string* ProduceInfo::release_strpaymentday() {
  clear_has_strpaymentday();
  if (strpaymentday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpaymentday_;
    strpaymentday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strpaymentday(::std::string* strpaymentday) {
  if (strpaymentday_ != &::google::protobuf::internal::kEmptyString) {
    delete strpaymentday_;
  }
  if (strpaymentday) {
    set_has_strpaymentday();
    strpaymentday_ = strpaymentday;
  } else {
    clear_has_strpaymentday();
    strpaymentday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTrusteeFee = 20;
inline bool ProduceInfo::has_strtrusteefee() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ProduceInfo::set_has_strtrusteefee() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ProduceInfo::clear_has_strtrusteefee() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ProduceInfo::clear_strtrusteefee() {
  if (strtrusteefee_ != &::google::protobuf::internal::kEmptyString) {
    strtrusteefee_->clear();
  }
  clear_has_strtrusteefee();
}
inline const ::std::string& ProduceInfo::strtrusteefee() const {
  return *strtrusteefee_;
}
inline void ProduceInfo::set_strtrusteefee(const ::std::string& value) {
  set_has_strtrusteefee();
  if (strtrusteefee_ == &::google::protobuf::internal::kEmptyString) {
    strtrusteefee_ = new ::std::string;
  }
  strtrusteefee_->assign(value);
}
inline void ProduceInfo::set_strtrusteefee(const char* value) {
  set_has_strtrusteefee();
  if (strtrusteefee_ == &::google::protobuf::internal::kEmptyString) {
    strtrusteefee_ = new ::std::string;
  }
  strtrusteefee_->assign(value);
}
inline void ProduceInfo::set_strtrusteefee(const char* value, size_t size) {
  set_has_strtrusteefee();
  if (strtrusteefee_ == &::google::protobuf::internal::kEmptyString) {
    strtrusteefee_ = new ::std::string;
  }
  strtrusteefee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strtrusteefee() {
  set_has_strtrusteefee();
  if (strtrusteefee_ == &::google::protobuf::internal::kEmptyString) {
    strtrusteefee_ = new ::std::string;
  }
  return strtrusteefee_;
}
inline ::std::string* ProduceInfo::release_strtrusteefee() {
  clear_has_strtrusteefee();
  if (strtrusteefee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtrusteefee_;
    strtrusteefee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strtrusteefee(::std::string* strtrusteefee) {
  if (strtrusteefee_ != &::google::protobuf::internal::kEmptyString) {
    delete strtrusteefee_;
  }
  if (strtrusteefee) {
    set_has_strtrusteefee();
    strtrusteefee_ = strtrusteefee;
  } else {
    clear_has_strtrusteefee();
    strtrusteefee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCommissionCharge = 21;
inline bool ProduceInfo::has_strcommissioncharge() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ProduceInfo::set_has_strcommissioncharge() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ProduceInfo::clear_has_strcommissioncharge() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ProduceInfo::clear_strcommissioncharge() {
  if (strcommissioncharge_ != &::google::protobuf::internal::kEmptyString) {
    strcommissioncharge_->clear();
  }
  clear_has_strcommissioncharge();
}
inline const ::std::string& ProduceInfo::strcommissioncharge() const {
  return *strcommissioncharge_;
}
inline void ProduceInfo::set_strcommissioncharge(const ::std::string& value) {
  set_has_strcommissioncharge();
  if (strcommissioncharge_ == &::google::protobuf::internal::kEmptyString) {
    strcommissioncharge_ = new ::std::string;
  }
  strcommissioncharge_->assign(value);
}
inline void ProduceInfo::set_strcommissioncharge(const char* value) {
  set_has_strcommissioncharge();
  if (strcommissioncharge_ == &::google::protobuf::internal::kEmptyString) {
    strcommissioncharge_ = new ::std::string;
  }
  strcommissioncharge_->assign(value);
}
inline void ProduceInfo::set_strcommissioncharge(const char* value, size_t size) {
  set_has_strcommissioncharge();
  if (strcommissioncharge_ == &::google::protobuf::internal::kEmptyString) {
    strcommissioncharge_ = new ::std::string;
  }
  strcommissioncharge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strcommissioncharge() {
  set_has_strcommissioncharge();
  if (strcommissioncharge_ == &::google::protobuf::internal::kEmptyString) {
    strcommissioncharge_ = new ::std::string;
  }
  return strcommissioncharge_;
}
inline ::std::string* ProduceInfo::release_strcommissioncharge() {
  clear_has_strcommissioncharge();
  if (strcommissioncharge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcommissioncharge_;
    strcommissioncharge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strcommissioncharge(::std::string* strcommissioncharge) {
  if (strcommissioncharge_ != &::google::protobuf::internal::kEmptyString) {
    delete strcommissioncharge_;
  }
  if (strcommissioncharge) {
    set_has_strcommissioncharge();
    strcommissioncharge_ = strcommissioncharge;
  } else {
    clear_has_strcommissioncharge();
    strcommissioncharge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTrustee = 22;
inline bool ProduceInfo::has_strtrustee() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ProduceInfo::set_has_strtrustee() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ProduceInfo::clear_has_strtrustee() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ProduceInfo::clear_strtrustee() {
  if (strtrustee_ != &::google::protobuf::internal::kEmptyString) {
    strtrustee_->clear();
  }
  clear_has_strtrustee();
}
inline const ::std::string& ProduceInfo::strtrustee() const {
  return *strtrustee_;
}
inline void ProduceInfo::set_strtrustee(const ::std::string& value) {
  set_has_strtrustee();
  if (strtrustee_ == &::google::protobuf::internal::kEmptyString) {
    strtrustee_ = new ::std::string;
  }
  strtrustee_->assign(value);
}
inline void ProduceInfo::set_strtrustee(const char* value) {
  set_has_strtrustee();
  if (strtrustee_ == &::google::protobuf::internal::kEmptyString) {
    strtrustee_ = new ::std::string;
  }
  strtrustee_->assign(value);
}
inline void ProduceInfo::set_strtrustee(const char* value, size_t size) {
  set_has_strtrustee();
  if (strtrustee_ == &::google::protobuf::internal::kEmptyString) {
    strtrustee_ = new ::std::string;
  }
  strtrustee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strtrustee() {
  set_has_strtrustee();
  if (strtrustee_ == &::google::protobuf::internal::kEmptyString) {
    strtrustee_ = new ::std::string;
  }
  return strtrustee_;
}
inline ::std::string* ProduceInfo::release_strtrustee() {
  clear_has_strtrustee();
  if (strtrustee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtrustee_;
    strtrustee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strtrustee(::std::string* strtrustee) {
  if (strtrustee_ != &::google::protobuf::internal::kEmptyString) {
    delete strtrustee_;
  }
  if (strtrustee) {
    set_has_strtrustee();
    strtrustee_ = strtrustee;
  } else {
    clear_has_strtrustee();
    strtrustee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strOverheadCharge = 23;
inline bool ProduceInfo::has_stroverheadcharge() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ProduceInfo::set_has_stroverheadcharge() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ProduceInfo::clear_has_stroverheadcharge() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ProduceInfo::clear_stroverheadcharge() {
  if (stroverheadcharge_ != &::google::protobuf::internal::kEmptyString) {
    stroverheadcharge_->clear();
  }
  clear_has_stroverheadcharge();
}
inline const ::std::string& ProduceInfo::stroverheadcharge() const {
  return *stroverheadcharge_;
}
inline void ProduceInfo::set_stroverheadcharge(const ::std::string& value) {
  set_has_stroverheadcharge();
  if (stroverheadcharge_ == &::google::protobuf::internal::kEmptyString) {
    stroverheadcharge_ = new ::std::string;
  }
  stroverheadcharge_->assign(value);
}
inline void ProduceInfo::set_stroverheadcharge(const char* value) {
  set_has_stroverheadcharge();
  if (stroverheadcharge_ == &::google::protobuf::internal::kEmptyString) {
    stroverheadcharge_ = new ::std::string;
  }
  stroverheadcharge_->assign(value);
}
inline void ProduceInfo::set_stroverheadcharge(const char* value, size_t size) {
  set_has_stroverheadcharge();
  if (stroverheadcharge_ == &::google::protobuf::internal::kEmptyString) {
    stroverheadcharge_ = new ::std::string;
  }
  stroverheadcharge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_stroverheadcharge() {
  set_has_stroverheadcharge();
  if (stroverheadcharge_ == &::google::protobuf::internal::kEmptyString) {
    stroverheadcharge_ = new ::std::string;
  }
  return stroverheadcharge_;
}
inline ::std::string* ProduceInfo::release_stroverheadcharge() {
  clear_has_stroverheadcharge();
  if (stroverheadcharge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroverheadcharge_;
    stroverheadcharge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_stroverheadcharge(::std::string* stroverheadcharge) {
  if (stroverheadcharge_ != &::google::protobuf::internal::kEmptyString) {
    delete stroverheadcharge_;
  }
  if (stroverheadcharge) {
    set_has_stroverheadcharge();
    stroverheadcharge_ = stroverheadcharge;
  } else {
    clear_has_stroverheadcharge();
    stroverheadcharge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRevenueCalculation = 24;
inline bool ProduceInfo::has_strrevenuecalculation() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ProduceInfo::set_has_strrevenuecalculation() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ProduceInfo::clear_has_strrevenuecalculation() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ProduceInfo::clear_strrevenuecalculation() {
  if (strrevenuecalculation_ != &::google::protobuf::internal::kEmptyString) {
    strrevenuecalculation_->clear();
  }
  clear_has_strrevenuecalculation();
}
inline const ::std::string& ProduceInfo::strrevenuecalculation() const {
  return *strrevenuecalculation_;
}
inline void ProduceInfo::set_strrevenuecalculation(const ::std::string& value) {
  set_has_strrevenuecalculation();
  if (strrevenuecalculation_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuecalculation_ = new ::std::string;
  }
  strrevenuecalculation_->assign(value);
}
inline void ProduceInfo::set_strrevenuecalculation(const char* value) {
  set_has_strrevenuecalculation();
  if (strrevenuecalculation_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuecalculation_ = new ::std::string;
  }
  strrevenuecalculation_->assign(value);
}
inline void ProduceInfo::set_strrevenuecalculation(const char* value, size_t size) {
  set_has_strrevenuecalculation();
  if (strrevenuecalculation_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuecalculation_ = new ::std::string;
  }
  strrevenuecalculation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strrevenuecalculation() {
  set_has_strrevenuecalculation();
  if (strrevenuecalculation_ == &::google::protobuf::internal::kEmptyString) {
    strrevenuecalculation_ = new ::std::string;
  }
  return strrevenuecalculation_;
}
inline ::std::string* ProduceInfo::release_strrevenuecalculation() {
  clear_has_strrevenuecalculation();
  if (strrevenuecalculation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrevenuecalculation_;
    strrevenuecalculation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strrevenuecalculation(::std::string* strrevenuecalculation) {
  if (strrevenuecalculation_ != &::google::protobuf::internal::kEmptyString) {
    delete strrevenuecalculation_;
  }
  if (strrevenuecalculation) {
    set_has_strrevenuecalculation();
    strrevenuecalculation_ = strrevenuecalculation;
  } else {
    clear_has_strrevenuecalculation();
    strrevenuecalculation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strContent = 25;
inline bool ProduceInfo::has_strcontent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ProduceInfo::set_has_strcontent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ProduceInfo::clear_has_strcontent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ProduceInfo::clear_strcontent() {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    strcontent_->clear();
  }
  clear_has_strcontent();
}
inline const ::std::string& ProduceInfo::strcontent() const {
  return *strcontent_;
}
inline void ProduceInfo::set_strcontent(const ::std::string& value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void ProduceInfo::set_strcontent(const char* value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void ProduceInfo::set_strcontent(const char* value, size_t size) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strcontent() {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  return strcontent_;
}
inline ::std::string* ProduceInfo::release_strcontent() {
  clear_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcontent_;
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strcontent(::std::string* strcontent) {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete strcontent_;
  }
  if (strcontent) {
    set_has_strcontent();
    strcontent_ = strcontent;
  } else {
    clear_has_strcontent();
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMaxTime = 26;
inline bool ProduceInfo::has_nmaxtime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ProduceInfo::set_has_nmaxtime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ProduceInfo::clear_has_nmaxtime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ProduceInfo::clear_nmaxtime() {
  nmaxtime_ = 0;
  clear_has_nmaxtime();
}
inline ::google::protobuf::int32 ProduceInfo::nmaxtime() const {
  return nmaxtime_;
}
inline void ProduceInfo::set_nmaxtime(::google::protobuf::int32 value) {
  set_has_nmaxtime();
  nmaxtime_ = value;
}

// required int32 nMineTime = 27;
inline bool ProduceInfo::has_nminetime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ProduceInfo::set_has_nminetime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ProduceInfo::clear_has_nminetime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ProduceInfo::clear_nminetime() {
  nminetime_ = 0;
  clear_has_nminetime();
}
inline ::google::protobuf::int32 ProduceInfo::nminetime() const {
  return nminetime_;
}
inline void ProduceInfo::set_nminetime(::google::protobuf::int32 value) {
  set_has_nminetime();
  nminetime_ = value;
}

// required int32 nStandardTime = 28;
inline bool ProduceInfo::has_nstandardtime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ProduceInfo::set_has_nstandardtime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ProduceInfo::clear_has_nstandardtime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ProduceInfo::clear_nstandardtime() {
  nstandardtime_ = 0;
  clear_has_nstandardtime();
}
inline ::google::protobuf::int32 ProduceInfo::nstandardtime() const {
  return nstandardtime_;
}
inline void ProduceInfo::set_nstandardtime(::google::protobuf::int32 value) {
  set_has_nstandardtime();
  nstandardtime_ = value;
}

// required string strPrequestion = 29;
inline bool ProduceInfo::has_strprequestion() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ProduceInfo::set_has_strprequestion() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ProduceInfo::clear_has_strprequestion() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ProduceInfo::clear_strprequestion() {
  if (strprequestion_ != &::google::protobuf::internal::kEmptyString) {
    strprequestion_->clear();
  }
  clear_has_strprequestion();
}
inline const ::std::string& ProduceInfo::strprequestion() const {
  return *strprequestion_;
}
inline void ProduceInfo::set_strprequestion(const ::std::string& value) {
  set_has_strprequestion();
  if (strprequestion_ == &::google::protobuf::internal::kEmptyString) {
    strprequestion_ = new ::std::string;
  }
  strprequestion_->assign(value);
}
inline void ProduceInfo::set_strprequestion(const char* value) {
  set_has_strprequestion();
  if (strprequestion_ == &::google::protobuf::internal::kEmptyString) {
    strprequestion_ = new ::std::string;
  }
  strprequestion_->assign(value);
}
inline void ProduceInfo::set_strprequestion(const char* value, size_t size) {
  set_has_strprequestion();
  if (strprequestion_ == &::google::protobuf::internal::kEmptyString) {
    strprequestion_ = new ::std::string;
  }
  strprequestion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strprequestion() {
  set_has_strprequestion();
  if (strprequestion_ == &::google::protobuf::internal::kEmptyString) {
    strprequestion_ = new ::std::string;
  }
  return strprequestion_;
}
inline ::std::string* ProduceInfo::release_strprequestion() {
  clear_has_strprequestion();
  if (strprequestion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strprequestion_;
    strprequestion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strprequestion(::std::string* strprequestion) {
  if (strprequestion_ != &::google::protobuf::internal::kEmptyString) {
    delete strprequestion_;
  }
  if (strprequestion) {
    set_has_strprequestion();
    strprequestion_ = strprequestion;
  } else {
    clear_has_strprequestion();
    strprequestion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nIsPublished = 30;
inline bool ProduceInfo::has_nispublished() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ProduceInfo::set_has_nispublished() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ProduceInfo::clear_has_nispublished() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ProduceInfo::clear_nispublished() {
  nispublished_ = 0;
  clear_has_nispublished();
}
inline ::google::protobuf::int32 ProduceInfo::nispublished() const {
  return nispublished_;
}
inline void ProduceInfo::set_nispublished(::google::protobuf::int32 value) {
  set_has_nispublished();
  nispublished_ = value;
}

// required int32 nIsEnabled = 31;
inline bool ProduceInfo::has_nisenabled() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ProduceInfo::set_has_nisenabled() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ProduceInfo::clear_has_nisenabled() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ProduceInfo::clear_nisenabled() {
  nisenabled_ = 0;
  clear_has_nisenabled();
}
inline ::google::protobuf::int32 ProduceInfo::nisenabled() const {
  return nisenabled_;
}
inline void ProduceInfo::set_nisenabled(::google::protobuf::int32 value) {
  set_has_nisenabled();
  nisenabled_ = value;
}

// required int32 nExtendedInfo = 32;
inline bool ProduceInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ProduceInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ProduceInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ProduceInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 ProduceInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void ProduceInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 33;
inline bool ProduceInfo::has_strextendedinfo1() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ProduceInfo::set_has_strextendedinfo1() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ProduceInfo::clear_has_strextendedinfo1() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ProduceInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& ProduceInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void ProduceInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ProduceInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ProduceInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* ProduceInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 34;
inline bool ProduceInfo::has_strextendedinfo2() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ProduceInfo::set_has_strextendedinfo2() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ProduceInfo::clear_has_strextendedinfo2() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ProduceInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& ProduceInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void ProduceInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ProduceInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ProduceInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* ProduceInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nEnableMigrated = 35;
inline bool ProduceInfo::has_nenablemigrated() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ProduceInfo::set_has_nenablemigrated() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ProduceInfo::clear_has_nenablemigrated() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ProduceInfo::clear_nenablemigrated() {
  nenablemigrated_ = 0;
  clear_has_nenablemigrated();
}
inline ::google::protobuf::int32 ProduceInfo::nenablemigrated() const {
  return nenablemigrated_;
}
inline void ProduceInfo::set_nenablemigrated(::google::protobuf::int32 value) {
  set_has_nenablemigrated();
  nenablemigrated_ = value;
}

// required int32 nRecordExistDays = 36;
inline bool ProduceInfo::has_nrecordexistdays() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ProduceInfo::set_has_nrecordexistdays() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ProduceInfo::clear_has_nrecordexistdays() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ProduceInfo::clear_nrecordexistdays() {
  nrecordexistdays_ = 0;
  clear_has_nrecordexistdays();
}
inline ::google::protobuf::int32 ProduceInfo::nrecordexistdays() const {
  return nrecordexistdays_;
}
inline void ProduceInfo::set_nrecordexistdays(::google::protobuf::int32 value) {
  set_has_nrecordexistdays();
  nrecordexistdays_ = value;
}

// required int32 nType = 37;
inline bool ProduceInfo::has_ntype() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ProduceInfo::set_has_ntype() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ProduceInfo::clear_has_ntype() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ProduceInfo::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 ProduceInfo::ntype() const {
  return ntype_;
}
inline void ProduceInfo::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// required string strRiskLevelDesc = 38;
inline bool ProduceInfo::has_strriskleveldesc() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ProduceInfo::set_has_strriskleveldesc() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ProduceInfo::clear_has_strriskleveldesc() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ProduceInfo::clear_strriskleveldesc() {
  if (strriskleveldesc_ != &::google::protobuf::internal::kEmptyString) {
    strriskleveldesc_->clear();
  }
  clear_has_strriskleveldesc();
}
inline const ::std::string& ProduceInfo::strriskleveldesc() const {
  return *strriskleveldesc_;
}
inline void ProduceInfo::set_strriskleveldesc(const ::std::string& value) {
  set_has_strriskleveldesc();
  if (strriskleveldesc_ == &::google::protobuf::internal::kEmptyString) {
    strriskleveldesc_ = new ::std::string;
  }
  strriskleveldesc_->assign(value);
}
inline void ProduceInfo::set_strriskleveldesc(const char* value) {
  set_has_strriskleveldesc();
  if (strriskleveldesc_ == &::google::protobuf::internal::kEmptyString) {
    strriskleveldesc_ = new ::std::string;
  }
  strriskleveldesc_->assign(value);
}
inline void ProduceInfo::set_strriskleveldesc(const char* value, size_t size) {
  set_has_strriskleveldesc();
  if (strriskleveldesc_ == &::google::protobuf::internal::kEmptyString) {
    strriskleveldesc_ = new ::std::string;
  }
  strriskleveldesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceInfo::mutable_strriskleveldesc() {
  set_has_strriskleveldesc();
  if (strriskleveldesc_ == &::google::protobuf::internal::kEmptyString) {
    strriskleveldesc_ = new ::std::string;
  }
  return strriskleveldesc_;
}
inline ::std::string* ProduceInfo::release_strriskleveldesc() {
  clear_has_strriskleveldesc();
  if (strriskleveldesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strriskleveldesc_;
    strriskleveldesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceInfo::set_allocated_strriskleveldesc(::std::string* strriskleveldesc) {
  if (strriskleveldesc_ != &::google::protobuf::internal::kEmptyString) {
    delete strriskleveldesc_;
  }
  if (strriskleveldesc) {
    set_has_strriskleveldesc();
    strriskleveldesc_ = strriskleveldesc;
  } else {
    clear_has_strriskleveldesc();
    strriskleveldesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPROD_LIFECYCLE = 39;
inline bool ProduceInfo::has_nprod_lifecycle() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ProduceInfo::set_has_nprod_lifecycle() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ProduceInfo::clear_has_nprod_lifecycle() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ProduceInfo::clear_nprod_lifecycle() {
  nprod_lifecycle_ = 0;
  clear_has_nprod_lifecycle();
}
inline ::google::protobuf::int32 ProduceInfo::nprod_lifecycle() const {
  return nprod_lifecycle_;
}
inline void ProduceInfo::set_nprod_lifecycle(::google::protobuf::int32 value) {
  set_has_nprod_lifecycle();
  nprod_lifecycle_ = value;
}

// -------------------------------------------------------------------

// BranchInfo

// required string strBranchId = 1;
inline bool BranchInfo::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BranchInfo::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BranchInfo::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BranchInfo::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& BranchInfo::strbranchid() const {
  return *strbranchid_;
}
inline void BranchInfo::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BranchInfo::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BranchInfo::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* BranchInfo::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strName = 2;
inline bool BranchInfo::has_strname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BranchInfo::set_has_strname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BranchInfo::clear_has_strname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BranchInfo::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& BranchInfo::strname() const {
  return *strname_;
}
inline void BranchInfo::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void BranchInfo::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void BranchInfo::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* BranchInfo::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strname(::std::string* strname) {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    delete strname_;
  }
  if (strname) {
    set_has_strname();
    strname_ = strname;
  } else {
    clear_has_strname();
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strAddress = 3;
inline bool BranchInfo::has_straddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BranchInfo::set_has_straddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BranchInfo::clear_has_straddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BranchInfo::clear_straddress() {
  if (straddress_ != &::google::protobuf::internal::kEmptyString) {
    straddress_->clear();
  }
  clear_has_straddress();
}
inline const ::std::string& BranchInfo::straddress() const {
  return *straddress_;
}
inline void BranchInfo::set_straddress(const ::std::string& value) {
  set_has_straddress();
  if (straddress_ == &::google::protobuf::internal::kEmptyString) {
    straddress_ = new ::std::string;
  }
  straddress_->assign(value);
}
inline void BranchInfo::set_straddress(const char* value) {
  set_has_straddress();
  if (straddress_ == &::google::protobuf::internal::kEmptyString) {
    straddress_ = new ::std::string;
  }
  straddress_->assign(value);
}
inline void BranchInfo::set_straddress(const char* value, size_t size) {
  set_has_straddress();
  if (straddress_ == &::google::protobuf::internal::kEmptyString) {
    straddress_ = new ::std::string;
  }
  straddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_straddress() {
  set_has_straddress();
  if (straddress_ == &::google::protobuf::internal::kEmptyString) {
    straddress_ = new ::std::string;
  }
  return straddress_;
}
inline ::std::string* BranchInfo::release_straddress() {
  clear_has_straddress();
  if (straddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straddress_;
    straddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_straddress(::std::string* straddress) {
  if (straddress_ != &::google::protobuf::internal::kEmptyString) {
    delete straddress_;
  }
  if (straddress) {
    set_has_straddress();
    straddress_ = straddress;
  } else {
    clear_has_straddress();
    straddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strContact = 4;
inline bool BranchInfo::has_strcontact() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BranchInfo::set_has_strcontact() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BranchInfo::clear_has_strcontact() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BranchInfo::clear_strcontact() {
  if (strcontact_ != &::google::protobuf::internal::kEmptyString) {
    strcontact_->clear();
  }
  clear_has_strcontact();
}
inline const ::std::string& BranchInfo::strcontact() const {
  return *strcontact_;
}
inline void BranchInfo::set_strcontact(const ::std::string& value) {
  set_has_strcontact();
  if (strcontact_ == &::google::protobuf::internal::kEmptyString) {
    strcontact_ = new ::std::string;
  }
  strcontact_->assign(value);
}
inline void BranchInfo::set_strcontact(const char* value) {
  set_has_strcontact();
  if (strcontact_ == &::google::protobuf::internal::kEmptyString) {
    strcontact_ = new ::std::string;
  }
  strcontact_->assign(value);
}
inline void BranchInfo::set_strcontact(const char* value, size_t size) {
  set_has_strcontact();
  if (strcontact_ == &::google::protobuf::internal::kEmptyString) {
    strcontact_ = new ::std::string;
  }
  strcontact_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strcontact() {
  set_has_strcontact();
  if (strcontact_ == &::google::protobuf::internal::kEmptyString) {
    strcontact_ = new ::std::string;
  }
  return strcontact_;
}
inline ::std::string* BranchInfo::release_strcontact() {
  clear_has_strcontact();
  if (strcontact_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcontact_;
    strcontact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strcontact(::std::string* strcontact) {
  if (strcontact_ != &::google::protobuf::internal::kEmptyString) {
    delete strcontact_;
  }
  if (strcontact) {
    set_has_strcontact();
    strcontact_ = strcontact;
  } else {
    clear_has_strcontact();
    strcontact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPhone = 5;
inline bool BranchInfo::has_strphone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BranchInfo::set_has_strphone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BranchInfo::clear_has_strphone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BranchInfo::clear_strphone() {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    strphone_->clear();
  }
  clear_has_strphone();
}
inline const ::std::string& BranchInfo::strphone() const {
  return *strphone_;
}
inline void BranchInfo::set_strphone(const ::std::string& value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void BranchInfo::set_strphone(const char* value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void BranchInfo::set_strphone(const char* value, size_t size) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strphone() {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  return strphone_;
}
inline ::std::string* BranchInfo::release_strphone() {
  clear_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strphone_;
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strphone(::std::string* strphone) {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    delete strphone_;
  }
  if (strphone) {
    set_has_strphone();
    strphone_ = strphone;
  } else {
    clear_has_strphone();
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strContent = 6;
inline bool BranchInfo::has_strcontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BranchInfo::set_has_strcontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BranchInfo::clear_has_strcontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BranchInfo::clear_strcontent() {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    strcontent_->clear();
  }
  clear_has_strcontent();
}
inline const ::std::string& BranchInfo::strcontent() const {
  return *strcontent_;
}
inline void BranchInfo::set_strcontent(const ::std::string& value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void BranchInfo::set_strcontent(const char* value) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(value);
}
inline void BranchInfo::set_strcontent(const char* value, size_t size) {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  strcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strcontent() {
  set_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    strcontent_ = new ::std::string;
  }
  return strcontent_;
}
inline ::std::string* BranchInfo::release_strcontent() {
  clear_has_strcontent();
  if (strcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcontent_;
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strcontent(::std::string* strcontent) {
  if (strcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete strcontent_;
  }
  if (strcontent) {
    set_has_strcontent();
    strcontent_ = strcontent;
  } else {
    clear_has_strcontent();
    strcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 7;
inline bool BranchInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BranchInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BranchInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BranchInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 BranchInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void BranchInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 8;
inline bool BranchInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BranchInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BranchInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BranchInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& BranchInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void BranchInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BranchInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BranchInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* BranchInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 9;
inline bool BranchInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BranchInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BranchInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BranchInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& BranchInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void BranchInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BranchInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BranchInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* BranchInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strParentId = 10;
inline bool BranchInfo::has_strparentid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BranchInfo::set_has_strparentid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BranchInfo::clear_has_strparentid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BranchInfo::clear_strparentid() {
  if (strparentid_ != &::google::protobuf::internal::kEmptyString) {
    strparentid_->clear();
  }
  clear_has_strparentid();
}
inline const ::std::string& BranchInfo::strparentid() const {
  return *strparentid_;
}
inline void BranchInfo::set_strparentid(const ::std::string& value) {
  set_has_strparentid();
  if (strparentid_ == &::google::protobuf::internal::kEmptyString) {
    strparentid_ = new ::std::string;
  }
  strparentid_->assign(value);
}
inline void BranchInfo::set_strparentid(const char* value) {
  set_has_strparentid();
  if (strparentid_ == &::google::protobuf::internal::kEmptyString) {
    strparentid_ = new ::std::string;
  }
  strparentid_->assign(value);
}
inline void BranchInfo::set_strparentid(const char* value, size_t size) {
  set_has_strparentid();
  if (strparentid_ == &::google::protobuf::internal::kEmptyString) {
    strparentid_ = new ::std::string;
  }
  strparentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strparentid() {
  set_has_strparentid();
  if (strparentid_ == &::google::protobuf::internal::kEmptyString) {
    strparentid_ = new ::std::string;
  }
  return strparentid_;
}
inline ::std::string* BranchInfo::release_strparentid() {
  clear_has_strparentid();
  if (strparentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparentid_;
    strparentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strparentid(::std::string* strparentid) {
  if (strparentid_ != &::google::protobuf::internal::kEmptyString) {
    delete strparentid_;
  }
  if (strparentid) {
    set_has_strparentid();
    strparentid_ = strparentid;
  } else {
    clear_has_strparentid();
    strparentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nIsLocal = 11;
inline bool BranchInfo::has_nislocal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BranchInfo::set_has_nislocal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BranchInfo::clear_has_nislocal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BranchInfo::clear_nislocal() {
  nislocal_ = 0;
  clear_has_nislocal();
}
inline ::google::protobuf::int32 BranchInfo::nislocal() const {
  return nislocal_;
}
inline void BranchInfo::set_nislocal(::google::protobuf::int32 value) {
  set_has_nislocal();
  nislocal_ = value;
}

// required string strJDBRID = 12;
inline bool BranchInfo::has_strjdbrid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BranchInfo::set_has_strjdbrid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BranchInfo::clear_has_strjdbrid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BranchInfo::clear_strjdbrid() {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    strjdbrid_->clear();
  }
  clear_has_strjdbrid();
}
inline const ::std::string& BranchInfo::strjdbrid() const {
  return *strjdbrid_;
}
inline void BranchInfo::set_strjdbrid(const ::std::string& value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void BranchInfo::set_strjdbrid(const char* value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void BranchInfo::set_strjdbrid(const char* value, size_t size) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strjdbrid() {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  return strjdbrid_;
}
inline ::std::string* BranchInfo::release_strjdbrid() {
  clear_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strjdbrid_;
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strjdbrid(::std::string* strjdbrid) {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    delete strjdbrid_;
  }
  if (strjdbrid) {
    set_has_strjdbrid();
    strjdbrid_ = strjdbrid;
  } else {
    clear_has_strjdbrid();
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strParentJDBRID = 13;
inline bool BranchInfo::has_strparentjdbrid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BranchInfo::set_has_strparentjdbrid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BranchInfo::clear_has_strparentjdbrid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BranchInfo::clear_strparentjdbrid() {
  if (strparentjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    strparentjdbrid_->clear();
  }
  clear_has_strparentjdbrid();
}
inline const ::std::string& BranchInfo::strparentjdbrid() const {
  return *strparentjdbrid_;
}
inline void BranchInfo::set_strparentjdbrid(const ::std::string& value) {
  set_has_strparentjdbrid();
  if (strparentjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strparentjdbrid_ = new ::std::string;
  }
  strparentjdbrid_->assign(value);
}
inline void BranchInfo::set_strparentjdbrid(const char* value) {
  set_has_strparentjdbrid();
  if (strparentjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strparentjdbrid_ = new ::std::string;
  }
  strparentjdbrid_->assign(value);
}
inline void BranchInfo::set_strparentjdbrid(const char* value, size_t size) {
  set_has_strparentjdbrid();
  if (strparentjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strparentjdbrid_ = new ::std::string;
  }
  strparentjdbrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strparentjdbrid() {
  set_has_strparentjdbrid();
  if (strparentjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strparentjdbrid_ = new ::std::string;
  }
  return strparentjdbrid_;
}
inline ::std::string* BranchInfo::release_strparentjdbrid() {
  clear_has_strparentjdbrid();
  if (strparentjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparentjdbrid_;
    strparentjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strparentjdbrid(::std::string* strparentjdbrid) {
  if (strparentjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    delete strparentjdbrid_;
  }
  if (strparentjdbrid) {
    set_has_strparentjdbrid();
    strparentjdbrid_ = strparentjdbrid;
  } else {
    clear_has_strparentjdbrid();
    strparentjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strParentName = 14;
inline bool BranchInfo::has_strparentname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BranchInfo::set_has_strparentname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BranchInfo::clear_has_strparentname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BranchInfo::clear_strparentname() {
  if (strparentname_ != &::google::protobuf::internal::kEmptyString) {
    strparentname_->clear();
  }
  clear_has_strparentname();
}
inline const ::std::string& BranchInfo::strparentname() const {
  return *strparentname_;
}
inline void BranchInfo::set_strparentname(const ::std::string& value) {
  set_has_strparentname();
  if (strparentname_ == &::google::protobuf::internal::kEmptyString) {
    strparentname_ = new ::std::string;
  }
  strparentname_->assign(value);
}
inline void BranchInfo::set_strparentname(const char* value) {
  set_has_strparentname();
  if (strparentname_ == &::google::protobuf::internal::kEmptyString) {
    strparentname_ = new ::std::string;
  }
  strparentname_->assign(value);
}
inline void BranchInfo::set_strparentname(const char* value, size_t size) {
  set_has_strparentname();
  if (strparentname_ == &::google::protobuf::internal::kEmptyString) {
    strparentname_ = new ::std::string;
  }
  strparentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strparentname() {
  set_has_strparentname();
  if (strparentname_ == &::google::protobuf::internal::kEmptyString) {
    strparentname_ = new ::std::string;
  }
  return strparentname_;
}
inline ::std::string* BranchInfo::release_strparentname() {
  clear_has_strparentname();
  if (strparentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparentname_;
    strparentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strparentname(::std::string* strparentname) {
  if (strparentname_ != &::google::protobuf::internal::kEmptyString) {
    delete strparentname_;
  }
  if (strparentname) {
    set_has_strparentname();
    strparentname_ = strparentname;
  } else {
    clear_has_strparentname();
    strparentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strJDTYPE = 15;
inline bool BranchInfo::has_strjdtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BranchInfo::set_has_strjdtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BranchInfo::clear_has_strjdtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BranchInfo::clear_strjdtype() {
  if (strjdtype_ != &::google::protobuf::internal::kEmptyString) {
    strjdtype_->clear();
  }
  clear_has_strjdtype();
}
inline const ::std::string& BranchInfo::strjdtype() const {
  return *strjdtype_;
}
inline void BranchInfo::set_strjdtype(const ::std::string& value) {
  set_has_strjdtype();
  if (strjdtype_ == &::google::protobuf::internal::kEmptyString) {
    strjdtype_ = new ::std::string;
  }
  strjdtype_->assign(value);
}
inline void BranchInfo::set_strjdtype(const char* value) {
  set_has_strjdtype();
  if (strjdtype_ == &::google::protobuf::internal::kEmptyString) {
    strjdtype_ = new ::std::string;
  }
  strjdtype_->assign(value);
}
inline void BranchInfo::set_strjdtype(const char* value, size_t size) {
  set_has_strjdtype();
  if (strjdtype_ == &::google::protobuf::internal::kEmptyString) {
    strjdtype_ = new ::std::string;
  }
  strjdtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BranchInfo::mutable_strjdtype() {
  set_has_strjdtype();
  if (strjdtype_ == &::google::protobuf::internal::kEmptyString) {
    strjdtype_ = new ::std::string;
  }
  return strjdtype_;
}
inline ::std::string* BranchInfo::release_strjdtype() {
  clear_has_strjdtype();
  if (strjdtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strjdtype_;
    strjdtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BranchInfo::set_allocated_strjdtype(::std::string* strjdtype) {
  if (strjdtype_ != &::google::protobuf::internal::kEmptyString) {
    delete strjdtype_;
  }
  if (strjdtype) {
    set_has_strjdtype();
    strjdtype_ = strjdtype;
  } else {
    clear_has_strjdtype();
    strjdtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BusinessFileInfo

// required string strRecordId = 1;
inline bool BusinessFileInfo::has_strrecordid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessFileInfo::set_has_strrecordid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessFileInfo::clear_has_strrecordid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessFileInfo::clear_strrecordid() {
  if (strrecordid_ != &::google::protobuf::internal::kEmptyString) {
    strrecordid_->clear();
  }
  clear_has_strrecordid();
}
inline const ::std::string& BusinessFileInfo::strrecordid() const {
  return *strrecordid_;
}
inline void BusinessFileInfo::set_strrecordid(const ::std::string& value) {
  set_has_strrecordid();
  if (strrecordid_ == &::google::protobuf::internal::kEmptyString) {
    strrecordid_ = new ::std::string;
  }
  strrecordid_->assign(value);
}
inline void BusinessFileInfo::set_strrecordid(const char* value) {
  set_has_strrecordid();
  if (strrecordid_ == &::google::protobuf::internal::kEmptyString) {
    strrecordid_ = new ::std::string;
  }
  strrecordid_->assign(value);
}
inline void BusinessFileInfo::set_strrecordid(const char* value, size_t size) {
  set_has_strrecordid();
  if (strrecordid_ == &::google::protobuf::internal::kEmptyString) {
    strrecordid_ = new ::std::string;
  }
  strrecordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strrecordid() {
  set_has_strrecordid();
  if (strrecordid_ == &::google::protobuf::internal::kEmptyString) {
    strrecordid_ = new ::std::string;
  }
  return strrecordid_;
}
inline ::std::string* BusinessFileInfo::release_strrecordid() {
  clear_has_strrecordid();
  if (strrecordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordid_;
    strrecordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strrecordid(::std::string* strrecordid) {
  if (strrecordid_ != &::google::protobuf::internal::kEmptyString) {
    delete strrecordid_;
  }
  if (strrecordid) {
    set_has_strrecordid();
    strrecordid_ = strrecordid;
  } else {
    clear_has_strrecordid();
    strrecordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessInfoId = 2;
inline bool BusinessFileInfo::has_strbusinessinfoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessFileInfo::set_has_strbusinessinfoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessFileInfo::clear_has_strbusinessinfoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessFileInfo::clear_strbusinessinfoid() {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_->clear();
  }
  clear_has_strbusinessinfoid();
}
inline const ::std::string& BusinessFileInfo::strbusinessinfoid() const {
  return *strbusinessinfoid_;
}
inline void BusinessFileInfo::set_strbusinessinfoid(const ::std::string& value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessFileInfo::set_strbusinessinfoid(const char* value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessFileInfo::set_strbusinessinfoid(const char* value, size_t size) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strbusinessinfoid() {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  return strbusinessinfoid_;
}
inline ::std::string* BusinessFileInfo::release_strbusinessinfoid() {
  clear_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessinfoid_;
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid) {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessinfoid_;
  }
  if (strbusinessinfoid) {
    set_has_strbusinessinfoid();
    strbusinessinfoid_ = strbusinessinfoid;
  } else {
    clear_has_strbusinessinfoid();
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nType = 3;
inline bool BusinessFileInfo::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessFileInfo::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessFileInfo::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessFileInfo::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 BusinessFileInfo::ntype() const {
  return ntype_;
}
inline void BusinessFileInfo::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// required string strFileId = 4;
inline bool BusinessFileInfo::has_strfileid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessFileInfo::set_has_strfileid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessFileInfo::clear_has_strfileid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessFileInfo::clear_strfileid() {
  if (strfileid_ != &::google::protobuf::internal::kEmptyString) {
    strfileid_->clear();
  }
  clear_has_strfileid();
}
inline const ::std::string& BusinessFileInfo::strfileid() const {
  return *strfileid_;
}
inline void BusinessFileInfo::set_strfileid(const ::std::string& value) {
  set_has_strfileid();
  if (strfileid_ == &::google::protobuf::internal::kEmptyString) {
    strfileid_ = new ::std::string;
  }
  strfileid_->assign(value);
}
inline void BusinessFileInfo::set_strfileid(const char* value) {
  set_has_strfileid();
  if (strfileid_ == &::google::protobuf::internal::kEmptyString) {
    strfileid_ = new ::std::string;
  }
  strfileid_->assign(value);
}
inline void BusinessFileInfo::set_strfileid(const char* value, size_t size) {
  set_has_strfileid();
  if (strfileid_ == &::google::protobuf::internal::kEmptyString) {
    strfileid_ = new ::std::string;
  }
  strfileid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strfileid() {
  set_has_strfileid();
  if (strfileid_ == &::google::protobuf::internal::kEmptyString) {
    strfileid_ = new ::std::string;
  }
  return strfileid_;
}
inline ::std::string* BusinessFileInfo::release_strfileid() {
  clear_has_strfileid();
  if (strfileid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strfileid_;
    strfileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strfileid(::std::string* strfileid) {
  if (strfileid_ != &::google::protobuf::internal::kEmptyString) {
    delete strfileid_;
  }
  if (strfileid) {
    set_has_strfileid();
    strfileid_ = strfileid;
  } else {
    clear_has_strfileid();
    strfileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRecordBegin = 5;
inline bool BusinessFileInfo::has_strrecordbegin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessFileInfo::set_has_strrecordbegin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessFileInfo::clear_has_strrecordbegin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessFileInfo::clear_strrecordbegin() {
  if (strrecordbegin_ != &::google::protobuf::internal::kEmptyString) {
    strrecordbegin_->clear();
  }
  clear_has_strrecordbegin();
}
inline const ::std::string& BusinessFileInfo::strrecordbegin() const {
  return *strrecordbegin_;
}
inline void BusinessFileInfo::set_strrecordbegin(const ::std::string& value) {
  set_has_strrecordbegin();
  if (strrecordbegin_ == &::google::protobuf::internal::kEmptyString) {
    strrecordbegin_ = new ::std::string;
  }
  strrecordbegin_->assign(value);
}
inline void BusinessFileInfo::set_strrecordbegin(const char* value) {
  set_has_strrecordbegin();
  if (strrecordbegin_ == &::google::protobuf::internal::kEmptyString) {
    strrecordbegin_ = new ::std::string;
  }
  strrecordbegin_->assign(value);
}
inline void BusinessFileInfo::set_strrecordbegin(const char* value, size_t size) {
  set_has_strrecordbegin();
  if (strrecordbegin_ == &::google::protobuf::internal::kEmptyString) {
    strrecordbegin_ = new ::std::string;
  }
  strrecordbegin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strrecordbegin() {
  set_has_strrecordbegin();
  if (strrecordbegin_ == &::google::protobuf::internal::kEmptyString) {
    strrecordbegin_ = new ::std::string;
  }
  return strrecordbegin_;
}
inline ::std::string* BusinessFileInfo::release_strrecordbegin() {
  clear_has_strrecordbegin();
  if (strrecordbegin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordbegin_;
    strrecordbegin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strrecordbegin(::std::string* strrecordbegin) {
  if (strrecordbegin_ != &::google::protobuf::internal::kEmptyString) {
    delete strrecordbegin_;
  }
  if (strrecordbegin) {
    set_has_strrecordbegin();
    strrecordbegin_ = strrecordbegin;
  } else {
    clear_has_strrecordbegin();
    strrecordbegin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRecordEnd = 6;
inline bool BusinessFileInfo::has_strrecordend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessFileInfo::set_has_strrecordend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessFileInfo::clear_has_strrecordend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessFileInfo::clear_strrecordend() {
  if (strrecordend_ != &::google::protobuf::internal::kEmptyString) {
    strrecordend_->clear();
  }
  clear_has_strrecordend();
}
inline const ::std::string& BusinessFileInfo::strrecordend() const {
  return *strrecordend_;
}
inline void BusinessFileInfo::set_strrecordend(const ::std::string& value) {
  set_has_strrecordend();
  if (strrecordend_ == &::google::protobuf::internal::kEmptyString) {
    strrecordend_ = new ::std::string;
  }
  strrecordend_->assign(value);
}
inline void BusinessFileInfo::set_strrecordend(const char* value) {
  set_has_strrecordend();
  if (strrecordend_ == &::google::protobuf::internal::kEmptyString) {
    strrecordend_ = new ::std::string;
  }
  strrecordend_->assign(value);
}
inline void BusinessFileInfo::set_strrecordend(const char* value, size_t size) {
  set_has_strrecordend();
  if (strrecordend_ == &::google::protobuf::internal::kEmptyString) {
    strrecordend_ = new ::std::string;
  }
  strrecordend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strrecordend() {
  set_has_strrecordend();
  if (strrecordend_ == &::google::protobuf::internal::kEmptyString) {
    strrecordend_ = new ::std::string;
  }
  return strrecordend_;
}
inline ::std::string* BusinessFileInfo::release_strrecordend() {
  clear_has_strrecordend();
  if (strrecordend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordend_;
    strrecordend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strrecordend(::std::string* strrecordend) {
  if (strrecordend_ != &::google::protobuf::internal::kEmptyString) {
    delete strrecordend_;
  }
  if (strrecordend) {
    set_has_strrecordend();
    strrecordend_ = strrecordend;
  } else {
    clear_has_strrecordend();
    strrecordend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 7;
inline bool BusinessFileInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BusinessFileInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BusinessFileInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BusinessFileInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 BusinessFileInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void BusinessFileInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 8;
inline bool BusinessFileInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BusinessFileInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BusinessFileInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BusinessFileInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& BusinessFileInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void BusinessFileInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BusinessFileInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void BusinessFileInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* BusinessFileInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 9;
inline bool BusinessFileInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BusinessFileInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BusinessFileInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BusinessFileInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& BusinessFileInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void BusinessFileInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessFileInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessFileInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessFileInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* BusinessFileInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessFileInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMigrated = 10;
inline bool BusinessFileInfo::has_nmigrated() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BusinessFileInfo::set_has_nmigrated() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BusinessFileInfo::clear_has_nmigrated() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BusinessFileInfo::clear_nmigrated() {
  nmigrated_ = 0;
  clear_has_nmigrated();
}
inline ::google::protobuf::int32 BusinessFileInfo::nmigrated() const {
  return nmigrated_;
}
inline void BusinessFileInfo::set_nmigrated(::google::protobuf::int32 value) {
  set_has_nmigrated();
  nmigrated_ = value;
}

// -------------------------------------------------------------------

// BusinessRelateInfo

// required string strBusinessRelateInfoId = 1;
inline bool BusinessRelateInfo::has_strbusinessrelateinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessRelateInfo::set_has_strbusinessrelateinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessRelateInfo::clear_has_strbusinessrelateinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessRelateInfo::clear_strbusinessrelateinfoid() {
  if (strbusinessrelateinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessrelateinfoid_->clear();
  }
  clear_has_strbusinessrelateinfoid();
}
inline const ::std::string& BusinessRelateInfo::strbusinessrelateinfoid() const {
  return *strbusinessrelateinfoid_;
}
inline void BusinessRelateInfo::set_strbusinessrelateinfoid(const ::std::string& value) {
  set_has_strbusinessrelateinfoid();
  if (strbusinessrelateinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessrelateinfoid_ = new ::std::string;
  }
  strbusinessrelateinfoid_->assign(value);
}
inline void BusinessRelateInfo::set_strbusinessrelateinfoid(const char* value) {
  set_has_strbusinessrelateinfoid();
  if (strbusinessrelateinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessrelateinfoid_ = new ::std::string;
  }
  strbusinessrelateinfoid_->assign(value);
}
inline void BusinessRelateInfo::set_strbusinessrelateinfoid(const char* value, size_t size) {
  set_has_strbusinessrelateinfoid();
  if (strbusinessrelateinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessrelateinfoid_ = new ::std::string;
  }
  strbusinessrelateinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessRelateInfo::mutable_strbusinessrelateinfoid() {
  set_has_strbusinessrelateinfoid();
  if (strbusinessrelateinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessrelateinfoid_ = new ::std::string;
  }
  return strbusinessrelateinfoid_;
}
inline ::std::string* BusinessRelateInfo::release_strbusinessrelateinfoid() {
  clear_has_strbusinessrelateinfoid();
  if (strbusinessrelateinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessrelateinfoid_;
    strbusinessrelateinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessRelateInfo::set_allocated_strbusinessrelateinfoid(::std::string* strbusinessrelateinfoid) {
  if (strbusinessrelateinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessrelateinfoid_;
  }
  if (strbusinessrelateinfoid) {
    set_has_strbusinessrelateinfoid();
    strbusinessrelateinfoid_ = strbusinessrelateinfoid;
  } else {
    clear_has_strbusinessrelateinfoid();
    strbusinessrelateinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessInfoId = 2;
inline bool BusinessRelateInfo::has_strbusinessinfoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessRelateInfo::set_has_strbusinessinfoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessRelateInfo::clear_has_strbusinessinfoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessRelateInfo::clear_strbusinessinfoid() {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_->clear();
  }
  clear_has_strbusinessinfoid();
}
inline const ::std::string& BusinessRelateInfo::strbusinessinfoid() const {
  return *strbusinessinfoid_;
}
inline void BusinessRelateInfo::set_strbusinessinfoid(const ::std::string& value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessRelateInfo::set_strbusinessinfoid(const char* value) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(value);
}
inline void BusinessRelateInfo::set_strbusinessinfoid(const char* value, size_t size) {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  strbusinessinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessRelateInfo::mutable_strbusinessinfoid() {
  set_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessinfoid_ = new ::std::string;
  }
  return strbusinessinfoid_;
}
inline ::std::string* BusinessRelateInfo::release_strbusinessinfoid() {
  clear_has_strbusinessinfoid();
  if (strbusinessinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessinfoid_;
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessRelateInfo::set_allocated_strbusinessinfoid(::std::string* strbusinessinfoid) {
  if (strbusinessinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessinfoid_;
  }
  if (strbusinessinfoid) {
    set_has_strbusinessinfoid();
    strbusinessinfoid_ = strbusinessinfoid;
  } else {
    clear_has_strbusinessinfoid();
    strbusinessinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nRelateType = 3;
inline bool BusinessRelateInfo::has_nrelatetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessRelateInfo::set_has_nrelatetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessRelateInfo::clear_has_nrelatetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessRelateInfo::clear_nrelatetype() {
  nrelatetype_ = 0;
  clear_has_nrelatetype();
}
inline ::google::protobuf::int32 BusinessRelateInfo::nrelatetype() const {
  return nrelatetype_;
}
inline void BusinessRelateInfo::set_nrelatetype(::google::protobuf::int32 value) {
  set_has_nrelatetype();
  nrelatetype_ = value;
}

// required string strRelate1 = 4;
inline bool BusinessRelateInfo::has_strrelate1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessRelateInfo::set_has_strrelate1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessRelateInfo::clear_has_strrelate1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessRelateInfo::clear_strrelate1() {
  if (strrelate1_ != &::google::protobuf::internal::kEmptyString) {
    strrelate1_->clear();
  }
  clear_has_strrelate1();
}
inline const ::std::string& BusinessRelateInfo::strrelate1() const {
  return *strrelate1_;
}
inline void BusinessRelateInfo::set_strrelate1(const ::std::string& value) {
  set_has_strrelate1();
  if (strrelate1_ == &::google::protobuf::internal::kEmptyString) {
    strrelate1_ = new ::std::string;
  }
  strrelate1_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate1(const char* value) {
  set_has_strrelate1();
  if (strrelate1_ == &::google::protobuf::internal::kEmptyString) {
    strrelate1_ = new ::std::string;
  }
  strrelate1_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate1(const char* value, size_t size) {
  set_has_strrelate1();
  if (strrelate1_ == &::google::protobuf::internal::kEmptyString) {
    strrelate1_ = new ::std::string;
  }
  strrelate1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessRelateInfo::mutable_strrelate1() {
  set_has_strrelate1();
  if (strrelate1_ == &::google::protobuf::internal::kEmptyString) {
    strrelate1_ = new ::std::string;
  }
  return strrelate1_;
}
inline ::std::string* BusinessRelateInfo::release_strrelate1() {
  clear_has_strrelate1();
  if (strrelate1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrelate1_;
    strrelate1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessRelateInfo::set_allocated_strrelate1(::std::string* strrelate1) {
  if (strrelate1_ != &::google::protobuf::internal::kEmptyString) {
    delete strrelate1_;
  }
  if (strrelate1) {
    set_has_strrelate1();
    strrelate1_ = strrelate1;
  } else {
    clear_has_strrelate1();
    strrelate1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRelate2 = 5;
inline bool BusinessRelateInfo::has_strrelate2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessRelateInfo::set_has_strrelate2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessRelateInfo::clear_has_strrelate2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessRelateInfo::clear_strrelate2() {
  if (strrelate2_ != &::google::protobuf::internal::kEmptyString) {
    strrelate2_->clear();
  }
  clear_has_strrelate2();
}
inline const ::std::string& BusinessRelateInfo::strrelate2() const {
  return *strrelate2_;
}
inline void BusinessRelateInfo::set_strrelate2(const ::std::string& value) {
  set_has_strrelate2();
  if (strrelate2_ == &::google::protobuf::internal::kEmptyString) {
    strrelate2_ = new ::std::string;
  }
  strrelate2_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate2(const char* value) {
  set_has_strrelate2();
  if (strrelate2_ == &::google::protobuf::internal::kEmptyString) {
    strrelate2_ = new ::std::string;
  }
  strrelate2_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate2(const char* value, size_t size) {
  set_has_strrelate2();
  if (strrelate2_ == &::google::protobuf::internal::kEmptyString) {
    strrelate2_ = new ::std::string;
  }
  strrelate2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessRelateInfo::mutable_strrelate2() {
  set_has_strrelate2();
  if (strrelate2_ == &::google::protobuf::internal::kEmptyString) {
    strrelate2_ = new ::std::string;
  }
  return strrelate2_;
}
inline ::std::string* BusinessRelateInfo::release_strrelate2() {
  clear_has_strrelate2();
  if (strrelate2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrelate2_;
    strrelate2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessRelateInfo::set_allocated_strrelate2(::std::string* strrelate2) {
  if (strrelate2_ != &::google::protobuf::internal::kEmptyString) {
    delete strrelate2_;
  }
  if (strrelate2) {
    set_has_strrelate2();
    strrelate2_ = strrelate2;
  } else {
    clear_has_strrelate2();
    strrelate2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRelate3 = 6;
inline bool BusinessRelateInfo::has_strrelate3() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessRelateInfo::set_has_strrelate3() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessRelateInfo::clear_has_strrelate3() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessRelateInfo::clear_strrelate3() {
  if (strrelate3_ != &::google::protobuf::internal::kEmptyString) {
    strrelate3_->clear();
  }
  clear_has_strrelate3();
}
inline const ::std::string& BusinessRelateInfo::strrelate3() const {
  return *strrelate3_;
}
inline void BusinessRelateInfo::set_strrelate3(const ::std::string& value) {
  set_has_strrelate3();
  if (strrelate3_ == &::google::protobuf::internal::kEmptyString) {
    strrelate3_ = new ::std::string;
  }
  strrelate3_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate3(const char* value) {
  set_has_strrelate3();
  if (strrelate3_ == &::google::protobuf::internal::kEmptyString) {
    strrelate3_ = new ::std::string;
  }
  strrelate3_->assign(value);
}
inline void BusinessRelateInfo::set_strrelate3(const char* value, size_t size) {
  set_has_strrelate3();
  if (strrelate3_ == &::google::protobuf::internal::kEmptyString) {
    strrelate3_ = new ::std::string;
  }
  strrelate3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessRelateInfo::mutable_strrelate3() {
  set_has_strrelate3();
  if (strrelate3_ == &::google::protobuf::internal::kEmptyString) {
    strrelate3_ = new ::std::string;
  }
  return strrelate3_;
}
inline ::std::string* BusinessRelateInfo::release_strrelate3() {
  clear_has_strrelate3();
  if (strrelate3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrelate3_;
    strrelate3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessRelateInfo::set_allocated_strrelate3(::std::string* strrelate3) {
  if (strrelate3_ != &::google::protobuf::internal::kEmptyString) {
    delete strrelate3_;
  }
  if (strrelate3) {
    set_has_strrelate3();
    strrelate3_ = strrelate3;
  } else {
    clear_has_strrelate3();
    strrelate3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EmployeeInfo

// required string strEmployeeId = 1;
inline bool EmployeeInfo::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmployeeInfo::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmployeeInfo::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmployeeInfo::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& EmployeeInfo::stremployeeid() const {
  return *stremployeeid_;
}
inline void EmployeeInfo::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void EmployeeInfo::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void EmployeeInfo::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* EmployeeInfo::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBranchId = 2;
inline bool EmployeeInfo::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmployeeInfo::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmployeeInfo::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmployeeInfo::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& EmployeeInfo::strbranchid() const {
  return *strbranchid_;
}
inline void EmployeeInfo::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void EmployeeInfo::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void EmployeeInfo::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* EmployeeInfo::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strName = 3;
inline bool EmployeeInfo::has_strname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmployeeInfo::set_has_strname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmployeeInfo::clear_has_strname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmployeeInfo::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& EmployeeInfo::strname() const {
  return *strname_;
}
inline void EmployeeInfo::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void EmployeeInfo::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void EmployeeInfo::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* EmployeeInfo::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strname(::std::string* strname) {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    delete strname_;
  }
  if (strname) {
    set_has_strname();
    strname_ = strname;
  } else {
    clear_has_strname();
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPassword = 4;
inline bool EmployeeInfo::has_strpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmployeeInfo::set_has_strpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmployeeInfo::clear_has_strpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmployeeInfo::clear_strpassword() {
  if (strpassword_ != &::google::protobuf::internal::kEmptyString) {
    strpassword_->clear();
  }
  clear_has_strpassword();
}
inline const ::std::string& EmployeeInfo::strpassword() const {
  return *strpassword_;
}
inline void EmployeeInfo::set_strpassword(const ::std::string& value) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(value);
}
inline void EmployeeInfo::set_strpassword(const char* value) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(value);
}
inline void EmployeeInfo::set_strpassword(const char* value, size_t size) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strpassword() {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  return strpassword_;
}
inline ::std::string* EmployeeInfo::release_strpassword() {
  clear_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpassword_;
    strpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strpassword(::std::string* strpassword) {
  if (strpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete strpassword_;
  }
  if (strpassword) {
    set_has_strpassword();
    strpassword_ = strpassword;
  } else {
    clear_has_strpassword();
    strpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCardId = 5;
inline bool EmployeeInfo::has_strcardid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmployeeInfo::set_has_strcardid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmployeeInfo::clear_has_strcardid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmployeeInfo::clear_strcardid() {
  if (strcardid_ != &::google::protobuf::internal::kEmptyString) {
    strcardid_->clear();
  }
  clear_has_strcardid();
}
inline const ::std::string& EmployeeInfo::strcardid() const {
  return *strcardid_;
}
inline void EmployeeInfo::set_strcardid(const ::std::string& value) {
  set_has_strcardid();
  if (strcardid_ == &::google::protobuf::internal::kEmptyString) {
    strcardid_ = new ::std::string;
  }
  strcardid_->assign(value);
}
inline void EmployeeInfo::set_strcardid(const char* value) {
  set_has_strcardid();
  if (strcardid_ == &::google::protobuf::internal::kEmptyString) {
    strcardid_ = new ::std::string;
  }
  strcardid_->assign(value);
}
inline void EmployeeInfo::set_strcardid(const char* value, size_t size) {
  set_has_strcardid();
  if (strcardid_ == &::google::protobuf::internal::kEmptyString) {
    strcardid_ = new ::std::string;
  }
  strcardid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strcardid() {
  set_has_strcardid();
  if (strcardid_ == &::google::protobuf::internal::kEmptyString) {
    strcardid_ = new ::std::string;
  }
  return strcardid_;
}
inline ::std::string* EmployeeInfo::release_strcardid() {
  clear_has_strcardid();
  if (strcardid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcardid_;
    strcardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strcardid(::std::string* strcardid) {
  if (strcardid_ != &::google::protobuf::internal::kEmptyString) {
    delete strcardid_;
  }
  if (strcardid) {
    set_has_strcardid();
    strcardid_ = strcardid;
  } else {
    clear_has_strcardid();
    strcardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRoleId = 6;
inline bool EmployeeInfo::has_strroleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmployeeInfo::set_has_strroleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmployeeInfo::clear_has_strroleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmployeeInfo::clear_strroleid() {
  if (strroleid_ != &::google::protobuf::internal::kEmptyString) {
    strroleid_->clear();
  }
  clear_has_strroleid();
}
inline const ::std::string& EmployeeInfo::strroleid() const {
  return *strroleid_;
}
inline void EmployeeInfo::set_strroleid(const ::std::string& value) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(value);
}
inline void EmployeeInfo::set_strroleid(const char* value) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(value);
}
inline void EmployeeInfo::set_strroleid(const char* value, size_t size) {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  strroleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strroleid() {
  set_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    strroleid_ = new ::std::string;
  }
  return strroleid_;
}
inline ::std::string* EmployeeInfo::release_strroleid() {
  clear_has_strroleid();
  if (strroleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strroleid_;
    strroleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strroleid(::std::string* strroleid) {
  if (strroleid_ != &::google::protobuf::internal::kEmptyString) {
    delete strroleid_;
  }
  if (strroleid) {
    set_has_strroleid();
    strroleid_ = strroleid;
  } else {
    clear_has_strroleid();
    strroleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPhone = 7;
inline bool EmployeeInfo::has_strphone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmployeeInfo::set_has_strphone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmployeeInfo::clear_has_strphone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmployeeInfo::clear_strphone() {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    strphone_->clear();
  }
  clear_has_strphone();
}
inline const ::std::string& EmployeeInfo::strphone() const {
  return *strphone_;
}
inline void EmployeeInfo::set_strphone(const ::std::string& value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void EmployeeInfo::set_strphone(const char* value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void EmployeeInfo::set_strphone(const char* value, size_t size) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strphone() {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  return strphone_;
}
inline ::std::string* EmployeeInfo::release_strphone() {
  clear_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strphone_;
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strphone(::std::string* strphone) {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    delete strphone_;
  }
  if (strphone) {
    set_has_strphone();
    strphone_ = strphone;
  } else {
    clear_has_strphone();
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 8;
inline bool EmployeeInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmployeeInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmployeeInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmployeeInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 EmployeeInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void EmployeeInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 9;
inline bool EmployeeInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmployeeInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmployeeInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmployeeInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& EmployeeInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void EmployeeInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void EmployeeInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void EmployeeInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* EmployeeInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 10;
inline bool EmployeeInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmployeeInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmployeeInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmployeeInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& EmployeeInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void EmployeeInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void EmployeeInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void EmployeeInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* EmployeeInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nFlag = 11;
inline bool EmployeeInfo::has_nflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmployeeInfo::set_has_nflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmployeeInfo::clear_has_nflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmployeeInfo::clear_nflag() {
  nflag_ = 0;
  clear_has_nflag();
}
inline ::google::protobuf::int32 EmployeeInfo::nflag() const {
  return nflag_;
}
inline void EmployeeInfo::set_nflag(::google::protobuf::int32 value) {
  set_has_nflag();
  nflag_ = value;
}

// required string stPasswordEidtTime = 12;
inline bool EmployeeInfo::has_stpasswordeidttime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmployeeInfo::set_has_stpasswordeidttime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmployeeInfo::clear_has_stpasswordeidttime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmployeeInfo::clear_stpasswordeidttime() {
  if (stpasswordeidttime_ != &::google::protobuf::internal::kEmptyString) {
    stpasswordeidttime_->clear();
  }
  clear_has_stpasswordeidttime();
}
inline const ::std::string& EmployeeInfo::stpasswordeidttime() const {
  return *stpasswordeidttime_;
}
inline void EmployeeInfo::set_stpasswordeidttime(const ::std::string& value) {
  set_has_stpasswordeidttime();
  if (stpasswordeidttime_ == &::google::protobuf::internal::kEmptyString) {
    stpasswordeidttime_ = new ::std::string;
  }
  stpasswordeidttime_->assign(value);
}
inline void EmployeeInfo::set_stpasswordeidttime(const char* value) {
  set_has_stpasswordeidttime();
  if (stpasswordeidttime_ == &::google::protobuf::internal::kEmptyString) {
    stpasswordeidttime_ = new ::std::string;
  }
  stpasswordeidttime_->assign(value);
}
inline void EmployeeInfo::set_stpasswordeidttime(const char* value, size_t size) {
  set_has_stpasswordeidttime();
  if (stpasswordeidttime_ == &::google::protobuf::internal::kEmptyString) {
    stpasswordeidttime_ = new ::std::string;
  }
  stpasswordeidttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_stpasswordeidttime() {
  set_has_stpasswordeidttime();
  if (stpasswordeidttime_ == &::google::protobuf::internal::kEmptyString) {
    stpasswordeidttime_ = new ::std::string;
  }
  return stpasswordeidttime_;
}
inline ::std::string* EmployeeInfo::release_stpasswordeidttime() {
  clear_has_stpasswordeidttime();
  if (stpasswordeidttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stpasswordeidttime_;
    stpasswordeidttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_stpasswordeidttime(::std::string* stpasswordeidttime) {
  if (stpasswordeidttime_ != &::google::protobuf::internal::kEmptyString) {
    delete stpasswordeidttime_;
  }
  if (stpasswordeidttime) {
    set_has_stpasswordeidttime();
    stpasswordeidttime_ = stpasswordeidttime;
  } else {
    clear_has_stpasswordeidttime();
    stpasswordeidttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strJDBRID = 13;
inline bool EmployeeInfo::has_strjdbrid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmployeeInfo::set_has_strjdbrid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmployeeInfo::clear_has_strjdbrid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmployeeInfo::clear_strjdbrid() {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    strjdbrid_->clear();
  }
  clear_has_strjdbrid();
}
inline const ::std::string& EmployeeInfo::strjdbrid() const {
  return *strjdbrid_;
}
inline void EmployeeInfo::set_strjdbrid(const ::std::string& value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void EmployeeInfo::set_strjdbrid(const char* value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void EmployeeInfo::set_strjdbrid(const char* value, size_t size) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strjdbrid() {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  return strjdbrid_;
}
inline ::std::string* EmployeeInfo::release_strjdbrid() {
  clear_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strjdbrid_;
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strjdbrid(::std::string* strjdbrid) {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    delete strjdbrid_;
  }
  if (strjdbrid) {
    set_has_strjdbrid();
    strjdbrid_ = strjdbrid;
  } else {
    clear_has_strjdbrid();
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTLNUM = 14;
inline bool EmployeeInfo::has_strtlnum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmployeeInfo::set_has_strtlnum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmployeeInfo::clear_has_strtlnum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmployeeInfo::clear_strtlnum() {
  if (strtlnum_ != &::google::protobuf::internal::kEmptyString) {
    strtlnum_->clear();
  }
  clear_has_strtlnum();
}
inline const ::std::string& EmployeeInfo::strtlnum() const {
  return *strtlnum_;
}
inline void EmployeeInfo::set_strtlnum(const ::std::string& value) {
  set_has_strtlnum();
  if (strtlnum_ == &::google::protobuf::internal::kEmptyString) {
    strtlnum_ = new ::std::string;
  }
  strtlnum_->assign(value);
}
inline void EmployeeInfo::set_strtlnum(const char* value) {
  set_has_strtlnum();
  if (strtlnum_ == &::google::protobuf::internal::kEmptyString) {
    strtlnum_ = new ::std::string;
  }
  strtlnum_->assign(value);
}
inline void EmployeeInfo::set_strtlnum(const char* value, size_t size) {
  set_has_strtlnum();
  if (strtlnum_ == &::google::protobuf::internal::kEmptyString) {
    strtlnum_ = new ::std::string;
  }
  strtlnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strtlnum() {
  set_has_strtlnum();
  if (strtlnum_ == &::google::protobuf::internal::kEmptyString) {
    strtlnum_ = new ::std::string;
  }
  return strtlnum_;
}
inline ::std::string* EmployeeInfo::release_strtlnum() {
  clear_has_strtlnum();
  if (strtlnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtlnum_;
    strtlnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strtlnum(::std::string* strtlnum) {
  if (strtlnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strtlnum_;
  }
  if (strtlnum) {
    set_has_strtlnum();
    strtlnum_ = strtlnum;
  } else {
    clear_has_strtlnum();
    strtlnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTEL = 15;
inline bool EmployeeInfo::has_strtel() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmployeeInfo::set_has_strtel() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmployeeInfo::clear_has_strtel() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmployeeInfo::clear_strtel() {
  if (strtel_ != &::google::protobuf::internal::kEmptyString) {
    strtel_->clear();
  }
  clear_has_strtel();
}
inline const ::std::string& EmployeeInfo::strtel() const {
  return *strtel_;
}
inline void EmployeeInfo::set_strtel(const ::std::string& value) {
  set_has_strtel();
  if (strtel_ == &::google::protobuf::internal::kEmptyString) {
    strtel_ = new ::std::string;
  }
  strtel_->assign(value);
}
inline void EmployeeInfo::set_strtel(const char* value) {
  set_has_strtel();
  if (strtel_ == &::google::protobuf::internal::kEmptyString) {
    strtel_ = new ::std::string;
  }
  strtel_->assign(value);
}
inline void EmployeeInfo::set_strtel(const char* value, size_t size) {
  set_has_strtel();
  if (strtel_ == &::google::protobuf::internal::kEmptyString) {
    strtel_ = new ::std::string;
  }
  strtel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strtel() {
  set_has_strtel();
  if (strtel_ == &::google::protobuf::internal::kEmptyString) {
    strtel_ = new ::std::string;
  }
  return strtel_;
}
inline ::std::string* EmployeeInfo::release_strtel() {
  clear_has_strtel();
  if (strtel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtel_;
    strtel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strtel(::std::string* strtel) {
  if (strtel_ != &::google::protobuf::internal::kEmptyString) {
    delete strtel_;
  }
  if (strtel) {
    set_has_strtel();
    strtel_ = strtel;
  } else {
    clear_has_strtel();
    strtel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strGW = 16;
inline bool EmployeeInfo::has_strgw() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmployeeInfo::set_has_strgw() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmployeeInfo::clear_has_strgw() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmployeeInfo::clear_strgw() {
  if (strgw_ != &::google::protobuf::internal::kEmptyString) {
    strgw_->clear();
  }
  clear_has_strgw();
}
inline const ::std::string& EmployeeInfo::strgw() const {
  return *strgw_;
}
inline void EmployeeInfo::set_strgw(const ::std::string& value) {
  set_has_strgw();
  if (strgw_ == &::google::protobuf::internal::kEmptyString) {
    strgw_ = new ::std::string;
  }
  strgw_->assign(value);
}
inline void EmployeeInfo::set_strgw(const char* value) {
  set_has_strgw();
  if (strgw_ == &::google::protobuf::internal::kEmptyString) {
    strgw_ = new ::std::string;
  }
  strgw_->assign(value);
}
inline void EmployeeInfo::set_strgw(const char* value, size_t size) {
  set_has_strgw();
  if (strgw_ == &::google::protobuf::internal::kEmptyString) {
    strgw_ = new ::std::string;
  }
  strgw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strgw() {
  set_has_strgw();
  if (strgw_ == &::google::protobuf::internal::kEmptyString) {
    strgw_ = new ::std::string;
  }
  return strgw_;
}
inline ::std::string* EmployeeInfo::release_strgw() {
  clear_has_strgw();
  if (strgw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgw_;
    strgw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strgw(::std::string* strgw) {
  if (strgw_ != &::google::protobuf::internal::kEmptyString) {
    delete strgw_;
  }
  if (strgw) {
    set_has_strgw();
    strgw_ = strgw;
  } else {
    clear_has_strgw();
    strgw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSTS = 17;
inline bool EmployeeInfo::has_strsts() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EmployeeInfo::set_has_strsts() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EmployeeInfo::clear_has_strsts() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EmployeeInfo::clear_strsts() {
  if (strsts_ != &::google::protobuf::internal::kEmptyString) {
    strsts_->clear();
  }
  clear_has_strsts();
}
inline const ::std::string& EmployeeInfo::strsts() const {
  return *strsts_;
}
inline void EmployeeInfo::set_strsts(const ::std::string& value) {
  set_has_strsts();
  if (strsts_ == &::google::protobuf::internal::kEmptyString) {
    strsts_ = new ::std::string;
  }
  strsts_->assign(value);
}
inline void EmployeeInfo::set_strsts(const char* value) {
  set_has_strsts();
  if (strsts_ == &::google::protobuf::internal::kEmptyString) {
    strsts_ = new ::std::string;
  }
  strsts_->assign(value);
}
inline void EmployeeInfo::set_strsts(const char* value, size_t size) {
  set_has_strsts();
  if (strsts_ == &::google::protobuf::internal::kEmptyString) {
    strsts_ = new ::std::string;
  }
  strsts_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strsts() {
  set_has_strsts();
  if (strsts_ == &::google::protobuf::internal::kEmptyString) {
    strsts_ = new ::std::string;
  }
  return strsts_;
}
inline ::std::string* EmployeeInfo::release_strsts() {
  clear_has_strsts();
  if (strsts_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsts_;
    strsts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strsts(::std::string* strsts) {
  if (strsts_ != &::google::protobuf::internal::kEmptyString) {
    delete strsts_;
  }
  if (strsts) {
    set_has_strsts();
    strsts_ = strsts;
  } else {
    clear_has_strsts();
    strsts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTLINST = 18;
inline bool EmployeeInfo::has_strtlinst() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EmployeeInfo::set_has_strtlinst() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EmployeeInfo::clear_has_strtlinst() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EmployeeInfo::clear_strtlinst() {
  if (strtlinst_ != &::google::protobuf::internal::kEmptyString) {
    strtlinst_->clear();
  }
  clear_has_strtlinst();
}
inline const ::std::string& EmployeeInfo::strtlinst() const {
  return *strtlinst_;
}
inline void EmployeeInfo::set_strtlinst(const ::std::string& value) {
  set_has_strtlinst();
  if (strtlinst_ == &::google::protobuf::internal::kEmptyString) {
    strtlinst_ = new ::std::string;
  }
  strtlinst_->assign(value);
}
inline void EmployeeInfo::set_strtlinst(const char* value) {
  set_has_strtlinst();
  if (strtlinst_ == &::google::protobuf::internal::kEmptyString) {
    strtlinst_ = new ::std::string;
  }
  strtlinst_->assign(value);
}
inline void EmployeeInfo::set_strtlinst(const char* value, size_t size) {
  set_has_strtlinst();
  if (strtlinst_ == &::google::protobuf::internal::kEmptyString) {
    strtlinst_ = new ::std::string;
  }
  strtlinst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strtlinst() {
  set_has_strtlinst();
  if (strtlinst_ == &::google::protobuf::internal::kEmptyString) {
    strtlinst_ = new ::std::string;
  }
  return strtlinst_;
}
inline ::std::string* EmployeeInfo::release_strtlinst() {
  clear_has_strtlinst();
  if (strtlinst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtlinst_;
    strtlinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strtlinst(::std::string* strtlinst) {
  if (strtlinst_ != &::google::protobuf::internal::kEmptyString) {
    delete strtlinst_;
  }
  if (strtlinst) {
    set_has_strtlinst();
    strtlinst_ = strtlinst;
  } else {
    clear_has_strtlinst();
    strtlinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strUSERNAME = 19;
inline bool EmployeeInfo::has_strusername() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EmployeeInfo::set_has_strusername() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EmployeeInfo::clear_has_strusername() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EmployeeInfo::clear_strusername() {
  if (strusername_ != &::google::protobuf::internal::kEmptyString) {
    strusername_->clear();
  }
  clear_has_strusername();
}
inline const ::std::string& EmployeeInfo::strusername() const {
  return *strusername_;
}
inline void EmployeeInfo::set_strusername(const ::std::string& value) {
  set_has_strusername();
  if (strusername_ == &::google::protobuf::internal::kEmptyString) {
    strusername_ = new ::std::string;
  }
  strusername_->assign(value);
}
inline void EmployeeInfo::set_strusername(const char* value) {
  set_has_strusername();
  if (strusername_ == &::google::protobuf::internal::kEmptyString) {
    strusername_ = new ::std::string;
  }
  strusername_->assign(value);
}
inline void EmployeeInfo::set_strusername(const char* value, size_t size) {
  set_has_strusername();
  if (strusername_ == &::google::protobuf::internal::kEmptyString) {
    strusername_ = new ::std::string;
  }
  strusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strusername() {
  set_has_strusername();
  if (strusername_ == &::google::protobuf::internal::kEmptyString) {
    strusername_ = new ::std::string;
  }
  return strusername_;
}
inline ::std::string* EmployeeInfo::release_strusername() {
  clear_has_strusername();
  if (strusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strusername_;
    strusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strusername(::std::string* strusername) {
  if (strusername_ != &::google::protobuf::internal::kEmptyString) {
    delete strusername_;
  }
  if (strusername) {
    set_has_strusername();
    strusername_ = strusername;
  } else {
    clear_has_strusername();
    strusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strROLENAME = 20;
inline bool EmployeeInfo::has_strrolename() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EmployeeInfo::set_has_strrolename() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EmployeeInfo::clear_has_strrolename() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EmployeeInfo::clear_strrolename() {
  if (strrolename_ != &::google::protobuf::internal::kEmptyString) {
    strrolename_->clear();
  }
  clear_has_strrolename();
}
inline const ::std::string& EmployeeInfo::strrolename() const {
  return *strrolename_;
}
inline void EmployeeInfo::set_strrolename(const ::std::string& value) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(value);
}
inline void EmployeeInfo::set_strrolename(const char* value) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(value);
}
inline void EmployeeInfo::set_strrolename(const char* value, size_t size) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_strrolename() {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  return strrolename_;
}
inline ::std::string* EmployeeInfo::release_strrolename() {
  clear_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrolename_;
    strrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_strrolename(::std::string* strrolename) {
  if (strrolename_ != &::google::protobuf::internal::kEmptyString) {
    delete strrolename_;
  }
  if (strrolename) {
    set_has_strrolename();
    strrolename_ = strrolename;
  } else {
    clear_has_strrolename();
    strrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strUSERSTATUS = 21;
inline bool EmployeeInfo::has_struserstatus() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EmployeeInfo::set_has_struserstatus() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EmployeeInfo::clear_has_struserstatus() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EmployeeInfo::clear_struserstatus() {
  if (struserstatus_ != &::google::protobuf::internal::kEmptyString) {
    struserstatus_->clear();
  }
  clear_has_struserstatus();
}
inline const ::std::string& EmployeeInfo::struserstatus() const {
  return *struserstatus_;
}
inline void EmployeeInfo::set_struserstatus(const ::std::string& value) {
  set_has_struserstatus();
  if (struserstatus_ == &::google::protobuf::internal::kEmptyString) {
    struserstatus_ = new ::std::string;
  }
  struserstatus_->assign(value);
}
inline void EmployeeInfo::set_struserstatus(const char* value) {
  set_has_struserstatus();
  if (struserstatus_ == &::google::protobuf::internal::kEmptyString) {
    struserstatus_ = new ::std::string;
  }
  struserstatus_->assign(value);
}
inline void EmployeeInfo::set_struserstatus(const char* value, size_t size) {
  set_has_struserstatus();
  if (struserstatus_ == &::google::protobuf::internal::kEmptyString) {
    struserstatus_ = new ::std::string;
  }
  struserstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeeInfo::mutable_struserstatus() {
  set_has_struserstatus();
  if (struserstatus_ == &::google::protobuf::internal::kEmptyString) {
    struserstatus_ = new ::std::string;
  }
  return struserstatus_;
}
inline ::std::string* EmployeeInfo::release_struserstatus() {
  clear_has_struserstatus();
  if (struserstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = struserstatus_;
    struserstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_struserstatus(::std::string* struserstatus) {
  if (struserstatus_ != &::google::protobuf::internal::kEmptyString) {
    delete struserstatus_;
  }
  if (struserstatus) {
    set_has_struserstatus();
    struserstatus_ = struserstatus;
  } else {
    clear_has_struserstatus();
    struserstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPassErrorCount = 22;
inline bool EmployeeInfo::has_npasserrorcount() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EmployeeInfo::set_has_npasserrorcount() {
  _has_bits_[0] |= 0x00200000u;
}
inline void EmployeeInfo::clear_has_npasserrorcount() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void EmployeeInfo::clear_npasserrorcount() {
  npasserrorcount_ = 0;
  clear_has_npasserrorcount();
}
inline ::google::protobuf::int32 EmployeeInfo::npasserrorcount() const {
  return npasserrorcount_;
}
inline void EmployeeInfo::set_npasserrorcount(::google::protobuf::int32 value) {
  set_has_npasserrorcount();
  npasserrorcount_ = value;
}

// -------------------------------------------------------------------

// EmployeePurviewInfo

// required string strEmployeePurviewId = 1;
inline bool EmployeePurviewInfo::has_stremployeepurviewid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmployeePurviewInfo::set_has_stremployeepurviewid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmployeePurviewInfo::clear_has_stremployeepurviewid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmployeePurviewInfo::clear_stremployeepurviewid() {
  if (stremployeepurviewid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeepurviewid_->clear();
  }
  clear_has_stremployeepurviewid();
}
inline const ::std::string& EmployeePurviewInfo::stremployeepurviewid() const {
  return *stremployeepurviewid_;
}
inline void EmployeePurviewInfo::set_stremployeepurviewid(const ::std::string& value) {
  set_has_stremployeepurviewid();
  if (stremployeepurviewid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeepurviewid_ = new ::std::string;
  }
  stremployeepurviewid_->assign(value);
}
inline void EmployeePurviewInfo::set_stremployeepurviewid(const char* value) {
  set_has_stremployeepurviewid();
  if (stremployeepurviewid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeepurviewid_ = new ::std::string;
  }
  stremployeepurviewid_->assign(value);
}
inline void EmployeePurviewInfo::set_stremployeepurviewid(const char* value, size_t size) {
  set_has_stremployeepurviewid();
  if (stremployeepurviewid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeepurviewid_ = new ::std::string;
  }
  stremployeepurviewid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeePurviewInfo::mutable_stremployeepurviewid() {
  set_has_stremployeepurviewid();
  if (stremployeepurviewid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeepurviewid_ = new ::std::string;
  }
  return stremployeepurviewid_;
}
inline ::std::string* EmployeePurviewInfo::release_stremployeepurviewid() {
  clear_has_stremployeepurviewid();
  if (stremployeepurviewid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeepurviewid_;
    stremployeepurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeePurviewInfo::set_allocated_stremployeepurviewid(::std::string* stremployeepurviewid) {
  if (stremployeepurviewid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeepurviewid_;
  }
  if (stremployeepurviewid) {
    set_has_stremployeepurviewid();
    stremployeepurviewid_ = stremployeepurviewid;
  } else {
    clear_has_stremployeepurviewid();
    stremployeepurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeId = 2;
inline bool EmployeePurviewInfo::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmployeePurviewInfo::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmployeePurviewInfo::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmployeePurviewInfo::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& EmployeePurviewInfo::stremployeeid() const {
  return *stremployeeid_;
}
inline void EmployeePurviewInfo::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void EmployeePurviewInfo::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void EmployeePurviewInfo::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeePurviewInfo::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* EmployeePurviewInfo::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeePurviewInfo::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPurviewInfoId = 3;
inline bool EmployeePurviewInfo::has_strpurviewinfoid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmployeePurviewInfo::set_has_strpurviewinfoid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmployeePurviewInfo::clear_has_strpurviewinfoid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmployeePurviewInfo::clear_strpurviewinfoid() {
  if (strpurviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_->clear();
  }
  clear_has_strpurviewinfoid();
}
inline const ::std::string& EmployeePurviewInfo::strpurviewinfoid() const {
  return *strpurviewinfoid_;
}
inline void EmployeePurviewInfo::set_strpurviewinfoid(const ::std::string& value) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(value);
}
inline void EmployeePurviewInfo::set_strpurviewinfoid(const char* value) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(value);
}
inline void EmployeePurviewInfo::set_strpurviewinfoid(const char* value, size_t size) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeePurviewInfo::mutable_strpurviewinfoid() {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  return strpurviewinfoid_;
}
inline ::std::string* EmployeePurviewInfo::release_strpurviewinfoid() {
  clear_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpurviewinfoid_;
    strpurviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeePurviewInfo::set_allocated_strpurviewinfoid(::std::string* strpurviewinfoid) {
  if (strpurviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strpurviewinfoid_;
  }
  if (strpurviewinfoid) {
    set_has_strpurviewinfoid();
    strpurviewinfoid_ = strpurviewinfoid;
  } else {
    clear_has_strpurviewinfoid();
    strpurviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 4;
inline bool EmployeePurviewInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmployeePurviewInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmployeePurviewInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmployeePurviewInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 EmployeePurviewInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void EmployeePurviewInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 5;
inline bool EmployeePurviewInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmployeePurviewInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmployeePurviewInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmployeePurviewInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& EmployeePurviewInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void EmployeePurviewInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void EmployeePurviewInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void EmployeePurviewInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeePurviewInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* EmployeePurviewInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeePurviewInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 6;
inline bool EmployeePurviewInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmployeePurviewInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmployeePurviewInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmployeePurviewInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& EmployeePurviewInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void EmployeePurviewInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void EmployeePurviewInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void EmployeePurviewInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmployeePurviewInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* EmployeePurviewInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmployeePurviewInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EmployeePurviewInfoList

// required int32 nEmployeePurviewSize = 1;
inline bool EmployeePurviewInfoList::has_nemployeepurviewsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmployeePurviewInfoList::set_has_nemployeepurviewsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmployeePurviewInfoList::clear_has_nemployeepurviewsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmployeePurviewInfoList::clear_nemployeepurviewsize() {
  nemployeepurviewsize_ = 0;
  clear_has_nemployeepurviewsize();
}
inline ::google::protobuf::int32 EmployeePurviewInfoList::nemployeepurviewsize() const {
  return nemployeepurviewsize_;
}
inline void EmployeePurviewInfoList::set_nemployeepurviewsize(::google::protobuf::int32 value) {
  set_has_nemployeepurviewsize();
  nemployeepurviewsize_ = value;
}

// repeated .BFIS.EmployeePurviewInfo vecEmployeePurview = 2;
inline int EmployeePurviewInfoList::vecemployeepurview_size() const {
  return vecemployeepurview_.size();
}
inline void EmployeePurviewInfoList::clear_vecemployeepurview() {
  vecemployeepurview_.Clear();
}
inline const ::BFIS::EmployeePurviewInfo& EmployeePurviewInfoList::vecemployeepurview(int index) const {
  return vecemployeepurview_.Get(index);
}
inline ::BFIS::EmployeePurviewInfo* EmployeePurviewInfoList::mutable_vecemployeepurview(int index) {
  return vecemployeepurview_.Mutable(index);
}
inline ::BFIS::EmployeePurviewInfo* EmployeePurviewInfoList::add_vecemployeepurview() {
  return vecemployeepurview_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BFIS::EmployeePurviewInfo >&
EmployeePurviewInfoList::vecemployeepurview() const {
  return vecemployeepurview_;
}
inline ::google::protobuf::RepeatedPtrField< ::BFIS::EmployeePurviewInfo >*
EmployeePurviewInfoList::mutable_vecemployeepurview() {
  return &vecemployeepurview_;
}

// optional int32 nStateSign = 3 [default = 0];
inline bool EmployeePurviewInfoList::has_nstatesign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmployeePurviewInfoList::set_has_nstatesign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmployeePurviewInfoList::clear_has_nstatesign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmployeePurviewInfoList::clear_nstatesign() {
  nstatesign_ = 0;
  clear_has_nstatesign();
}
inline ::google::protobuf::int32 EmployeePurviewInfoList::nstatesign() const {
  return nstatesign_;
}
inline void EmployeePurviewInfoList::set_nstatesign(::google::protobuf::int32 value) {
  set_has_nstatesign();
  nstatesign_ = value;
}

// optional int32 nReserved = 4 [default = 0];
inline bool EmployeePurviewInfoList::has_nreserved() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmployeePurviewInfoList::set_has_nreserved() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmployeePurviewInfoList::clear_has_nreserved() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmployeePurviewInfoList::clear_nreserved() {
  nreserved_ = 0;
  clear_has_nreserved();
}
inline ::google::protobuf::int32 EmployeePurviewInfoList::nreserved() const {
  return nreserved_;
}
inline void EmployeePurviewInfoList::set_nreserved(::google::protobuf::int32 value) {
  set_has_nreserved();
  nreserved_ = value;
}

// -------------------------------------------------------------------

// PurviewInfo

// required string strPurviewInfoId = 1;
inline bool PurviewInfo::has_strpurviewinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PurviewInfo::set_has_strpurviewinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PurviewInfo::clear_has_strpurviewinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PurviewInfo::clear_strpurviewinfoid() {
  if (strpurviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_->clear();
  }
  clear_has_strpurviewinfoid();
}
inline const ::std::string& PurviewInfo::strpurviewinfoid() const {
  return *strpurviewinfoid_;
}
inline void PurviewInfo::set_strpurviewinfoid(const ::std::string& value) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(value);
}
inline void PurviewInfo::set_strpurviewinfoid(const char* value) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(value);
}
inline void PurviewInfo::set_strpurviewinfoid(const char* value, size_t size) {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  strpurviewinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strpurviewinfoid() {
  set_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewinfoid_ = new ::std::string;
  }
  return strpurviewinfoid_;
}
inline ::std::string* PurviewInfo::release_strpurviewinfoid() {
  clear_has_strpurviewinfoid();
  if (strpurviewinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpurviewinfoid_;
    strpurviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strpurviewinfoid(::std::string* strpurviewinfoid) {
  if (strpurviewinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strpurviewinfoid_;
  }
  if (strpurviewinfoid) {
    set_has_strpurviewinfoid();
    strpurviewinfoid_ = strpurviewinfoid;
  } else {
    clear_has_strpurviewinfoid();
    strpurviewinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strParentPurviewId = 2;
inline bool PurviewInfo::has_strparentpurviewid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PurviewInfo::set_has_strparentpurviewid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PurviewInfo::clear_has_strparentpurviewid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PurviewInfo::clear_strparentpurviewid() {
  if (strparentpurviewid_ != &::google::protobuf::internal::kEmptyString) {
    strparentpurviewid_->clear();
  }
  clear_has_strparentpurviewid();
}
inline const ::std::string& PurviewInfo::strparentpurviewid() const {
  return *strparentpurviewid_;
}
inline void PurviewInfo::set_strparentpurviewid(const ::std::string& value) {
  set_has_strparentpurviewid();
  if (strparentpurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strparentpurviewid_ = new ::std::string;
  }
  strparentpurviewid_->assign(value);
}
inline void PurviewInfo::set_strparentpurviewid(const char* value) {
  set_has_strparentpurviewid();
  if (strparentpurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strparentpurviewid_ = new ::std::string;
  }
  strparentpurviewid_->assign(value);
}
inline void PurviewInfo::set_strparentpurviewid(const char* value, size_t size) {
  set_has_strparentpurviewid();
  if (strparentpurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strparentpurviewid_ = new ::std::string;
  }
  strparentpurviewid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strparentpurviewid() {
  set_has_strparentpurviewid();
  if (strparentpurviewid_ == &::google::protobuf::internal::kEmptyString) {
    strparentpurviewid_ = new ::std::string;
  }
  return strparentpurviewid_;
}
inline ::std::string* PurviewInfo::release_strparentpurviewid() {
  clear_has_strparentpurviewid();
  if (strparentpurviewid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparentpurviewid_;
    strparentpurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strparentpurviewid(::std::string* strparentpurviewid) {
  if (strparentpurviewid_ != &::google::protobuf::internal::kEmptyString) {
    delete strparentpurviewid_;
  }
  if (strparentpurviewid) {
    set_has_strparentpurviewid();
    strparentpurviewid_ = strparentpurviewid;
  } else {
    clear_has_strparentpurviewid();
    strparentpurviewid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPurviewCode = 3;
inline bool PurviewInfo::has_strpurviewcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PurviewInfo::set_has_strpurviewcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PurviewInfo::clear_has_strpurviewcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PurviewInfo::clear_strpurviewcode() {
  if (strpurviewcode_ != &::google::protobuf::internal::kEmptyString) {
    strpurviewcode_->clear();
  }
  clear_has_strpurviewcode();
}
inline const ::std::string& PurviewInfo::strpurviewcode() const {
  return *strpurviewcode_;
}
inline void PurviewInfo::set_strpurviewcode(const ::std::string& value) {
  set_has_strpurviewcode();
  if (strpurviewcode_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewcode_ = new ::std::string;
  }
  strpurviewcode_->assign(value);
}
inline void PurviewInfo::set_strpurviewcode(const char* value) {
  set_has_strpurviewcode();
  if (strpurviewcode_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewcode_ = new ::std::string;
  }
  strpurviewcode_->assign(value);
}
inline void PurviewInfo::set_strpurviewcode(const char* value, size_t size) {
  set_has_strpurviewcode();
  if (strpurviewcode_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewcode_ = new ::std::string;
  }
  strpurviewcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strpurviewcode() {
  set_has_strpurviewcode();
  if (strpurviewcode_ == &::google::protobuf::internal::kEmptyString) {
    strpurviewcode_ = new ::std::string;
  }
  return strpurviewcode_;
}
inline ::std::string* PurviewInfo::release_strpurviewcode() {
  clear_has_strpurviewcode();
  if (strpurviewcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpurviewcode_;
    strpurviewcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strpurviewcode(::std::string* strpurviewcode) {
  if (strpurviewcode_ != &::google::protobuf::internal::kEmptyString) {
    delete strpurviewcode_;
  }
  if (strpurviewcode) {
    set_has_strpurviewcode();
    strpurviewcode_ = strpurviewcode;
  } else {
    clear_has_strpurviewcode();
    strpurviewcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strDescription = 4;
inline bool PurviewInfo::has_strdescription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PurviewInfo::set_has_strdescription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PurviewInfo::clear_has_strdescription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PurviewInfo::clear_strdescription() {
  if (strdescription_ != &::google::protobuf::internal::kEmptyString) {
    strdescription_->clear();
  }
  clear_has_strdescription();
}
inline const ::std::string& PurviewInfo::strdescription() const {
  return *strdescription_;
}
inline void PurviewInfo::set_strdescription(const ::std::string& value) {
  set_has_strdescription();
  if (strdescription_ == &::google::protobuf::internal::kEmptyString) {
    strdescription_ = new ::std::string;
  }
  strdescription_->assign(value);
}
inline void PurviewInfo::set_strdescription(const char* value) {
  set_has_strdescription();
  if (strdescription_ == &::google::protobuf::internal::kEmptyString) {
    strdescription_ = new ::std::string;
  }
  strdescription_->assign(value);
}
inline void PurviewInfo::set_strdescription(const char* value, size_t size) {
  set_has_strdescription();
  if (strdescription_ == &::google::protobuf::internal::kEmptyString) {
    strdescription_ = new ::std::string;
  }
  strdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strdescription() {
  set_has_strdescription();
  if (strdescription_ == &::google::protobuf::internal::kEmptyString) {
    strdescription_ = new ::std::string;
  }
  return strdescription_;
}
inline ::std::string* PurviewInfo::release_strdescription() {
  clear_has_strdescription();
  if (strdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdescription_;
    strdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strdescription(::std::string* strdescription) {
  if (strdescription_ != &::google::protobuf::internal::kEmptyString) {
    delete strdescription_;
  }
  if (strdescription) {
    set_has_strdescription();
    strdescription_ = strdescription;
  } else {
    clear_has_strdescription();
    strdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo1 = 5;
inline bool PurviewInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PurviewInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PurviewInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PurviewInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& PurviewInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void PurviewInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void PurviewInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void PurviewInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* PurviewInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 6;
inline bool PurviewInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PurviewInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PurviewInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PurviewInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& PurviewInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void PurviewInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void PurviewInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void PurviewInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PurviewInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* PurviewInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PurviewInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoleInfo

// required string strRoleInfoId = 1;
inline bool RoleInfo::has_strroleinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleInfo::set_has_strroleinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleInfo::clear_has_strroleinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleInfo::clear_strroleinfoid() {
  if (strroleinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strroleinfoid_->clear();
  }
  clear_has_strroleinfoid();
}
inline const ::std::string& RoleInfo::strroleinfoid() const {
  return *strroleinfoid_;
}
inline void RoleInfo::set_strroleinfoid(const ::std::string& value) {
  set_has_strroleinfoid();
  if (strroleinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfoid_ = new ::std::string;
  }
  strroleinfoid_->assign(value);
}
inline void RoleInfo::set_strroleinfoid(const char* value) {
  set_has_strroleinfoid();
  if (strroleinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfoid_ = new ::std::string;
  }
  strroleinfoid_->assign(value);
}
inline void RoleInfo::set_strroleinfoid(const char* value, size_t size) {
  set_has_strroleinfoid();
  if (strroleinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfoid_ = new ::std::string;
  }
  strroleinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_strroleinfoid() {
  set_has_strroleinfoid();
  if (strroleinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strroleinfoid_ = new ::std::string;
  }
  return strroleinfoid_;
}
inline ::std::string* RoleInfo::release_strroleinfoid() {
  clear_has_strroleinfoid();
  if (strroleinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strroleinfoid_;
    strroleinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_strroleinfoid(::std::string* strroleinfoid) {
  if (strroleinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strroleinfoid_;
  }
  if (strroleinfoid) {
    set_has_strroleinfoid();
    strroleinfoid_ = strroleinfoid;
  } else {
    clear_has_strroleinfoid();
    strroleinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRoleName = 2;
inline bool RoleInfo::has_strrolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleInfo::set_has_strrolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleInfo::clear_has_strrolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleInfo::clear_strrolename() {
  if (strrolename_ != &::google::protobuf::internal::kEmptyString) {
    strrolename_->clear();
  }
  clear_has_strrolename();
}
inline const ::std::string& RoleInfo::strrolename() const {
  return *strrolename_;
}
inline void RoleInfo::set_strrolename(const ::std::string& value) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(value);
}
inline void RoleInfo::set_strrolename(const char* value) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(value);
}
inline void RoleInfo::set_strrolename(const char* value, size_t size) {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  strrolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_strrolename() {
  set_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    strrolename_ = new ::std::string;
  }
  return strrolename_;
}
inline ::std::string* RoleInfo::release_strrolename() {
  clear_has_strrolename();
  if (strrolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrolename_;
    strrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_strrolename(::std::string* strrolename) {
  if (strrolename_ != &::google::protobuf::internal::kEmptyString) {
    delete strrolename_;
  }
  if (strrolename) {
    set_has_strrolename();
    strrolename_ = strrolename;
  } else {
    clear_has_strrolename();
    strrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nRoleLevel = 3;
inline bool RoleInfo::has_nrolelevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleInfo::set_has_nrolelevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleInfo::clear_has_nrolelevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleInfo::clear_nrolelevel() {
  nrolelevel_ = 0;
  clear_has_nrolelevel();
}
inline ::google::protobuf::int32 RoleInfo::nrolelevel() const {
  return nrolelevel_;
}
inline void RoleInfo::set_nrolelevel(::google::protobuf::int32 value) {
  set_has_nrolelevel();
  nrolelevel_ = value;
}

// required int32 nExtendedInfo = 4;
inline bool RoleInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 RoleInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void RoleInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 5;
inline bool RoleInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& RoleInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void RoleInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void RoleInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void RoleInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* RoleInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 6;
inline bool RoleInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& RoleInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void RoleInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void RoleInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void RoleInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* RoleInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBranchInfoId = 7;
inline bool RoleInfo::has_strbranchinfoid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoleInfo::set_has_strbranchinfoid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoleInfo::clear_has_strbranchinfoid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoleInfo::clear_strbranchinfoid() {
  if (strbranchinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchinfoid_->clear();
  }
  clear_has_strbranchinfoid();
}
inline const ::std::string& RoleInfo::strbranchinfoid() const {
  return *strbranchinfoid_;
}
inline void RoleInfo::set_strbranchinfoid(const ::std::string& value) {
  set_has_strbranchinfoid();
  if (strbranchinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchinfoid_ = new ::std::string;
  }
  strbranchinfoid_->assign(value);
}
inline void RoleInfo::set_strbranchinfoid(const char* value) {
  set_has_strbranchinfoid();
  if (strbranchinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchinfoid_ = new ::std::string;
  }
  strbranchinfoid_->assign(value);
}
inline void RoleInfo::set_strbranchinfoid(const char* value, size_t size) {
  set_has_strbranchinfoid();
  if (strbranchinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchinfoid_ = new ::std::string;
  }
  strbranchinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_strbranchinfoid() {
  set_has_strbranchinfoid();
  if (strbranchinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchinfoid_ = new ::std::string;
  }
  return strbranchinfoid_;
}
inline ::std::string* RoleInfo::release_strbranchinfoid() {
  clear_has_strbranchinfoid();
  if (strbranchinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchinfoid_;
    strbranchinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_strbranchinfoid(::std::string* strbranchinfoid) {
  if (strbranchinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchinfoid_;
  }
  if (strbranchinfoid) {
    set_has_strbranchinfoid();
    strbranchinfoid_ = strbranchinfoid;
  } else {
    clear_has_strbranchinfoid();
    strbranchinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nFlag = 8;
inline bool RoleInfo::has_nflag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoleInfo::set_has_nflag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoleInfo::clear_has_nflag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoleInfo::clear_nflag() {
  nflag_ = 0;
  clear_has_nflag();
}
inline ::google::protobuf::int32 RoleInfo::nflag() const {
  return nflag_;
}
inline void RoleInfo::set_nflag(::google::protobuf::int32 value) {
  set_has_nflag();
  nflag_ = value;
}

// -------------------------------------------------------------------

// UserMapInfo

// required string strUsermapinfoid = 1;
inline bool UserMapInfo::has_strusermapinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMapInfo::set_has_strusermapinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMapInfo::clear_has_strusermapinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMapInfo::clear_strusermapinfoid() {
  if (strusermapinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strusermapinfoid_->clear();
  }
  clear_has_strusermapinfoid();
}
inline const ::std::string& UserMapInfo::strusermapinfoid() const {
  return *strusermapinfoid_;
}
inline void UserMapInfo::set_strusermapinfoid(const ::std::string& value) {
  set_has_strusermapinfoid();
  if (strusermapinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strusermapinfoid_ = new ::std::string;
  }
  strusermapinfoid_->assign(value);
}
inline void UserMapInfo::set_strusermapinfoid(const char* value) {
  set_has_strusermapinfoid();
  if (strusermapinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strusermapinfoid_ = new ::std::string;
  }
  strusermapinfoid_->assign(value);
}
inline void UserMapInfo::set_strusermapinfoid(const char* value, size_t size) {
  set_has_strusermapinfoid();
  if (strusermapinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strusermapinfoid_ = new ::std::string;
  }
  strusermapinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_strusermapinfoid() {
  set_has_strusermapinfoid();
  if (strusermapinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strusermapinfoid_ = new ::std::string;
  }
  return strusermapinfoid_;
}
inline ::std::string* UserMapInfo::release_strusermapinfoid() {
  clear_has_strusermapinfoid();
  if (strusermapinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strusermapinfoid_;
    strusermapinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_strusermapinfoid(::std::string* strusermapinfoid) {
  if (strusermapinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strusermapinfoid_;
  }
  if (strusermapinfoid) {
    set_has_strusermapinfoid();
    strusermapinfoid_ = strusermapinfoid;
  } else {
    clear_has_strusermapinfoid();
    strusermapinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeid = 2;
inline bool UserMapInfo::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMapInfo::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMapInfo::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMapInfo::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& UserMapInfo::stremployeeid() const {
  return *stremployeeid_;
}
inline void UserMapInfo::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void UserMapInfo::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void UserMapInfo::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* UserMapInfo::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSocusername = 3;
inline bool UserMapInfo::has_strsocusername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMapInfo::set_has_strsocusername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMapInfo::clear_has_strsocusername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMapInfo::clear_strsocusername() {
  if (strsocusername_ != &::google::protobuf::internal::kEmptyString) {
    strsocusername_->clear();
  }
  clear_has_strsocusername();
}
inline const ::std::string& UserMapInfo::strsocusername() const {
  return *strsocusername_;
}
inline void UserMapInfo::set_strsocusername(const ::std::string& value) {
  set_has_strsocusername();
  if (strsocusername_ == &::google::protobuf::internal::kEmptyString) {
    strsocusername_ = new ::std::string;
  }
  strsocusername_->assign(value);
}
inline void UserMapInfo::set_strsocusername(const char* value) {
  set_has_strsocusername();
  if (strsocusername_ == &::google::protobuf::internal::kEmptyString) {
    strsocusername_ = new ::std::string;
  }
  strsocusername_->assign(value);
}
inline void UserMapInfo::set_strsocusername(const char* value, size_t size) {
  set_has_strsocusername();
  if (strsocusername_ == &::google::protobuf::internal::kEmptyString) {
    strsocusername_ = new ::std::string;
  }
  strsocusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_strsocusername() {
  set_has_strsocusername();
  if (strsocusername_ == &::google::protobuf::internal::kEmptyString) {
    strsocusername_ = new ::std::string;
  }
  return strsocusername_;
}
inline ::std::string* UserMapInfo::release_strsocusername() {
  clear_has_strsocusername();
  if (strsocusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsocusername_;
    strsocusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_strsocusername(::std::string* strsocusername) {
  if (strsocusername_ != &::google::protobuf::internal::kEmptyString) {
    delete strsocusername_;
  }
  if (strsocusername) {
    set_has_strsocusername();
    strsocusername_ = strsocusername;
  } else {
    clear_has_strsocusername();
    strsocusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strSocpassword = 4;
inline bool UserMapInfo::has_strsocpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMapInfo::set_has_strsocpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMapInfo::clear_has_strsocpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMapInfo::clear_strsocpassword() {
  if (strsocpassword_ != &::google::protobuf::internal::kEmptyString) {
    strsocpassword_->clear();
  }
  clear_has_strsocpassword();
}
inline const ::std::string& UserMapInfo::strsocpassword() const {
  return *strsocpassword_;
}
inline void UserMapInfo::set_strsocpassword(const ::std::string& value) {
  set_has_strsocpassword();
  if (strsocpassword_ == &::google::protobuf::internal::kEmptyString) {
    strsocpassword_ = new ::std::string;
  }
  strsocpassword_->assign(value);
}
inline void UserMapInfo::set_strsocpassword(const char* value) {
  set_has_strsocpassword();
  if (strsocpassword_ == &::google::protobuf::internal::kEmptyString) {
    strsocpassword_ = new ::std::string;
  }
  strsocpassword_->assign(value);
}
inline void UserMapInfo::set_strsocpassword(const char* value, size_t size) {
  set_has_strsocpassword();
  if (strsocpassword_ == &::google::protobuf::internal::kEmptyString) {
    strsocpassword_ = new ::std::string;
  }
  strsocpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_strsocpassword() {
  set_has_strsocpassword();
  if (strsocpassword_ == &::google::protobuf::internal::kEmptyString) {
    strsocpassword_ = new ::std::string;
  }
  return strsocpassword_;
}
inline ::std::string* UserMapInfo::release_strsocpassword() {
  clear_has_strsocpassword();
  if (strsocpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsocpassword_;
    strsocpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_strsocpassword(::std::string* strsocpassword) {
  if (strsocpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete strsocpassword_;
  }
  if (strsocpassword) {
    set_has_strsocpassword();
    strsocpassword_ = strsocpassword;
  } else {
    clear_has_strsocpassword();
    strsocpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedinfo1 = 5;
inline bool UserMapInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMapInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMapInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMapInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& UserMapInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void UserMapInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void UserMapInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void UserMapInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* UserMapInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedinfo2 = 6;
inline bool UserMapInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMapInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMapInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMapInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& UserMapInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void UserMapInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void UserMapInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void UserMapInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMapInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* UserMapInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMapInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BusinessQueryParam

// required string strBranchid = 1;
inline bool BusinessQueryParam::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessQueryParam::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessQueryParam::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessQueryParam::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& BusinessQueryParam::strbranchid() const {
  return *strbranchid_;
}
inline void BusinessQueryParam::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BusinessQueryParam::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void BusinessQueryParam::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* BusinessQueryParam::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeid = 2;
inline bool BusinessQueryParam::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessQueryParam::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessQueryParam::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessQueryParam::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& BusinessQueryParam::stremployeeid() const {
  return *stremployeeid_;
}
inline void BusinessQueryParam::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BusinessQueryParam::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BusinessQueryParam::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* BusinessQueryParam::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCustomerid = 3;
inline bool BusinessQueryParam::has_strcustomerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessQueryParam::set_has_strcustomerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessQueryParam::clear_has_strcustomerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessQueryParam::clear_strcustomerid() {
  if (strcustomerid_ != &::google::protobuf::internal::kEmptyString) {
    strcustomerid_->clear();
  }
  clear_has_strcustomerid();
}
inline const ::std::string& BusinessQueryParam::strcustomerid() const {
  return *strcustomerid_;
}
inline void BusinessQueryParam::set_strcustomerid(const ::std::string& value) {
  set_has_strcustomerid();
  if (strcustomerid_ == &::google::protobuf::internal::kEmptyString) {
    strcustomerid_ = new ::std::string;
  }
  strcustomerid_->assign(value);
}
inline void BusinessQueryParam::set_strcustomerid(const char* value) {
  set_has_strcustomerid();
  if (strcustomerid_ == &::google::protobuf::internal::kEmptyString) {
    strcustomerid_ = new ::std::string;
  }
  strcustomerid_->assign(value);
}
inline void BusinessQueryParam::set_strcustomerid(const char* value, size_t size) {
  set_has_strcustomerid();
  if (strcustomerid_ == &::google::protobuf::internal::kEmptyString) {
    strcustomerid_ = new ::std::string;
  }
  strcustomerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strcustomerid() {
  set_has_strcustomerid();
  if (strcustomerid_ == &::google::protobuf::internal::kEmptyString) {
    strcustomerid_ = new ::std::string;
  }
  return strcustomerid_;
}
inline ::std::string* BusinessQueryParam::release_strcustomerid() {
  clear_has_strcustomerid();
  if (strcustomerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcustomerid_;
    strcustomerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strcustomerid(::std::string* strcustomerid) {
  if (strcustomerid_ != &::google::protobuf::internal::kEmptyString) {
    delete strcustomerid_;
  }
  if (strcustomerid) {
    set_has_strcustomerid();
    strcustomerid_ = strcustomerid;
  } else {
    clear_has_strcustomerid();
    strcustomerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceid = 4;
inline bool BusinessQueryParam::has_strproduceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessQueryParam::set_has_strproduceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessQueryParam::clear_has_strproduceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessQueryParam::clear_strproduceid() {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    strproduceid_->clear();
  }
  clear_has_strproduceid();
}
inline const ::std::string& BusinessQueryParam::strproduceid() const {
  return *strproduceid_;
}
inline void BusinessQueryParam::set_strproduceid(const ::std::string& value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BusinessQueryParam::set_strproduceid(const char* value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BusinessQueryParam::set_strproduceid(const char* value, size_t size) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strproduceid() {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  return strproduceid_;
}
inline ::std::string* BusinessQueryParam::release_strproduceid() {
  clear_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproduceid_;
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strproduceid(::std::string* strproduceid) {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    delete strproduceid_;
  }
  if (strproduceid) {
    set_has_strproduceid();
    strproduceid_ = strproduceid;
  } else {
    clear_has_strproduceid();
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strStarttime = 5;
inline bool BusinessQueryParam::has_strstarttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessQueryParam::set_has_strstarttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessQueryParam::clear_has_strstarttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessQueryParam::clear_strstarttime() {
  if (strstarttime_ != &::google::protobuf::internal::kEmptyString) {
    strstarttime_->clear();
  }
  clear_has_strstarttime();
}
inline const ::std::string& BusinessQueryParam::strstarttime() const {
  return *strstarttime_;
}
inline void BusinessQueryParam::set_strstarttime(const ::std::string& value) {
  set_has_strstarttime();
  if (strstarttime_ == &::google::protobuf::internal::kEmptyString) {
    strstarttime_ = new ::std::string;
  }
  strstarttime_->assign(value);
}
inline void BusinessQueryParam::set_strstarttime(const char* value) {
  set_has_strstarttime();
  if (strstarttime_ == &::google::protobuf::internal::kEmptyString) {
    strstarttime_ = new ::std::string;
  }
  strstarttime_->assign(value);
}
inline void BusinessQueryParam::set_strstarttime(const char* value, size_t size) {
  set_has_strstarttime();
  if (strstarttime_ == &::google::protobuf::internal::kEmptyString) {
    strstarttime_ = new ::std::string;
  }
  strstarttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strstarttime() {
  set_has_strstarttime();
  if (strstarttime_ == &::google::protobuf::internal::kEmptyString) {
    strstarttime_ = new ::std::string;
  }
  return strstarttime_;
}
inline ::std::string* BusinessQueryParam::release_strstarttime() {
  clear_has_strstarttime();
  if (strstarttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strstarttime_;
    strstarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strstarttime(::std::string* strstarttime) {
  if (strstarttime_ != &::google::protobuf::internal::kEmptyString) {
    delete strstarttime_;
  }
  if (strstarttime) {
    set_has_strstarttime();
    strstarttime_ = strstarttime;
  } else {
    clear_has_strstarttime();
    strstarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEndtime = 6;
inline bool BusinessQueryParam::has_strendtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessQueryParam::set_has_strendtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessQueryParam::clear_has_strendtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessQueryParam::clear_strendtime() {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    strendtime_->clear();
  }
  clear_has_strendtime();
}
inline const ::std::string& BusinessQueryParam::strendtime() const {
  return *strendtime_;
}
inline void BusinessQueryParam::set_strendtime(const ::std::string& value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void BusinessQueryParam::set_strendtime(const char* value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void BusinessQueryParam::set_strendtime(const char* value, size_t size) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strendtime() {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  return strendtime_;
}
inline ::std::string* BusinessQueryParam::release_strendtime() {
  clear_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strendtime_;
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strendtime(::std::string* strendtime) {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    delete strendtime_;
  }
  if (strendtime) {
    set_has_strendtime();
    strendtime_ = strendtime;
  } else {
    clear_has_strendtime();
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPagesize = 7;
inline bool BusinessQueryParam::has_npagesize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BusinessQueryParam::set_has_npagesize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BusinessQueryParam::clear_has_npagesize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BusinessQueryParam::clear_npagesize() {
  npagesize_ = 0;
  clear_has_npagesize();
}
inline ::google::protobuf::int32 BusinessQueryParam::npagesize() const {
  return npagesize_;
}
inline void BusinessQueryParam::set_npagesize(::google::protobuf::int32 value) {
  set_has_npagesize();
  npagesize_ = value;
}

// required int32 nPageindex = 8;
inline bool BusinessQueryParam::has_npageindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BusinessQueryParam::set_has_npageindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BusinessQueryParam::clear_has_npageindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BusinessQueryParam::clear_npageindex() {
  npageindex_ = 0;
  clear_has_npageindex();
}
inline ::google::protobuf::int32 BusinessQueryParam::npageindex() const {
  return npageindex_;
}
inline void BusinessQueryParam::set_npageindex(::google::protobuf::int32 value) {
  set_has_npageindex();
  npageindex_ = value;
}

// required int32 nRecordcount = 9;
inline bool BusinessQueryParam::has_nrecordcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BusinessQueryParam::set_has_nrecordcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BusinessQueryParam::clear_has_nrecordcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BusinessQueryParam::clear_nrecordcount() {
  nrecordcount_ = 0;
  clear_has_nrecordcount();
}
inline ::google::protobuf::int32 BusinessQueryParam::nrecordcount() const {
  return nrecordcount_;
}
inline void BusinessQueryParam::set_nrecordcount(::google::protobuf::int32 value) {
  set_has_nrecordcount();
  nrecordcount_ = value;
}

// required string strSerialNumber = 10;
inline bool BusinessQueryParam::has_strserialnumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BusinessQueryParam::set_has_strserialnumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BusinessQueryParam::clear_has_strserialnumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BusinessQueryParam::clear_strserialnumber() {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    strserialnumber_->clear();
  }
  clear_has_strserialnumber();
}
inline const ::std::string& BusinessQueryParam::strserialnumber() const {
  return *strserialnumber_;
}
inline void BusinessQueryParam::set_strserialnumber(const ::std::string& value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BusinessQueryParam::set_strserialnumber(const char* value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BusinessQueryParam::set_strserialnumber(const char* value, size_t size) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strserialnumber() {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  return strserialnumber_;
}
inline ::std::string* BusinessQueryParam::release_strserialnumber() {
  clear_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strserialnumber_;
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strserialnumber(::std::string* strserialnumber) {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete strserialnumber_;
  }
  if (strserialnumber) {
    set_has_strserialnumber();
    strserialnumber_ = strserialnumber;
  } else {
    clear_has_strserialnumber();
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCredenitialsType = 11;
inline bool BusinessQueryParam::has_strcredenitialstype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BusinessQueryParam::set_has_strcredenitialstype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BusinessQueryParam::clear_has_strcredenitialstype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BusinessQueryParam::clear_strcredenitialstype() {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_->clear();
  }
  clear_has_strcredenitialstype();
}
inline const ::std::string& BusinessQueryParam::strcredenitialstype() const {
  return *strcredenitialstype_;
}
inline void BusinessQueryParam::set_strcredenitialstype(const ::std::string& value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void BusinessQueryParam::set_strcredenitialstype(const char* value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void BusinessQueryParam::set_strcredenitialstype(const char* value, size_t size) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strcredenitialstype() {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  return strcredenitialstype_;
}
inline ::std::string* BusinessQueryParam::release_strcredenitialstype() {
  clear_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcredenitialstype_;
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strcredenitialstype(::std::string* strcredenitialstype) {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcredenitialstype_;
  }
  if (strcredenitialstype) {
    set_has_strcredenitialstype();
    strcredenitialstype_ = strcredenitialstype;
  } else {
    clear_has_strcredenitialstype();
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessType = 12;
inline bool BusinessQueryParam::has_strbusinesstype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BusinessQueryParam::set_has_strbusinesstype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BusinessQueryParam::clear_has_strbusinesstype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BusinessQueryParam::clear_strbusinesstype() {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_->clear();
  }
  clear_has_strbusinesstype();
}
inline const ::std::string& BusinessQueryParam::strbusinesstype() const {
  return *strbusinesstype_;
}
inline void BusinessQueryParam::set_strbusinesstype(const ::std::string& value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void BusinessQueryParam::set_strbusinesstype(const char* value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void BusinessQueryParam::set_strbusinesstype(const char* value, size_t size) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strbusinesstype() {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  return strbusinesstype_;
}
inline ::std::string* BusinessQueryParam::release_strbusinesstype() {
  clear_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinesstype_;
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strbusinesstype(::std::string* strbusinesstype) {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinesstype_;
  }
  if (strbusinesstype) {
    set_has_strbusinesstype();
    strbusinesstype_ = strbusinesstype;
  } else {
    clear_has_strbusinesstype();
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCardNumber = 13;
inline bool BusinessQueryParam::has_strcardnumber() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BusinessQueryParam::set_has_strcardnumber() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BusinessQueryParam::clear_has_strcardnumber() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BusinessQueryParam::clear_strcardnumber() {
  if (strcardnumber_ != &::google::protobuf::internal::kEmptyString) {
    strcardnumber_->clear();
  }
  clear_has_strcardnumber();
}
inline const ::std::string& BusinessQueryParam::strcardnumber() const {
  return *strcardnumber_;
}
inline void BusinessQueryParam::set_strcardnumber(const ::std::string& value) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(value);
}
inline void BusinessQueryParam::set_strcardnumber(const char* value) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(value);
}
inline void BusinessQueryParam::set_strcardnumber(const char* value, size_t size) {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  strcardnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strcardnumber() {
  set_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcardnumber_ = new ::std::string;
  }
  return strcardnumber_;
}
inline ::std::string* BusinessQueryParam::release_strcardnumber() {
  clear_has_strcardnumber();
  if (strcardnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcardnumber_;
    strcardnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strcardnumber(::std::string* strcardnumber) {
  if (strcardnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete strcardnumber_;
  }
  if (strcardnumber) {
    set_has_strcardnumber();
    strcardnumber_ = strcardnumber;
  } else {
    clear_has_strcardnumber();
    strcardnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nMarkerType = 14;
inline bool BusinessQueryParam::has_nmarkertype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BusinessQueryParam::set_has_nmarkertype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BusinessQueryParam::clear_has_nmarkertype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BusinessQueryParam::clear_nmarkertype() {
  nmarkertype_ = 0;
  clear_has_nmarkertype();
}
inline ::google::protobuf::int32 BusinessQueryParam::nmarkertype() const {
  return nmarkertype_;
}
inline void BusinessQueryParam::set_nmarkertype(::google::protobuf::int32 value) {
  set_has_nmarkertype();
  nmarkertype_ = value;
}

// required string strRiskLevel = 15;
inline bool BusinessQueryParam::has_strrisklevel() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BusinessQueryParam::set_has_strrisklevel() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BusinessQueryParam::clear_has_strrisklevel() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BusinessQueryParam::clear_strrisklevel() {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strrisklevel_->clear();
  }
  clear_has_strrisklevel();
}
inline const ::std::string& BusinessQueryParam::strrisklevel() const {
  return *strrisklevel_;
}
inline void BusinessQueryParam::set_strrisklevel(const ::std::string& value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void BusinessQueryParam::set_strrisklevel(const char* value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void BusinessQueryParam::set_strrisklevel(const char* value, size_t size) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strrisklevel() {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  return strrisklevel_;
}
inline ::std::string* BusinessQueryParam::release_strrisklevel() {
  clear_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrisklevel_;
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strrisklevel(::std::string* strrisklevel) {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    delete strrisklevel_;
  }
  if (strrisklevel) {
    set_has_strrisklevel();
    strrisklevel_ = strrisklevel;
  } else {
    clear_has_strrisklevel();
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strConditionEx = 16;
inline bool BusinessQueryParam::has_strconditionex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BusinessQueryParam::set_has_strconditionex() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BusinessQueryParam::clear_has_strconditionex() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BusinessQueryParam::clear_strconditionex() {
  if (strconditionex_ != &::google::protobuf::internal::kEmptyString) {
    strconditionex_->clear();
  }
  clear_has_strconditionex();
}
inline const ::std::string& BusinessQueryParam::strconditionex() const {
  return *strconditionex_;
}
inline void BusinessQueryParam::set_strconditionex(const ::std::string& value) {
  set_has_strconditionex();
  if (strconditionex_ == &::google::protobuf::internal::kEmptyString) {
    strconditionex_ = new ::std::string;
  }
  strconditionex_->assign(value);
}
inline void BusinessQueryParam::set_strconditionex(const char* value) {
  set_has_strconditionex();
  if (strconditionex_ == &::google::protobuf::internal::kEmptyString) {
    strconditionex_ = new ::std::string;
  }
  strconditionex_->assign(value);
}
inline void BusinessQueryParam::set_strconditionex(const char* value, size_t size) {
  set_has_strconditionex();
  if (strconditionex_ == &::google::protobuf::internal::kEmptyString) {
    strconditionex_ = new ::std::string;
  }
  strconditionex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strconditionex() {
  set_has_strconditionex();
  if (strconditionex_ == &::google::protobuf::internal::kEmptyString) {
    strconditionex_ = new ::std::string;
  }
  return strconditionex_;
}
inline ::std::string* BusinessQueryParam::release_strconditionex() {
  clear_has_strconditionex();
  if (strconditionex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strconditionex_;
    strconditionex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strconditionex(::std::string* strconditionex) {
  if (strconditionex_ != &::google::protobuf::internal::kEmptyString) {
    delete strconditionex_;
  }
  if (strconditionex) {
    set_has_strconditionex();
    strconditionex_ = strconditionex;
  } else {
    clear_has_strconditionex();
    strconditionex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMediumNum = 17;
inline bool BusinessQueryParam::has_strmediumnum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BusinessQueryParam::set_has_strmediumnum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BusinessQueryParam::clear_has_strmediumnum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BusinessQueryParam::clear_strmediumnum() {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    strmediumnum_->clear();
  }
  clear_has_strmediumnum();
}
inline const ::std::string& BusinessQueryParam::strmediumnum() const {
  return *strmediumnum_;
}
inline void BusinessQueryParam::set_strmediumnum(const ::std::string& value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessQueryParam::set_strmediumnum(const char* value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessQueryParam::set_strmediumnum(const char* value, size_t size) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strmediumnum() {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  return strmediumnum_;
}
inline ::std::string* BusinessQueryParam::release_strmediumnum() {
  clear_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmediumnum_;
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strmediumnum(::std::string* strmediumnum) {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strmediumnum_;
  }
  if (strmediumnum) {
    set_has_strmediumnum();
    strmediumnum_ = strmediumnum;
  } else {
    clear_has_strmediumnum();
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 18;
inline bool BusinessQueryParam::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BusinessQueryParam::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BusinessQueryParam::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BusinessQueryParam::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& BusinessQueryParam::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void BusinessQueryParam::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessQueryParam::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BusinessQueryParam::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessQueryParam::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* BusinessQueryParam::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessQueryParam::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProduceIdQueryParam

// required string strInfoId = 1;
inline bool ProduceIdQueryParam::has_strinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProduceIdQueryParam::set_has_strinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProduceIdQueryParam::clear_has_strinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProduceIdQueryParam::clear_strinfoid() {
  if (strinfoid_ != &::google::protobuf::internal::kEmptyString) {
    strinfoid_->clear();
  }
  clear_has_strinfoid();
}
inline const ::std::string& ProduceIdQueryParam::strinfoid() const {
  return *strinfoid_;
}
inline void ProduceIdQueryParam::set_strinfoid(const ::std::string& value) {
  set_has_strinfoid();
  if (strinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strinfoid_ = new ::std::string;
  }
  strinfoid_->assign(value);
}
inline void ProduceIdQueryParam::set_strinfoid(const char* value) {
  set_has_strinfoid();
  if (strinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strinfoid_ = new ::std::string;
  }
  strinfoid_->assign(value);
}
inline void ProduceIdQueryParam::set_strinfoid(const char* value, size_t size) {
  set_has_strinfoid();
  if (strinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strinfoid_ = new ::std::string;
  }
  strinfoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProduceIdQueryParam::mutable_strinfoid() {
  set_has_strinfoid();
  if (strinfoid_ == &::google::protobuf::internal::kEmptyString) {
    strinfoid_ = new ::std::string;
  }
  return strinfoid_;
}
inline ::std::string* ProduceIdQueryParam::release_strinfoid() {
  clear_has_strinfoid();
  if (strinfoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strinfoid_;
    strinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProduceIdQueryParam::set_allocated_strinfoid(::std::string* strinfoid) {
  if (strinfoid_ != &::google::protobuf::internal::kEmptyString) {
    delete strinfoid_;
  }
  if (strinfoid) {
    set_has_strinfoid();
    strinfoid_ = strinfoid;
  } else {
    clear_has_strinfoid();
    strinfoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nCount = 2;
inline bool ProduceIdQueryParam::has_ncount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProduceIdQueryParam::set_has_ncount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProduceIdQueryParam::clear_has_ncount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProduceIdQueryParam::clear_ncount() {
  ncount_ = 0;
  clear_has_ncount();
}
inline ::google::protobuf::int32 ProduceIdQueryParam::ncount() const {
  return ncount_;
}
inline void ProduceIdQueryParam::set_ncount(::google::protobuf::int32 value) {
  set_has_ncount();
  ncount_ = value;
}

// -------------------------------------------------------------------

// TaskPlan

// required string strPlanid = 1;
inline bool TaskPlan::has_strplanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskPlan::set_has_strplanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskPlan::clear_has_strplanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskPlan::clear_strplanid() {
  if (strplanid_ != &::google::protobuf::internal::kEmptyString) {
    strplanid_->clear();
  }
  clear_has_strplanid();
}
inline const ::std::string& TaskPlan::strplanid() const {
  return *strplanid_;
}
inline void TaskPlan::set_strplanid(const ::std::string& value) {
  set_has_strplanid();
  if (strplanid_ == &::google::protobuf::internal::kEmptyString) {
    strplanid_ = new ::std::string;
  }
  strplanid_->assign(value);
}
inline void TaskPlan::set_strplanid(const char* value) {
  set_has_strplanid();
  if (strplanid_ == &::google::protobuf::internal::kEmptyString) {
    strplanid_ = new ::std::string;
  }
  strplanid_->assign(value);
}
inline void TaskPlan::set_strplanid(const char* value, size_t size) {
  set_has_strplanid();
  if (strplanid_ == &::google::protobuf::internal::kEmptyString) {
    strplanid_ = new ::std::string;
  }
  strplanid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_strplanid() {
  set_has_strplanid();
  if (strplanid_ == &::google::protobuf::internal::kEmptyString) {
    strplanid_ = new ::std::string;
  }
  return strplanid_;
}
inline ::std::string* TaskPlan::release_strplanid() {
  clear_has_strplanid();
  if (strplanid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strplanid_;
    strplanid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_strplanid(::std::string* strplanid) {
  if (strplanid_ != &::google::protobuf::internal::kEmptyString) {
    delete strplanid_;
  }
  if (strplanid) {
    set_has_strplanid();
    strplanid_ = strplanid;
  } else {
    clear_has_strplanid();
    strplanid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBegintime = 2;
inline bool TaskPlan::has_strbegintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskPlan::set_has_strbegintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskPlan::clear_has_strbegintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskPlan::clear_strbegintime() {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    strbegintime_->clear();
  }
  clear_has_strbegintime();
}
inline const ::std::string& TaskPlan::strbegintime() const {
  return *strbegintime_;
}
inline void TaskPlan::set_strbegintime(const ::std::string& value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void TaskPlan::set_strbegintime(const char* value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void TaskPlan::set_strbegintime(const char* value, size_t size) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_strbegintime() {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  return strbegintime_;
}
inline ::std::string* TaskPlan::release_strbegintime() {
  clear_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbegintime_;
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_strbegintime(::std::string* strbegintime) {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    delete strbegintime_;
  }
  if (strbegintime) {
    set_has_strbegintime();
    strbegintime_ = strbegintime;
  } else {
    clear_has_strbegintime();
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEndtime = 3;
inline bool TaskPlan::has_strendtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskPlan::set_has_strendtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskPlan::clear_has_strendtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskPlan::clear_strendtime() {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    strendtime_->clear();
  }
  clear_has_strendtime();
}
inline const ::std::string& TaskPlan::strendtime() const {
  return *strendtime_;
}
inline void TaskPlan::set_strendtime(const ::std::string& value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void TaskPlan::set_strendtime(const char* value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void TaskPlan::set_strendtime(const char* value, size_t size) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_strendtime() {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  return strendtime_;
}
inline ::std::string* TaskPlan::release_strendtime() {
  clear_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strendtime_;
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_strendtime(::std::string* strendtime) {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    delete strendtime_;
  }
  if (strendtime) {
    set_has_strendtime();
    strendtime_ = strendtime;
  } else {
    clear_has_strendtime();
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nEable = 4;
inline bool TaskPlan::has_neable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskPlan::set_has_neable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskPlan::clear_has_neable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskPlan::clear_neable() {
  neable_ = 0;
  clear_has_neable();
}
inline ::google::protobuf::int32 TaskPlan::neable() const {
  return neable_;
}
inline void TaskPlan::set_neable(::google::protobuf::int32 value) {
  set_has_neable();
  neable_ = value;
}

// required int32 nOrderid = 5;
inline bool TaskPlan::has_norderid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskPlan::set_has_norderid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskPlan::clear_has_norderid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskPlan::clear_norderid() {
  norderid_ = 0;
  clear_has_norderid();
}
inline ::google::protobuf::int32 TaskPlan::norderid() const {
  return norderid_;
}
inline void TaskPlan::set_norderid(::google::protobuf::int32 value) {
  set_has_norderid();
  norderid_ = value;
}

// -------------------------------------------------------------------

// BackupTask

// required string strTaskid = 1;
inline bool BackupTask::has_strtaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupTask::set_has_strtaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupTask::clear_has_strtaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupTask::clear_strtaskid() {
  if (strtaskid_ != &::google::protobuf::internal::kEmptyString) {
    strtaskid_->clear();
  }
  clear_has_strtaskid();
}
inline const ::std::string& BackupTask::strtaskid() const {
  return *strtaskid_;
}
inline void BackupTask::set_strtaskid(const ::std::string& value) {
  set_has_strtaskid();
  if (strtaskid_ == &::google::protobuf::internal::kEmptyString) {
    strtaskid_ = new ::std::string;
  }
  strtaskid_->assign(value);
}
inline void BackupTask::set_strtaskid(const char* value) {
  set_has_strtaskid();
  if (strtaskid_ == &::google::protobuf::internal::kEmptyString) {
    strtaskid_ = new ::std::string;
  }
  strtaskid_->assign(value);
}
inline void BackupTask::set_strtaskid(const char* value, size_t size) {
  set_has_strtaskid();
  if (strtaskid_ == &::google::protobuf::internal::kEmptyString) {
    strtaskid_ = new ::std::string;
  }
  strtaskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strtaskid() {
  set_has_strtaskid();
  if (strtaskid_ == &::google::protobuf::internal::kEmptyString) {
    strtaskid_ = new ::std::string;
  }
  return strtaskid_;
}
inline ::std::string* BackupTask::release_strtaskid() {
  clear_has_strtaskid();
  if (strtaskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtaskid_;
    strtaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strtaskid(::std::string* strtaskid) {
  if (strtaskid_ != &::google::protobuf::internal::kEmptyString) {
    delete strtaskid_;
  }
  if (strtaskid) {
    set_has_strtaskid();
    strtaskid_ = strtaskid;
  } else {
    clear_has_strtaskid();
    strtaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nType = 2;
inline bool BackupTask::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackupTask::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackupTask::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackupTask::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 BackupTask::ntype() const {
  return ntype_;
}
inline void BackupTask::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// required int32 nStatus = 3;
inline bool BackupTask::has_nstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BackupTask::set_has_nstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BackupTask::clear_has_nstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BackupTask::clear_nstatus() {
  nstatus_ = 0;
  clear_has_nstatus();
}
inline ::google::protobuf::int32 BackupTask::nstatus() const {
  return nstatus_;
}
inline void BackupTask::set_nstatus(::google::protobuf::int32 value) {
  set_has_nstatus();
  nstatus_ = value;
}

// required string strBusinessid = 4;
inline bool BackupTask::has_strbusinessid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BackupTask::set_has_strbusinessid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BackupTask::clear_has_strbusinessid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BackupTask::clear_strbusinessid() {
  if (strbusinessid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessid_->clear();
  }
  clear_has_strbusinessid();
}
inline const ::std::string& BackupTask::strbusinessid() const {
  return *strbusinessid_;
}
inline void BackupTask::set_strbusinessid(const ::std::string& value) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(value);
}
inline void BackupTask::set_strbusinessid(const char* value) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(value);
}
inline void BackupTask::set_strbusinessid(const char* value, size_t size) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strbusinessid() {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  return strbusinessid_;
}
inline ::std::string* BackupTask::release_strbusinessid() {
  clear_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessid_;
    strbusinessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strbusinessid(::std::string* strbusinessid) {
  if (strbusinessid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessid_;
  }
  if (strbusinessid) {
    set_has_strbusinessid();
    strbusinessid_ = strbusinessid;
  } else {
    clear_has_strbusinessid();
    strbusinessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceid = 5;
inline bool BackupTask::has_strproduceid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BackupTask::set_has_strproduceid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BackupTask::clear_has_strproduceid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BackupTask::clear_strproduceid() {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    strproduceid_->clear();
  }
  clear_has_strproduceid();
}
inline const ::std::string& BackupTask::strproduceid() const {
  return *strproduceid_;
}
inline void BackupTask::set_strproduceid(const ::std::string& value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BackupTask::set_strproduceid(const char* value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void BackupTask::set_strproduceid(const char* value, size_t size) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strproduceid() {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  return strproduceid_;
}
inline ::std::string* BackupTask::release_strproduceid() {
  clear_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproduceid_;
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strproduceid(::std::string* strproduceid) {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    delete strproduceid_;
  }
  if (strproduceid) {
    set_has_strproduceid();
    strproduceid_ = strproduceid;
  } else {
    clear_has_strproduceid();
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeid = 6;
inline bool BackupTask::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BackupTask::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BackupTask::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BackupTask::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& BackupTask::stremployeeid() const {
  return *stremployeeid_;
}
inline void BackupTask::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BackupTask::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void BackupTask::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* BackupTask::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .BFIS.ClientInfo stCustomer = 7;
inline bool BackupTask::has_stcustomer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BackupTask::set_has_stcustomer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BackupTask::clear_has_stcustomer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BackupTask::clear_stcustomer() {
  if (stcustomer_ != NULL) stcustomer_->::BFIS::ClientInfo::Clear();
  clear_has_stcustomer();
}
inline const ::BFIS::ClientInfo& BackupTask::stcustomer() const {
  return stcustomer_ != NULL ? *stcustomer_ : *default_instance_->stcustomer_;
}
inline ::BFIS::ClientInfo* BackupTask::mutable_stcustomer() {
  set_has_stcustomer();
  if (stcustomer_ == NULL) stcustomer_ = new ::BFIS::ClientInfo;
  return stcustomer_;
}
inline ::BFIS::ClientInfo* BackupTask::release_stcustomer() {
  clear_has_stcustomer();
  ::BFIS::ClientInfo* temp = stcustomer_;
  stcustomer_ = NULL;
  return temp;
}
inline void BackupTask::set_allocated_stcustomer(::BFIS::ClientInfo* stcustomer) {
  delete stcustomer_;
  stcustomer_ = stcustomer;
  if (stcustomer) {
    set_has_stcustomer();
  } else {
    clear_has_stcustomer();
  }
}

// required string strAutotime = 8;
inline bool BackupTask::has_strautotime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BackupTask::set_has_strautotime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BackupTask::clear_has_strautotime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BackupTask::clear_strautotime() {
  if (strautotime_ != &::google::protobuf::internal::kEmptyString) {
    strautotime_->clear();
  }
  clear_has_strautotime();
}
inline const ::std::string& BackupTask::strautotime() const {
  return *strautotime_;
}
inline void BackupTask::set_strautotime(const ::std::string& value) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(value);
}
inline void BackupTask::set_strautotime(const char* value) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(value);
}
inline void BackupTask::set_strautotime(const char* value, size_t size) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strautotime() {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  return strautotime_;
}
inline ::std::string* BackupTask::release_strautotime() {
  clear_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strautotime_;
    strautotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strautotime(::std::string* strautotime) {
  if (strautotime_ != &::google::protobuf::internal::kEmptyString) {
    delete strautotime_;
  }
  if (strautotime) {
    set_has_strautotime();
    strautotime_ = strautotime;
  } else {
    clear_has_strautotime();
    strautotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBegintime = 9;
inline bool BackupTask::has_strbegintime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BackupTask::set_has_strbegintime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BackupTask::clear_has_strbegintime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BackupTask::clear_strbegintime() {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    strbegintime_->clear();
  }
  clear_has_strbegintime();
}
inline const ::std::string& BackupTask::strbegintime() const {
  return *strbegintime_;
}
inline void BackupTask::set_strbegintime(const ::std::string& value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void BackupTask::set_strbegintime(const char* value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void BackupTask::set_strbegintime(const char* value, size_t size) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strbegintime() {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  return strbegintime_;
}
inline ::std::string* BackupTask::release_strbegintime() {
  clear_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbegintime_;
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strbegintime(::std::string* strbegintime) {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    delete strbegintime_;
  }
  if (strbegintime) {
    set_has_strbegintime();
    strbegintime_ = strbegintime;
  } else {
    clear_has_strbegintime();
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEndtime = 10;
inline bool BackupTask::has_strendtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BackupTask::set_has_strendtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BackupTask::clear_has_strendtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BackupTask::clear_strendtime() {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    strendtime_->clear();
  }
  clear_has_strendtime();
}
inline const ::std::string& BackupTask::strendtime() const {
  return *strendtime_;
}
inline void BackupTask::set_strendtime(const ::std::string& value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void BackupTask::set_strendtime(const char* value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void BackupTask::set_strendtime(const char* value, size_t size) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strendtime() {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  return strendtime_;
}
inline ::std::string* BackupTask::release_strendtime() {
  clear_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strendtime_;
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strendtime(::std::string* strendtime) {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    delete strendtime_;
  }
  if (strendtime) {
    set_has_strendtime();
    strendtime_ = strendtime;
  } else {
    clear_has_strendtime();
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nProcess = 11;
inline bool BackupTask::has_nprocess() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BackupTask::set_has_nprocess() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BackupTask::clear_has_nprocess() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BackupTask::clear_nprocess() {
  nprocess_ = 0;
  clear_has_nprocess();
}
inline ::google::protobuf::int32 BackupTask::nprocess() const {
  return nprocess_;
}
inline void BackupTask::set_nprocess(::google::protobuf::int32 value) {
  set_has_nprocess();
  nprocess_ = value;
}

// required string strLaunchEmployeeID = 12;
inline bool BackupTask::has_strlaunchemployeeid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BackupTask::set_has_strlaunchemployeeid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BackupTask::clear_has_strlaunchemployeeid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BackupTask::clear_strlaunchemployeeid() {
  if (strlaunchemployeeid_ != &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_->clear();
  }
  clear_has_strlaunchemployeeid();
}
inline const ::std::string& BackupTask::strlaunchemployeeid() const {
  return *strlaunchemployeeid_;
}
inline void BackupTask::set_strlaunchemployeeid(const ::std::string& value) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(value);
}
inline void BackupTask::set_strlaunchemployeeid(const char* value) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(value);
}
inline void BackupTask::set_strlaunchemployeeid(const char* value, size_t size) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strlaunchemployeeid() {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  return strlaunchemployeeid_;
}
inline ::std::string* BackupTask::release_strlaunchemployeeid() {
  clear_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlaunchemployeeid_;
    strlaunchemployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strlaunchemployeeid(::std::string* strlaunchemployeeid) {
  if (strlaunchemployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete strlaunchemployeeid_;
  }
  if (strlaunchemployeeid) {
    set_has_strlaunchemployeeid();
    strlaunchemployeeid_ = strlaunchemployeeid;
  } else {
    clear_has_strlaunchemployeeid();
    strlaunchemployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nOrderid = 13;
inline bool BackupTask::has_norderid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BackupTask::set_has_norderid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BackupTask::clear_has_norderid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BackupTask::clear_norderid() {
  norderid_ = 0;
  clear_has_norderid();
}
inline ::google::protobuf::int32 BackupTask::norderid() const {
  return norderid_;
}
inline void BackupTask::set_norderid(::google::protobuf::int32 value) {
  set_has_norderid();
  norderid_ = value;
}

// required string strTimeForBusiness = 14;
inline bool BackupTask::has_strtimeforbusiness() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BackupTask::set_has_strtimeforbusiness() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BackupTask::clear_has_strtimeforbusiness() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BackupTask::clear_strtimeforbusiness() {
  if (strtimeforbusiness_ != &::google::protobuf::internal::kEmptyString) {
    strtimeforbusiness_->clear();
  }
  clear_has_strtimeforbusiness();
}
inline const ::std::string& BackupTask::strtimeforbusiness() const {
  return *strtimeforbusiness_;
}
inline void BackupTask::set_strtimeforbusiness(const ::std::string& value) {
  set_has_strtimeforbusiness();
  if (strtimeforbusiness_ == &::google::protobuf::internal::kEmptyString) {
    strtimeforbusiness_ = new ::std::string;
  }
  strtimeforbusiness_->assign(value);
}
inline void BackupTask::set_strtimeforbusiness(const char* value) {
  set_has_strtimeforbusiness();
  if (strtimeforbusiness_ == &::google::protobuf::internal::kEmptyString) {
    strtimeforbusiness_ = new ::std::string;
  }
  strtimeforbusiness_->assign(value);
}
inline void BackupTask::set_strtimeforbusiness(const char* value, size_t size) {
  set_has_strtimeforbusiness();
  if (strtimeforbusiness_ == &::google::protobuf::internal::kEmptyString) {
    strtimeforbusiness_ = new ::std::string;
  }
  strtimeforbusiness_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strtimeforbusiness() {
  set_has_strtimeforbusiness();
  if (strtimeforbusiness_ == &::google::protobuf::internal::kEmptyString) {
    strtimeforbusiness_ = new ::std::string;
  }
  return strtimeforbusiness_;
}
inline ::std::string* BackupTask::release_strtimeforbusiness() {
  clear_has_strtimeforbusiness();
  if (strtimeforbusiness_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtimeforbusiness_;
    strtimeforbusiness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strtimeforbusiness(::std::string* strtimeforbusiness) {
  if (strtimeforbusiness_ != &::google::protobuf::internal::kEmptyString) {
    delete strtimeforbusiness_;
  }
  if (strtimeforbusiness) {
    set_has_strtimeforbusiness();
    strtimeforbusiness_ = strtimeforbusiness;
  } else {
    clear_has_strtimeforbusiness();
    strtimeforbusiness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 15;
inline bool BackupTask::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BackupTask::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BackupTask::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BackupTask::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& BackupTask::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void BackupTask::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BackupTask::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void BackupTask::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupTask::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* BackupTask::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackupTask::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// McServer

// required string strBranchID = 1;
inline bool McServer::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void McServer::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void McServer::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void McServer::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& McServer::strbranchid() const {
  return *strbranchid_;
}
inline void McServer::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void McServer::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void McServer::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* McServer::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* McServer::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void McServer::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBranchName = 2;
inline bool McServer::has_strbranchname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void McServer::set_has_strbranchname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void McServer::clear_has_strbranchname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void McServer::clear_strbranchname() {
  if (strbranchname_ != &::google::protobuf::internal::kEmptyString) {
    strbranchname_->clear();
  }
  clear_has_strbranchname();
}
inline const ::std::string& McServer::strbranchname() const {
  return *strbranchname_;
}
inline void McServer::set_strbranchname(const ::std::string& value) {
  set_has_strbranchname();
  if (strbranchname_ == &::google::protobuf::internal::kEmptyString) {
    strbranchname_ = new ::std::string;
  }
  strbranchname_->assign(value);
}
inline void McServer::set_strbranchname(const char* value) {
  set_has_strbranchname();
  if (strbranchname_ == &::google::protobuf::internal::kEmptyString) {
    strbranchname_ = new ::std::string;
  }
  strbranchname_->assign(value);
}
inline void McServer::set_strbranchname(const char* value, size_t size) {
  set_has_strbranchname();
  if (strbranchname_ == &::google::protobuf::internal::kEmptyString) {
    strbranchname_ = new ::std::string;
  }
  strbranchname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* McServer::mutable_strbranchname() {
  set_has_strbranchname();
  if (strbranchname_ == &::google::protobuf::internal::kEmptyString) {
    strbranchname_ = new ::std::string;
  }
  return strbranchname_;
}
inline ::std::string* McServer::release_strbranchname() {
  clear_has_strbranchname();
  if (strbranchname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchname_;
    strbranchname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void McServer::set_allocated_strbranchname(::std::string* strbranchname) {
  if (strbranchname_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchname_;
  }
  if (strbranchname) {
    set_has_strbranchname();
    strbranchname_ = strbranchname;
  } else {
    clear_has_strbranchname();
    strbranchname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMCIP = 3;
inline bool McServer::has_strmcip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void McServer::set_has_strmcip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void McServer::clear_has_strmcip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void McServer::clear_strmcip() {
  if (strmcip_ != &::google::protobuf::internal::kEmptyString) {
    strmcip_->clear();
  }
  clear_has_strmcip();
}
inline const ::std::string& McServer::strmcip() const {
  return *strmcip_;
}
inline void McServer::set_strmcip(const ::std::string& value) {
  set_has_strmcip();
  if (strmcip_ == &::google::protobuf::internal::kEmptyString) {
    strmcip_ = new ::std::string;
  }
  strmcip_->assign(value);
}
inline void McServer::set_strmcip(const char* value) {
  set_has_strmcip();
  if (strmcip_ == &::google::protobuf::internal::kEmptyString) {
    strmcip_ = new ::std::string;
  }
  strmcip_->assign(value);
}
inline void McServer::set_strmcip(const char* value, size_t size) {
  set_has_strmcip();
  if (strmcip_ == &::google::protobuf::internal::kEmptyString) {
    strmcip_ = new ::std::string;
  }
  strmcip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* McServer::mutable_strmcip() {
  set_has_strmcip();
  if (strmcip_ == &::google::protobuf::internal::kEmptyString) {
    strmcip_ = new ::std::string;
  }
  return strmcip_;
}
inline ::std::string* McServer::release_strmcip() {
  clear_has_strmcip();
  if (strmcip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmcip_;
    strmcip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void McServer::set_allocated_strmcip(::std::string* strmcip) {
  if (strmcip_ != &::google::protobuf::internal::kEmptyString) {
    delete strmcip_;
  }
  if (strmcip) {
    set_has_strmcip();
    strmcip_ = strmcip;
  } else {
    clear_has_strmcip();
    strmcip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPort = 4;
inline bool McServer::has_nport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void McServer::set_has_nport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void McServer::clear_has_nport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void McServer::clear_nport() {
  nport_ = 0;
  clear_has_nport();
}
inline ::google::protobuf::int32 McServer::nport() const {
  return nport_;
}
inline void McServer::set_nport(::google::protobuf::int32 value) {
  set_has_nport();
  nport_ = value;
}

// required string strMCUserName = 5;
inline bool McServer::has_strmcusername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void McServer::set_has_strmcusername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void McServer::clear_has_strmcusername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void McServer::clear_strmcusername() {
  if (strmcusername_ != &::google::protobuf::internal::kEmptyString) {
    strmcusername_->clear();
  }
  clear_has_strmcusername();
}
inline const ::std::string& McServer::strmcusername() const {
  return *strmcusername_;
}
inline void McServer::set_strmcusername(const ::std::string& value) {
  set_has_strmcusername();
  if (strmcusername_ == &::google::protobuf::internal::kEmptyString) {
    strmcusername_ = new ::std::string;
  }
  strmcusername_->assign(value);
}
inline void McServer::set_strmcusername(const char* value) {
  set_has_strmcusername();
  if (strmcusername_ == &::google::protobuf::internal::kEmptyString) {
    strmcusername_ = new ::std::string;
  }
  strmcusername_->assign(value);
}
inline void McServer::set_strmcusername(const char* value, size_t size) {
  set_has_strmcusername();
  if (strmcusername_ == &::google::protobuf::internal::kEmptyString) {
    strmcusername_ = new ::std::string;
  }
  strmcusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* McServer::mutable_strmcusername() {
  set_has_strmcusername();
  if (strmcusername_ == &::google::protobuf::internal::kEmptyString) {
    strmcusername_ = new ::std::string;
  }
  return strmcusername_;
}
inline ::std::string* McServer::release_strmcusername() {
  clear_has_strmcusername();
  if (strmcusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmcusername_;
    strmcusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void McServer::set_allocated_strmcusername(::std::string* strmcusername) {
  if (strmcusername_ != &::google::protobuf::internal::kEmptyString) {
    delete strmcusername_;
  }
  if (strmcusername) {
    set_has_strmcusername();
    strmcusername_ = strmcusername;
  } else {
    clear_has_strmcusername();
    strmcusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMCUserPwd = 6;
inline bool McServer::has_strmcuserpwd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void McServer::set_has_strmcuserpwd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void McServer::clear_has_strmcuserpwd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void McServer::clear_strmcuserpwd() {
  if (strmcuserpwd_ != &::google::protobuf::internal::kEmptyString) {
    strmcuserpwd_->clear();
  }
  clear_has_strmcuserpwd();
}
inline const ::std::string& McServer::strmcuserpwd() const {
  return *strmcuserpwd_;
}
inline void McServer::set_strmcuserpwd(const ::std::string& value) {
  set_has_strmcuserpwd();
  if (strmcuserpwd_ == &::google::protobuf::internal::kEmptyString) {
    strmcuserpwd_ = new ::std::string;
  }
  strmcuserpwd_->assign(value);
}
inline void McServer::set_strmcuserpwd(const char* value) {
  set_has_strmcuserpwd();
  if (strmcuserpwd_ == &::google::protobuf::internal::kEmptyString) {
    strmcuserpwd_ = new ::std::string;
  }
  strmcuserpwd_->assign(value);
}
inline void McServer::set_strmcuserpwd(const char* value, size_t size) {
  set_has_strmcuserpwd();
  if (strmcuserpwd_ == &::google::protobuf::internal::kEmptyString) {
    strmcuserpwd_ = new ::std::string;
  }
  strmcuserpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* McServer::mutable_strmcuserpwd() {
  set_has_strmcuserpwd();
  if (strmcuserpwd_ == &::google::protobuf::internal::kEmptyString) {
    strmcuserpwd_ = new ::std::string;
  }
  return strmcuserpwd_;
}
inline ::std::string* McServer::release_strmcuserpwd() {
  clear_has_strmcuserpwd();
  if (strmcuserpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmcuserpwd_;
    strmcuserpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void McServer::set_allocated_strmcuserpwd(::std::string* strmcuserpwd) {
  if (strmcuserpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete strmcuserpwd_;
  }
  if (strmcuserpwd) {
    set_has_strmcuserpwd();
    strmcuserpwd_ = strmcuserpwd;
  } else {
    clear_has_strmcuserpwd();
    strmcuserpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nIsLocal = 7;
inline bool McServer::has_nislocal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void McServer::set_has_nislocal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void McServer::clear_has_nislocal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void McServer::clear_nislocal() {
  nislocal_ = 0;
  clear_has_nislocal();
}
inline ::google::protobuf::int32 McServer::nislocal() const {
  return nislocal_;
}
inline void McServer::set_nislocal(::google::protobuf::int32 value) {
  set_has_nislocal();
  nislocal_ = value;
}

// -------------------------------------------------------------------

// MigrateLog

// required string strMigrateTaskID = 1;
inline bool MigrateLog::has_strmigratetaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MigrateLog::set_has_strmigratetaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MigrateLog::clear_has_strmigratetaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MigrateLog::clear_strmigratetaskid() {
  if (strmigratetaskid_ != &::google::protobuf::internal::kEmptyString) {
    strmigratetaskid_->clear();
  }
  clear_has_strmigratetaskid();
}
inline const ::std::string& MigrateLog::strmigratetaskid() const {
  return *strmigratetaskid_;
}
inline void MigrateLog::set_strmigratetaskid(const ::std::string& value) {
  set_has_strmigratetaskid();
  if (strmigratetaskid_ == &::google::protobuf::internal::kEmptyString) {
    strmigratetaskid_ = new ::std::string;
  }
  strmigratetaskid_->assign(value);
}
inline void MigrateLog::set_strmigratetaskid(const char* value) {
  set_has_strmigratetaskid();
  if (strmigratetaskid_ == &::google::protobuf::internal::kEmptyString) {
    strmigratetaskid_ = new ::std::string;
  }
  strmigratetaskid_->assign(value);
}
inline void MigrateLog::set_strmigratetaskid(const char* value, size_t size) {
  set_has_strmigratetaskid();
  if (strmigratetaskid_ == &::google::protobuf::internal::kEmptyString) {
    strmigratetaskid_ = new ::std::string;
  }
  strmigratetaskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strmigratetaskid() {
  set_has_strmigratetaskid();
  if (strmigratetaskid_ == &::google::protobuf::internal::kEmptyString) {
    strmigratetaskid_ = new ::std::string;
  }
  return strmigratetaskid_;
}
inline ::std::string* MigrateLog::release_strmigratetaskid() {
  clear_has_strmigratetaskid();
  if (strmigratetaskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmigratetaskid_;
    strmigratetaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strmigratetaskid(::std::string* strmigratetaskid) {
  if (strmigratetaskid_ != &::google::protobuf::internal::kEmptyString) {
    delete strmigratetaskid_;
  }
  if (strmigratetaskid) {
    set_has_strmigratetaskid();
    strmigratetaskid_ = strmigratetaskid;
  } else {
    clear_has_strmigratetaskid();
    strmigratetaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessID = 2;
inline bool MigrateLog::has_strbusinessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MigrateLog::set_has_strbusinessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MigrateLog::clear_has_strbusinessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MigrateLog::clear_strbusinessid() {
  if (strbusinessid_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessid_->clear();
  }
  clear_has_strbusinessid();
}
inline const ::std::string& MigrateLog::strbusinessid() const {
  return *strbusinessid_;
}
inline void MigrateLog::set_strbusinessid(const ::std::string& value) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(value);
}
inline void MigrateLog::set_strbusinessid(const char* value) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(value);
}
inline void MigrateLog::set_strbusinessid(const char* value, size_t size) {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  strbusinessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strbusinessid() {
  set_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessid_ = new ::std::string;
  }
  return strbusinessid_;
}
inline ::std::string* MigrateLog::release_strbusinessid() {
  clear_has_strbusinessid();
  if (strbusinessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessid_;
    strbusinessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strbusinessid(::std::string* strbusinessid) {
  if (strbusinessid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessid_;
  }
  if (strbusinessid) {
    set_has_strbusinessid();
    strbusinessid_ = strbusinessid;
  } else {
    clear_has_strbusinessid();
    strbusinessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceID = 3;
inline bool MigrateLog::has_strproduceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MigrateLog::set_has_strproduceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MigrateLog::clear_has_strproduceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MigrateLog::clear_strproduceid() {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    strproduceid_->clear();
  }
  clear_has_strproduceid();
}
inline const ::std::string& MigrateLog::strproduceid() const {
  return *strproduceid_;
}
inline void MigrateLog::set_strproduceid(const ::std::string& value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void MigrateLog::set_strproduceid(const char* value) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(value);
}
inline void MigrateLog::set_strproduceid(const char* value, size_t size) {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  strproduceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strproduceid() {
  set_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    strproduceid_ = new ::std::string;
  }
  return strproduceid_;
}
inline ::std::string* MigrateLog::release_strproduceid() {
  clear_has_strproduceid();
  if (strproduceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproduceid_;
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strproduceid(::std::string* strproduceid) {
  if (strproduceid_ != &::google::protobuf::internal::kEmptyString) {
    delete strproduceid_;
  }
  if (strproduceid) {
    set_has_strproduceid();
    strproduceid_ = strproduceid;
  } else {
    clear_has_strproduceid();
    strproduceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeID = 4;
inline bool MigrateLog::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MigrateLog::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MigrateLog::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MigrateLog::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& MigrateLog::stremployeeid() const {
  return *stremployeeid_;
}
inline void MigrateLog::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void MigrateLog::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void MigrateLog::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* MigrateLog::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nType = 5;
inline bool MigrateLog::has_ntype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MigrateLog::set_has_ntype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MigrateLog::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MigrateLog::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 MigrateLog::ntype() const {
  return ntype_;
}
inline void MigrateLog::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// required int32 nStatus = 6;
inline bool MigrateLog::has_nstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MigrateLog::set_has_nstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MigrateLog::clear_has_nstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MigrateLog::clear_nstatus() {
  nstatus_ = 0;
  clear_has_nstatus();
}
inline ::google::protobuf::int32 MigrateLog::nstatus() const {
  return nstatus_;
}
inline void MigrateLog::set_nstatus(::google::protobuf::int32 value) {
  set_has_nstatus();
  nstatus_ = value;
}

// required string strAutoTime = 7;
inline bool MigrateLog::has_strautotime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MigrateLog::set_has_strautotime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MigrateLog::clear_has_strautotime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MigrateLog::clear_strautotime() {
  if (strautotime_ != &::google::protobuf::internal::kEmptyString) {
    strautotime_->clear();
  }
  clear_has_strautotime();
}
inline const ::std::string& MigrateLog::strautotime() const {
  return *strautotime_;
}
inline void MigrateLog::set_strautotime(const ::std::string& value) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(value);
}
inline void MigrateLog::set_strautotime(const char* value) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(value);
}
inline void MigrateLog::set_strautotime(const char* value, size_t size) {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  strautotime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strautotime() {
  set_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    strautotime_ = new ::std::string;
  }
  return strautotime_;
}
inline ::std::string* MigrateLog::release_strautotime() {
  clear_has_strautotime();
  if (strautotime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strautotime_;
    strautotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strautotime(::std::string* strautotime) {
  if (strautotime_ != &::google::protobuf::internal::kEmptyString) {
    delete strautotime_;
  }
  if (strautotime) {
    set_has_strautotime();
    strautotime_ = strautotime;
  } else {
    clear_has_strautotime();
    strautotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBeginTime = 8;
inline bool MigrateLog::has_strbegintime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MigrateLog::set_has_strbegintime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MigrateLog::clear_has_strbegintime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MigrateLog::clear_strbegintime() {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    strbegintime_->clear();
  }
  clear_has_strbegintime();
}
inline const ::std::string& MigrateLog::strbegintime() const {
  return *strbegintime_;
}
inline void MigrateLog::set_strbegintime(const ::std::string& value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void MigrateLog::set_strbegintime(const char* value) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(value);
}
inline void MigrateLog::set_strbegintime(const char* value, size_t size) {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  strbegintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strbegintime() {
  set_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    strbegintime_ = new ::std::string;
  }
  return strbegintime_;
}
inline ::std::string* MigrateLog::release_strbegintime() {
  clear_has_strbegintime();
  if (strbegintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbegintime_;
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strbegintime(::std::string* strbegintime) {
  if (strbegintime_ != &::google::protobuf::internal::kEmptyString) {
    delete strbegintime_;
  }
  if (strbegintime) {
    set_has_strbegintime();
    strbegintime_ = strbegintime;
  } else {
    clear_has_strbegintime();
    strbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEndTime = 9;
inline bool MigrateLog::has_strendtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MigrateLog::set_has_strendtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MigrateLog::clear_has_strendtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MigrateLog::clear_strendtime() {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    strendtime_->clear();
  }
  clear_has_strendtime();
}
inline const ::std::string& MigrateLog::strendtime() const {
  return *strendtime_;
}
inline void MigrateLog::set_strendtime(const ::std::string& value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void MigrateLog::set_strendtime(const char* value) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(value);
}
inline void MigrateLog::set_strendtime(const char* value, size_t size) {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  strendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strendtime() {
  set_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    strendtime_ = new ::std::string;
  }
  return strendtime_;
}
inline ::std::string* MigrateLog::release_strendtime() {
  clear_has_strendtime();
  if (strendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strendtime_;
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strendtime(::std::string* strendtime) {
  if (strendtime_ != &::google::protobuf::internal::kEmptyString) {
    delete strendtime_;
  }
  if (strendtime) {
    set_has_strendtime();
    strendtime_ = strendtime;
  } else {
    clear_has_strendtime();
    strendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strLaunchEmployeeID = 10;
inline bool MigrateLog::has_strlaunchemployeeid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MigrateLog::set_has_strlaunchemployeeid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MigrateLog::clear_has_strlaunchemployeeid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MigrateLog::clear_strlaunchemployeeid() {
  if (strlaunchemployeeid_ != &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_->clear();
  }
  clear_has_strlaunchemployeeid();
}
inline const ::std::string& MigrateLog::strlaunchemployeeid() const {
  return *strlaunchemployeeid_;
}
inline void MigrateLog::set_strlaunchemployeeid(const ::std::string& value) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(value);
}
inline void MigrateLog::set_strlaunchemployeeid(const char* value) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(value);
}
inline void MigrateLog::set_strlaunchemployeeid(const char* value, size_t size) {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  strlaunchemployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MigrateLog::mutable_strlaunchemployeeid() {
  set_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    strlaunchemployeeid_ = new ::std::string;
  }
  return strlaunchemployeeid_;
}
inline ::std::string* MigrateLog::release_strlaunchemployeeid() {
  clear_has_strlaunchemployeeid();
  if (strlaunchemployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlaunchemployeeid_;
    strlaunchemployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MigrateLog::set_allocated_strlaunchemployeeid(::std::string* strlaunchemployeeid) {
  if (strlaunchemployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete strlaunchemployeeid_;
  }
  if (strlaunchemployeeid) {
    set_has_strlaunchemployeeid();
    strlaunchemployeeid_ = strlaunchemployeeid;
  } else {
    clear_has_strlaunchemployeeid();
    strlaunchemployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nOrderID = 11;
inline bool MigrateLog::has_norderid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MigrateLog::set_has_norderid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MigrateLog::clear_has_norderid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MigrateLog::clear_norderid() {
  norderid_ = 0;
  clear_has_norderid();
}
inline ::google::protobuf::int32 MigrateLog::norderid() const {
  return norderid_;
}
inline void MigrateLog::set_norderid(::google::protobuf::int32 value) {
  set_has_norderid();
  norderid_ = value;
}

// -------------------------------------------------------------------

// QueryCondition

// required string strCon1 = 1;
inline bool QueryCondition::has_strcon1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryCondition::set_has_strcon1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryCondition::clear_has_strcon1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryCondition::clear_strcon1() {
  if (strcon1_ != &::google::protobuf::internal::kEmptyString) {
    strcon1_->clear();
  }
  clear_has_strcon1();
}
inline const ::std::string& QueryCondition::strcon1() const {
  return *strcon1_;
}
inline void QueryCondition::set_strcon1(const ::std::string& value) {
  set_has_strcon1();
  if (strcon1_ == &::google::protobuf::internal::kEmptyString) {
    strcon1_ = new ::std::string;
  }
  strcon1_->assign(value);
}
inline void QueryCondition::set_strcon1(const char* value) {
  set_has_strcon1();
  if (strcon1_ == &::google::protobuf::internal::kEmptyString) {
    strcon1_ = new ::std::string;
  }
  strcon1_->assign(value);
}
inline void QueryCondition::set_strcon1(const char* value, size_t size) {
  set_has_strcon1();
  if (strcon1_ == &::google::protobuf::internal::kEmptyString) {
    strcon1_ = new ::std::string;
  }
  strcon1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCondition::mutable_strcon1() {
  set_has_strcon1();
  if (strcon1_ == &::google::protobuf::internal::kEmptyString) {
    strcon1_ = new ::std::string;
  }
  return strcon1_;
}
inline ::std::string* QueryCondition::release_strcon1() {
  clear_has_strcon1();
  if (strcon1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcon1_;
    strcon1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryCondition::set_allocated_strcon1(::std::string* strcon1) {
  if (strcon1_ != &::google::protobuf::internal::kEmptyString) {
    delete strcon1_;
  }
  if (strcon1) {
    set_has_strcon1();
    strcon1_ = strcon1;
  } else {
    clear_has_strcon1();
    strcon1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCon2 = 2;
inline bool QueryCondition::has_strcon2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryCondition::set_has_strcon2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryCondition::clear_has_strcon2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryCondition::clear_strcon2() {
  if (strcon2_ != &::google::protobuf::internal::kEmptyString) {
    strcon2_->clear();
  }
  clear_has_strcon2();
}
inline const ::std::string& QueryCondition::strcon2() const {
  return *strcon2_;
}
inline void QueryCondition::set_strcon2(const ::std::string& value) {
  set_has_strcon2();
  if (strcon2_ == &::google::protobuf::internal::kEmptyString) {
    strcon2_ = new ::std::string;
  }
  strcon2_->assign(value);
}
inline void QueryCondition::set_strcon2(const char* value) {
  set_has_strcon2();
  if (strcon2_ == &::google::protobuf::internal::kEmptyString) {
    strcon2_ = new ::std::string;
  }
  strcon2_->assign(value);
}
inline void QueryCondition::set_strcon2(const char* value, size_t size) {
  set_has_strcon2();
  if (strcon2_ == &::google::protobuf::internal::kEmptyString) {
    strcon2_ = new ::std::string;
  }
  strcon2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCondition::mutable_strcon2() {
  set_has_strcon2();
  if (strcon2_ == &::google::protobuf::internal::kEmptyString) {
    strcon2_ = new ::std::string;
  }
  return strcon2_;
}
inline ::std::string* QueryCondition::release_strcon2() {
  clear_has_strcon2();
  if (strcon2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcon2_;
    strcon2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryCondition::set_allocated_strcon2(::std::string* strcon2) {
  if (strcon2_ != &::google::protobuf::internal::kEmptyString) {
    delete strcon2_;
  }
  if (strcon2) {
    set_has_strcon2();
    strcon2_ = strcon2;
  } else {
    clear_has_strcon2();
    strcon2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nPageSize = 3;
inline bool QueryCondition::has_npagesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryCondition::set_has_npagesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryCondition::clear_has_npagesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryCondition::clear_npagesize() {
  npagesize_ = 0;
  clear_has_npagesize();
}
inline ::google::protobuf::int32 QueryCondition::npagesize() const {
  return npagesize_;
}
inline void QueryCondition::set_npagesize(::google::protobuf::int32 value) {
  set_has_npagesize();
  npagesize_ = value;
}

// required int32 nPageIndex = 4;
inline bool QueryCondition::has_npageindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryCondition::set_has_npageindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryCondition::clear_has_npageindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryCondition::clear_npageindex() {
  npageindex_ = 0;
  clear_has_npageindex();
}
inline ::google::protobuf::int32 QueryCondition::npageindex() const {
  return npageindex_;
}
inline void QueryCondition::set_npageindex(::google::protobuf::int32 value) {
  set_has_npageindex();
  npageindex_ = value;
}

// required int32 nReserved = 5;
inline bool QueryCondition::has_nreserved() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryCondition::set_has_nreserved() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryCondition::clear_has_nreserved() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryCondition::clear_nreserved() {
  nreserved_ = 0;
  clear_has_nreserved();
}
inline ::google::protobuf::int32 QueryCondition::nreserved() const {
  return nreserved_;
}
inline void QueryCondition::set_nreserved(::google::protobuf::int32 value) {
  set_has_nreserved();
  nreserved_ = value;
}

// required string strReserved = 6;
inline bool QueryCondition::has_strreserved() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryCondition::set_has_strreserved() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryCondition::clear_has_strreserved() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryCondition::clear_strreserved() {
  if (strreserved_ != &::google::protobuf::internal::kEmptyString) {
    strreserved_->clear();
  }
  clear_has_strreserved();
}
inline const ::std::string& QueryCondition::strreserved() const {
  return *strreserved_;
}
inline void QueryCondition::set_strreserved(const ::std::string& value) {
  set_has_strreserved();
  if (strreserved_ == &::google::protobuf::internal::kEmptyString) {
    strreserved_ = new ::std::string;
  }
  strreserved_->assign(value);
}
inline void QueryCondition::set_strreserved(const char* value) {
  set_has_strreserved();
  if (strreserved_ == &::google::protobuf::internal::kEmptyString) {
    strreserved_ = new ::std::string;
  }
  strreserved_->assign(value);
}
inline void QueryCondition::set_strreserved(const char* value, size_t size) {
  set_has_strreserved();
  if (strreserved_ == &::google::protobuf::internal::kEmptyString) {
    strreserved_ = new ::std::string;
  }
  strreserved_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCondition::mutable_strreserved() {
  set_has_strreserved();
  if (strreserved_ == &::google::protobuf::internal::kEmptyString) {
    strreserved_ = new ::std::string;
  }
  return strreserved_;
}
inline ::std::string* QueryCondition::release_strreserved() {
  clear_has_strreserved();
  if (strreserved_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strreserved_;
    strreserved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryCondition::set_allocated_strreserved(::std::string* strreserved) {
  if (strreserved_ != &::google::protobuf::internal::kEmptyString) {
    delete strreserved_;
  }
  if (strreserved) {
    set_has_strreserved();
    strreserved_ = strreserved;
  } else {
    clear_has_strreserved();
    strreserved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BusinessDockMsgInfo

// required string strChannelCode = 1;
inline bool BusinessDockMsgInfo::has_strchannelcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strchannelcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessDockMsgInfo::clear_has_strchannelcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessDockMsgInfo::clear_strchannelcode() {
  if (strchannelcode_ != &::google::protobuf::internal::kEmptyString) {
    strchannelcode_->clear();
  }
  clear_has_strchannelcode();
}
inline const ::std::string& BusinessDockMsgInfo::strchannelcode() const {
  return *strchannelcode_;
}
inline void BusinessDockMsgInfo::set_strchannelcode(const ::std::string& value) {
  set_has_strchannelcode();
  if (strchannelcode_ == &::google::protobuf::internal::kEmptyString) {
    strchannelcode_ = new ::std::string;
  }
  strchannelcode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchannelcode(const char* value) {
  set_has_strchannelcode();
  if (strchannelcode_ == &::google::protobuf::internal::kEmptyString) {
    strchannelcode_ = new ::std::string;
  }
  strchannelcode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchannelcode(const char* value, size_t size) {
  set_has_strchannelcode();
  if (strchannelcode_ == &::google::protobuf::internal::kEmptyString) {
    strchannelcode_ = new ::std::string;
  }
  strchannelcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strchannelcode() {
  set_has_strchannelcode();
  if (strchannelcode_ == &::google::protobuf::internal::kEmptyString) {
    strchannelcode_ = new ::std::string;
  }
  return strchannelcode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strchannelcode() {
  clear_has_strchannelcode();
  if (strchannelcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strchannelcode_;
    strchannelcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strchannelcode(::std::string* strchannelcode) {
  if (strchannelcode_ != &::google::protobuf::internal::kEmptyString) {
    delete strchannelcode_;
  }
  if (strchannelcode) {
    set_has_strchannelcode();
    strchannelcode_ = strchannelcode;
  } else {
    clear_has_strchannelcode();
    strchannelcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strServiceCode = 2;
inline bool BusinessDockMsgInfo::has_strservicecode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strservicecode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessDockMsgInfo::clear_has_strservicecode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessDockMsgInfo::clear_strservicecode() {
  if (strservicecode_ != &::google::protobuf::internal::kEmptyString) {
    strservicecode_->clear();
  }
  clear_has_strservicecode();
}
inline const ::std::string& BusinessDockMsgInfo::strservicecode() const {
  return *strservicecode_;
}
inline void BusinessDockMsgInfo::set_strservicecode(const ::std::string& value) {
  set_has_strservicecode();
  if (strservicecode_ == &::google::protobuf::internal::kEmptyString) {
    strservicecode_ = new ::std::string;
  }
  strservicecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strservicecode(const char* value) {
  set_has_strservicecode();
  if (strservicecode_ == &::google::protobuf::internal::kEmptyString) {
    strservicecode_ = new ::std::string;
  }
  strservicecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strservicecode(const char* value, size_t size) {
  set_has_strservicecode();
  if (strservicecode_ == &::google::protobuf::internal::kEmptyString) {
    strservicecode_ = new ::std::string;
  }
  strservicecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strservicecode() {
  set_has_strservicecode();
  if (strservicecode_ == &::google::protobuf::internal::kEmptyString) {
    strservicecode_ = new ::std::string;
  }
  return strservicecode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strservicecode() {
  clear_has_strservicecode();
  if (strservicecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strservicecode_;
    strservicecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strservicecode(::std::string* strservicecode) {
  if (strservicecode_ != &::google::protobuf::internal::kEmptyString) {
    delete strservicecode_;
  }
  if (strservicecode) {
    set_has_strservicecode();
    strservicecode_ = strservicecode;
  } else {
    clear_has_strservicecode();
    strservicecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strJDBRID = 3;
inline bool BusinessDockMsgInfo::has_strjdbrid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strjdbrid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessDockMsgInfo::clear_has_strjdbrid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessDockMsgInfo::clear_strjdbrid() {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    strjdbrid_->clear();
  }
  clear_has_strjdbrid();
}
inline const ::std::string& BusinessDockMsgInfo::strjdbrid() const {
  return *strjdbrid_;
}
inline void BusinessDockMsgInfo::set_strjdbrid(const ::std::string& value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void BusinessDockMsgInfo::set_strjdbrid(const char* value) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(value);
}
inline void BusinessDockMsgInfo::set_strjdbrid(const char* value, size_t size) {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  strjdbrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strjdbrid() {
  set_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    strjdbrid_ = new ::std::string;
  }
  return strjdbrid_;
}
inline ::std::string* BusinessDockMsgInfo::release_strjdbrid() {
  clear_has_strjdbrid();
  if (strjdbrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strjdbrid_;
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strjdbrid(::std::string* strjdbrid) {
  if (strjdbrid_ != &::google::protobuf::internal::kEmptyString) {
    delete strjdbrid_;
  }
  if (strjdbrid) {
    set_has_strjdbrid();
    strjdbrid_ = strjdbrid;
  } else {
    clear_has_strjdbrid();
    strjdbrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strOperatorId = 4;
inline bool BusinessDockMsgInfo::has_stroperatorid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessDockMsgInfo::set_has_stroperatorid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessDockMsgInfo::clear_has_stroperatorid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessDockMsgInfo::clear_stroperatorid() {
  if (stroperatorid_ != &::google::protobuf::internal::kEmptyString) {
    stroperatorid_->clear();
  }
  clear_has_stroperatorid();
}
inline const ::std::string& BusinessDockMsgInfo::stroperatorid() const {
  return *stroperatorid_;
}
inline void BusinessDockMsgInfo::set_stroperatorid(const ::std::string& value) {
  set_has_stroperatorid();
  if (stroperatorid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatorid_ = new ::std::string;
  }
  stroperatorid_->assign(value);
}
inline void BusinessDockMsgInfo::set_stroperatorid(const char* value) {
  set_has_stroperatorid();
  if (stroperatorid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatorid_ = new ::std::string;
  }
  stroperatorid_->assign(value);
}
inline void BusinessDockMsgInfo::set_stroperatorid(const char* value, size_t size) {
  set_has_stroperatorid();
  if (stroperatorid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatorid_ = new ::std::string;
  }
  stroperatorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_stroperatorid() {
  set_has_stroperatorid();
  if (stroperatorid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatorid_ = new ::std::string;
  }
  return stroperatorid_;
}
inline ::std::string* BusinessDockMsgInfo::release_stroperatorid() {
  clear_has_stroperatorid();
  if (stroperatorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroperatorid_;
    stroperatorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_stroperatorid(::std::string* stroperatorid) {
  if (stroperatorid_ != &::google::protobuf::internal::kEmptyString) {
    delete stroperatorid_;
  }
  if (stroperatorid) {
    set_has_stroperatorid();
    stroperatorid_ = stroperatorid;
  } else {
    clear_has_stroperatorid();
    stroperatorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strChannelSerialNum = 5;
inline bool BusinessDockMsgInfo::has_strchannelserialnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strchannelserialnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessDockMsgInfo::clear_has_strchannelserialnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessDockMsgInfo::clear_strchannelserialnum() {
  if (strchannelserialnum_ != &::google::protobuf::internal::kEmptyString) {
    strchannelserialnum_->clear();
  }
  clear_has_strchannelserialnum();
}
inline const ::std::string& BusinessDockMsgInfo::strchannelserialnum() const {
  return *strchannelserialnum_;
}
inline void BusinessDockMsgInfo::set_strchannelserialnum(const ::std::string& value) {
  set_has_strchannelserialnum();
  if (strchannelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strchannelserialnum_ = new ::std::string;
  }
  strchannelserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchannelserialnum(const char* value) {
  set_has_strchannelserialnum();
  if (strchannelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strchannelserialnum_ = new ::std::string;
  }
  strchannelserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchannelserialnum(const char* value, size_t size) {
  set_has_strchannelserialnum();
  if (strchannelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strchannelserialnum_ = new ::std::string;
  }
  strchannelserialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strchannelserialnum() {
  set_has_strchannelserialnum();
  if (strchannelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strchannelserialnum_ = new ::std::string;
  }
  return strchannelserialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strchannelserialnum() {
  clear_has_strchannelserialnum();
  if (strchannelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strchannelserialnum_;
    strchannelserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strchannelserialnum(::std::string* strchannelserialnum) {
  if (strchannelserialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strchannelserialnum_;
  }
  if (strchannelserialnum) {
    set_has_strchannelserialnum();
    strchannelserialnum_ = strchannelserialnum;
  } else {
    clear_has_strchannelserialnum();
    strchannelserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strKernelSerialNum = 6;
inline bool BusinessDockMsgInfo::has_strkernelserialnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strkernelserialnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessDockMsgInfo::clear_has_strkernelserialnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessDockMsgInfo::clear_strkernelserialnum() {
  if (strkernelserialnum_ != &::google::protobuf::internal::kEmptyString) {
    strkernelserialnum_->clear();
  }
  clear_has_strkernelserialnum();
}
inline const ::std::string& BusinessDockMsgInfo::strkernelserialnum() const {
  return *strkernelserialnum_;
}
inline void BusinessDockMsgInfo::set_strkernelserialnum(const ::std::string& value) {
  set_has_strkernelserialnum();
  if (strkernelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strkernelserialnum_ = new ::std::string;
  }
  strkernelserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strkernelserialnum(const char* value) {
  set_has_strkernelserialnum();
  if (strkernelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strkernelserialnum_ = new ::std::string;
  }
  strkernelserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strkernelserialnum(const char* value, size_t size) {
  set_has_strkernelserialnum();
  if (strkernelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strkernelserialnum_ = new ::std::string;
  }
  strkernelserialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strkernelserialnum() {
  set_has_strkernelserialnum();
  if (strkernelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strkernelserialnum_ = new ::std::string;
  }
  return strkernelserialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strkernelserialnum() {
  clear_has_strkernelserialnum();
  if (strkernelserialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strkernelserialnum_;
    strkernelserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strkernelserialnum(::std::string* strkernelserialnum) {
  if (strkernelserialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strkernelserialnum_;
  }
  if (strkernelserialnum) {
    set_has_strkernelserialnum();
    strkernelserialnum_ = strkernelserialnum;
  } else {
    clear_has_strkernelserialnum();
    strkernelserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strDateTime = 7;
inline bool BusinessDockMsgInfo::has_strdatetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strdatetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BusinessDockMsgInfo::clear_has_strdatetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BusinessDockMsgInfo::clear_strdatetime() {
  if (strdatetime_ != &::google::protobuf::internal::kEmptyString) {
    strdatetime_->clear();
  }
  clear_has_strdatetime();
}
inline const ::std::string& BusinessDockMsgInfo::strdatetime() const {
  return *strdatetime_;
}
inline void BusinessDockMsgInfo::set_strdatetime(const ::std::string& value) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(value);
}
inline void BusinessDockMsgInfo::set_strdatetime(const char* value) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(value);
}
inline void BusinessDockMsgInfo::set_strdatetime(const char* value, size_t size) {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  strdatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strdatetime() {
  set_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    strdatetime_ = new ::std::string;
  }
  return strdatetime_;
}
inline ::std::string* BusinessDockMsgInfo::release_strdatetime() {
  clear_has_strdatetime();
  if (strdatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdatetime_;
    strdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strdatetime(::std::string* strdatetime) {
  if (strdatetime_ != &::google::protobuf::internal::kEmptyString) {
    delete strdatetime_;
  }
  if (strdatetime) {
    set_has_strdatetime();
    strdatetime_ = strdatetime;
  } else {
    clear_has_strdatetime();
    strdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strChannelDate = 8;
inline bool BusinessDockMsgInfo::has_strchanneldate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strchanneldate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BusinessDockMsgInfo::clear_has_strchanneldate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BusinessDockMsgInfo::clear_strchanneldate() {
  if (strchanneldate_ != &::google::protobuf::internal::kEmptyString) {
    strchanneldate_->clear();
  }
  clear_has_strchanneldate();
}
inline const ::std::string& BusinessDockMsgInfo::strchanneldate() const {
  return *strchanneldate_;
}
inline void BusinessDockMsgInfo::set_strchanneldate(const ::std::string& value) {
  set_has_strchanneldate();
  if (strchanneldate_ == &::google::protobuf::internal::kEmptyString) {
    strchanneldate_ = new ::std::string;
  }
  strchanneldate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchanneldate(const char* value) {
  set_has_strchanneldate();
  if (strchanneldate_ == &::google::protobuf::internal::kEmptyString) {
    strchanneldate_ = new ::std::string;
  }
  strchanneldate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchanneldate(const char* value, size_t size) {
  set_has_strchanneldate();
  if (strchanneldate_ == &::google::protobuf::internal::kEmptyString) {
    strchanneldate_ = new ::std::string;
  }
  strchanneldate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strchanneldate() {
  set_has_strchanneldate();
  if (strchanneldate_ == &::google::protobuf::internal::kEmptyString) {
    strchanneldate_ = new ::std::string;
  }
  return strchanneldate_;
}
inline ::std::string* BusinessDockMsgInfo::release_strchanneldate() {
  clear_has_strchanneldate();
  if (strchanneldate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strchanneldate_;
    strchanneldate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strchanneldate(::std::string* strchanneldate) {
  if (strchanneldate_ != &::google::protobuf::internal::kEmptyString) {
    delete strchanneldate_;
  }
  if (strchanneldate) {
    set_has_strchanneldate();
    strchanneldate_ = strchanneldate;
  } else {
    clear_has_strchanneldate();
    strchanneldate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strRepondCode = 9;
inline bool BusinessDockMsgInfo::has_strrepondcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strrepondcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BusinessDockMsgInfo::clear_has_strrepondcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BusinessDockMsgInfo::clear_strrepondcode() {
  if (strrepondcode_ != &::google::protobuf::internal::kEmptyString) {
    strrepondcode_->clear();
  }
  clear_has_strrepondcode();
}
inline const ::std::string& BusinessDockMsgInfo::strrepondcode() const {
  return *strrepondcode_;
}
inline void BusinessDockMsgInfo::set_strrepondcode(const ::std::string& value) {
  set_has_strrepondcode();
  if (strrepondcode_ == &::google::protobuf::internal::kEmptyString) {
    strrepondcode_ = new ::std::string;
  }
  strrepondcode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strrepondcode(const char* value) {
  set_has_strrepondcode();
  if (strrepondcode_ == &::google::protobuf::internal::kEmptyString) {
    strrepondcode_ = new ::std::string;
  }
  strrepondcode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strrepondcode(const char* value, size_t size) {
  set_has_strrepondcode();
  if (strrepondcode_ == &::google::protobuf::internal::kEmptyString) {
    strrepondcode_ = new ::std::string;
  }
  strrepondcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strrepondcode() {
  set_has_strrepondcode();
  if (strrepondcode_ == &::google::protobuf::internal::kEmptyString) {
    strrepondcode_ = new ::std::string;
  }
  return strrepondcode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strrepondcode() {
  clear_has_strrepondcode();
  if (strrepondcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrepondcode_;
    strrepondcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strrepondcode(::std::string* strrepondcode) {
  if (strrepondcode_ != &::google::protobuf::internal::kEmptyString) {
    delete strrepondcode_;
  }
  if (strrepondcode) {
    set_has_strrepondcode();
    strrepondcode_ = strrepondcode;
  } else {
    clear_has_strrepondcode();
    strrepondcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strChineseDescribeInfo = 10;
inline bool BusinessDockMsgInfo::has_strchinesedescribeinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strchinesedescribeinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BusinessDockMsgInfo::clear_has_strchinesedescribeinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BusinessDockMsgInfo::clear_strchinesedescribeinfo() {
  if (strchinesedescribeinfo_ != &::google::protobuf::internal::kEmptyString) {
    strchinesedescribeinfo_->clear();
  }
  clear_has_strchinesedescribeinfo();
}
inline const ::std::string& BusinessDockMsgInfo::strchinesedescribeinfo() const {
  return *strchinesedescribeinfo_;
}
inline void BusinessDockMsgInfo::set_strchinesedescribeinfo(const ::std::string& value) {
  set_has_strchinesedescribeinfo();
  if (strchinesedescribeinfo_ == &::google::protobuf::internal::kEmptyString) {
    strchinesedescribeinfo_ = new ::std::string;
  }
  strchinesedescribeinfo_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchinesedescribeinfo(const char* value) {
  set_has_strchinesedescribeinfo();
  if (strchinesedescribeinfo_ == &::google::protobuf::internal::kEmptyString) {
    strchinesedescribeinfo_ = new ::std::string;
  }
  strchinesedescribeinfo_->assign(value);
}
inline void BusinessDockMsgInfo::set_strchinesedescribeinfo(const char* value, size_t size) {
  set_has_strchinesedescribeinfo();
  if (strchinesedescribeinfo_ == &::google::protobuf::internal::kEmptyString) {
    strchinesedescribeinfo_ = new ::std::string;
  }
  strchinesedescribeinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strchinesedescribeinfo() {
  set_has_strchinesedescribeinfo();
  if (strchinesedescribeinfo_ == &::google::protobuf::internal::kEmptyString) {
    strchinesedescribeinfo_ = new ::std::string;
  }
  return strchinesedescribeinfo_;
}
inline ::std::string* BusinessDockMsgInfo::release_strchinesedescribeinfo() {
  clear_has_strchinesedescribeinfo();
  if (strchinesedescribeinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strchinesedescribeinfo_;
    strchinesedescribeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strchinesedescribeinfo(::std::string* strchinesedescribeinfo) {
  if (strchinesedescribeinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete strchinesedescribeinfo_;
  }
  if (strchinesedescribeinfo) {
    set_has_strchinesedescribeinfo();
    strchinesedescribeinfo_ = strchinesedescribeinfo;
  } else {
    clear_has_strchinesedescribeinfo();
    strchinesedescribeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessCode = 11;
inline bool BusinessDockMsgInfo::has_strbusinesscode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strbusinesscode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BusinessDockMsgInfo::clear_has_strbusinesscode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BusinessDockMsgInfo::clear_strbusinesscode() {
  if (strbusinesscode_ != &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_->clear();
  }
  clear_has_strbusinesscode();
}
inline const ::std::string& BusinessDockMsgInfo::strbusinesscode() const {
  return *strbusinesscode_;
}
inline void BusinessDockMsgInfo::set_strbusinesscode(const ::std::string& value) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinesscode(const char* value) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinesscode(const char* value, size_t size) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strbusinesscode() {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  return strbusinesscode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strbusinesscode() {
  clear_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinesscode_;
    strbusinesscode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strbusinesscode(::std::string* strbusinesscode) {
  if (strbusinesscode_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinesscode_;
  }
  if (strbusinesscode) {
    set_has_strbusinesscode();
    strbusinesscode_ = strbusinesscode;
  } else {
    clear_has_strbusinesscode();
    strbusinesscode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessName = 12;
inline bool BusinessDockMsgInfo::has_strbusinessname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strbusinessname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BusinessDockMsgInfo::clear_has_strbusinessname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BusinessDockMsgInfo::clear_strbusinessname() {
  if (strbusinessname_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessname_->clear();
  }
  clear_has_strbusinessname();
}
inline const ::std::string& BusinessDockMsgInfo::strbusinessname() const {
  return *strbusinessname_;
}
inline void BusinessDockMsgInfo::set_strbusinessname(const ::std::string& value) {
  set_has_strbusinessname();
  if (strbusinessname_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessname_ = new ::std::string;
  }
  strbusinessname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessname(const char* value) {
  set_has_strbusinessname();
  if (strbusinessname_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessname_ = new ::std::string;
  }
  strbusinessname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessname(const char* value, size_t size) {
  set_has_strbusinessname();
  if (strbusinessname_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessname_ = new ::std::string;
  }
  strbusinessname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strbusinessname() {
  set_has_strbusinessname();
  if (strbusinessname_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessname_ = new ::std::string;
  }
  return strbusinessname_;
}
inline ::std::string* BusinessDockMsgInfo::release_strbusinessname() {
  clear_has_strbusinessname();
  if (strbusinessname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessname_;
    strbusinessname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strbusinessname(::std::string* strbusinessname) {
  if (strbusinessname_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessname_;
  }
  if (strbusinessname) {
    set_has_strbusinessname();
    strbusinessname_ = strbusinessname;
  } else {
    clear_has_strbusinessname();
    strbusinessname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessStatus = 13;
inline bool BusinessDockMsgInfo::has_strbusinessstatus() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strbusinessstatus() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BusinessDockMsgInfo::clear_has_strbusinessstatus() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BusinessDockMsgInfo::clear_strbusinessstatus() {
  if (strbusinessstatus_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessstatus_->clear();
  }
  clear_has_strbusinessstatus();
}
inline const ::std::string& BusinessDockMsgInfo::strbusinessstatus() const {
  return *strbusinessstatus_;
}
inline void BusinessDockMsgInfo::set_strbusinessstatus(const ::std::string& value) {
  set_has_strbusinessstatus();
  if (strbusinessstatus_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessstatus_ = new ::std::string;
  }
  strbusinessstatus_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessstatus(const char* value) {
  set_has_strbusinessstatus();
  if (strbusinessstatus_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessstatus_ = new ::std::string;
  }
  strbusinessstatus_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessstatus(const char* value, size_t size) {
  set_has_strbusinessstatus();
  if (strbusinessstatus_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessstatus_ = new ::std::string;
  }
  strbusinessstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strbusinessstatus() {
  set_has_strbusinessstatus();
  if (strbusinessstatus_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessstatus_ = new ::std::string;
  }
  return strbusinessstatus_;
}
inline ::std::string* BusinessDockMsgInfo::release_strbusinessstatus() {
  clear_has_strbusinessstatus();
  if (strbusinessstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessstatus_;
    strbusinessstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strbusinessstatus(::std::string* strbusinessstatus) {
  if (strbusinessstatus_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessstatus_;
  }
  if (strbusinessstatus) {
    set_has_strbusinessstatus();
    strbusinessstatus_ = strbusinessstatus;
  } else {
    clear_has_strbusinessstatus();
    strbusinessstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceCode = 14;
inline bool BusinessDockMsgInfo::has_strproducecode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strproducecode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BusinessDockMsgInfo::clear_has_strproducecode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BusinessDockMsgInfo::clear_strproducecode() {
  if (strproducecode_ != &::google::protobuf::internal::kEmptyString) {
    strproducecode_->clear();
  }
  clear_has_strproducecode();
}
inline const ::std::string& BusinessDockMsgInfo::strproducecode() const {
  return *strproducecode_;
}
inline void BusinessDockMsgInfo::set_strproducecode(const ::std::string& value) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducecode(const char* value) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducecode(const char* value, size_t size) {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  strproducecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strproducecode() {
  set_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strproducecode_ = new ::std::string;
  }
  return strproducecode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strproducecode() {
  clear_has_strproducecode();
  if (strproducecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproducecode_;
    strproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strproducecode(::std::string* strproducecode) {
  if (strproducecode_ != &::google::protobuf::internal::kEmptyString) {
    delete strproducecode_;
  }
  if (strproducecode) {
    set_has_strproducecode();
    strproducecode_ = strproducecode;
  } else {
    clear_has_strproducecode();
    strproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strObjectProduceCode = 15;
inline bool BusinessDockMsgInfo::has_strobjectproducecode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strobjectproducecode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BusinessDockMsgInfo::clear_has_strobjectproducecode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BusinessDockMsgInfo::clear_strobjectproducecode() {
  if (strobjectproducecode_ != &::google::protobuf::internal::kEmptyString) {
    strobjectproducecode_->clear();
  }
  clear_has_strobjectproducecode();
}
inline const ::std::string& BusinessDockMsgInfo::strobjectproducecode() const {
  return *strobjectproducecode_;
}
inline void BusinessDockMsgInfo::set_strobjectproducecode(const ::std::string& value) {
  set_has_strobjectproducecode();
  if (strobjectproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strobjectproducecode_ = new ::std::string;
  }
  strobjectproducecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strobjectproducecode(const char* value) {
  set_has_strobjectproducecode();
  if (strobjectproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strobjectproducecode_ = new ::std::string;
  }
  strobjectproducecode_->assign(value);
}
inline void BusinessDockMsgInfo::set_strobjectproducecode(const char* value, size_t size) {
  set_has_strobjectproducecode();
  if (strobjectproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strobjectproducecode_ = new ::std::string;
  }
  strobjectproducecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strobjectproducecode() {
  set_has_strobjectproducecode();
  if (strobjectproducecode_ == &::google::protobuf::internal::kEmptyString) {
    strobjectproducecode_ = new ::std::string;
  }
  return strobjectproducecode_;
}
inline ::std::string* BusinessDockMsgInfo::release_strobjectproducecode() {
  clear_has_strobjectproducecode();
  if (strobjectproducecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strobjectproducecode_;
    strobjectproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strobjectproducecode(::std::string* strobjectproducecode) {
  if (strobjectproducecode_ != &::google::protobuf::internal::kEmptyString) {
    delete strobjectproducecode_;
  }
  if (strobjectproducecode) {
    set_has_strobjectproducecode();
    strobjectproducecode_ = strobjectproducecode;
  } else {
    clear_has_strobjectproducecode();
    strobjectproducecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strFundName = 16;
inline bool BusinessDockMsgInfo::has_strfundname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strfundname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BusinessDockMsgInfo::clear_has_strfundname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BusinessDockMsgInfo::clear_strfundname() {
  if (strfundname_ != &::google::protobuf::internal::kEmptyString) {
    strfundname_->clear();
  }
  clear_has_strfundname();
}
inline const ::std::string& BusinessDockMsgInfo::strfundname() const {
  return *strfundname_;
}
inline void BusinessDockMsgInfo::set_strfundname(const ::std::string& value) {
  set_has_strfundname();
  if (strfundname_ == &::google::protobuf::internal::kEmptyString) {
    strfundname_ = new ::std::string;
  }
  strfundname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfundname(const char* value) {
  set_has_strfundname();
  if (strfundname_ == &::google::protobuf::internal::kEmptyString) {
    strfundname_ = new ::std::string;
  }
  strfundname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfundname(const char* value, size_t size) {
  set_has_strfundname();
  if (strfundname_ == &::google::protobuf::internal::kEmptyString) {
    strfundname_ = new ::std::string;
  }
  strfundname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strfundname() {
  set_has_strfundname();
  if (strfundname_ == &::google::protobuf::internal::kEmptyString) {
    strfundname_ = new ::std::string;
  }
  return strfundname_;
}
inline ::std::string* BusinessDockMsgInfo::release_strfundname() {
  clear_has_strfundname();
  if (strfundname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strfundname_;
    strfundname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strfundname(::std::string* strfundname) {
  if (strfundname_ != &::google::protobuf::internal::kEmptyString) {
    delete strfundname_;
  }
  if (strfundname) {
    set_has_strfundname();
    strfundname_ = strfundname;
  } else {
    clear_has_strfundname();
    strfundname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceName = 17;
inline bool BusinessDockMsgInfo::has_strproducename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strproducename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BusinessDockMsgInfo::clear_has_strproducename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BusinessDockMsgInfo::clear_strproducename() {
  if (strproducename_ != &::google::protobuf::internal::kEmptyString) {
    strproducename_->clear();
  }
  clear_has_strproducename();
}
inline const ::std::string& BusinessDockMsgInfo::strproducename() const {
  return *strproducename_;
}
inline void BusinessDockMsgInfo::set_strproducename(const ::std::string& value) {
  set_has_strproducename();
  if (strproducename_ == &::google::protobuf::internal::kEmptyString) {
    strproducename_ = new ::std::string;
  }
  strproducename_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducename(const char* value) {
  set_has_strproducename();
  if (strproducename_ == &::google::protobuf::internal::kEmptyString) {
    strproducename_ = new ::std::string;
  }
  strproducename_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducename(const char* value, size_t size) {
  set_has_strproducename();
  if (strproducename_ == &::google::protobuf::internal::kEmptyString) {
    strproducename_ = new ::std::string;
  }
  strproducename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strproducename() {
  set_has_strproducename();
  if (strproducename_ == &::google::protobuf::internal::kEmptyString) {
    strproducename_ = new ::std::string;
  }
  return strproducename_;
}
inline ::std::string* BusinessDockMsgInfo::release_strproducename() {
  clear_has_strproducename();
  if (strproducename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproducename_;
    strproducename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strproducename(::std::string* strproducename) {
  if (strproducename_ != &::google::protobuf::internal::kEmptyString) {
    delete strproducename_;
  }
  if (strproducename) {
    set_has_strproducename();
    strproducename_ = strproducename;
  } else {
    clear_has_strproducename();
    strproducename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strIncomeType = 18;
inline bool BusinessDockMsgInfo::has_strincometype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strincometype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BusinessDockMsgInfo::clear_has_strincometype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BusinessDockMsgInfo::clear_strincometype() {
  if (strincometype_ != &::google::protobuf::internal::kEmptyString) {
    strincometype_->clear();
  }
  clear_has_strincometype();
}
inline const ::std::string& BusinessDockMsgInfo::strincometype() const {
  return *strincometype_;
}
inline void BusinessDockMsgInfo::set_strincometype(const ::std::string& value) {
  set_has_strincometype();
  if (strincometype_ == &::google::protobuf::internal::kEmptyString) {
    strincometype_ = new ::std::string;
  }
  strincometype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strincometype(const char* value) {
  set_has_strincometype();
  if (strincometype_ == &::google::protobuf::internal::kEmptyString) {
    strincometype_ = new ::std::string;
  }
  strincometype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strincometype(const char* value, size_t size) {
  set_has_strincometype();
  if (strincometype_ == &::google::protobuf::internal::kEmptyString) {
    strincometype_ = new ::std::string;
  }
  strincometype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strincometype() {
  set_has_strincometype();
  if (strincometype_ == &::google::protobuf::internal::kEmptyString) {
    strincometype_ = new ::std::string;
  }
  return strincometype_;
}
inline ::std::string* BusinessDockMsgInfo::release_strincometype() {
  clear_has_strincometype();
  if (strincometype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strincometype_;
    strincometype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strincometype(::std::string* strincometype) {
  if (strincometype_ != &::google::protobuf::internal::kEmptyString) {
    delete strincometype_;
  }
  if (strincometype) {
    set_has_strincometype();
    strincometype_ = strincometype;
  } else {
    clear_has_strincometype();
    strincometype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessDate = 19;
inline bool BusinessDockMsgInfo::has_strbusinessdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strbusinessdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BusinessDockMsgInfo::clear_has_strbusinessdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BusinessDockMsgInfo::clear_strbusinessdate() {
  if (strbusinessdate_ != &::google::protobuf::internal::kEmptyString) {
    strbusinessdate_->clear();
  }
  clear_has_strbusinessdate();
}
inline const ::std::string& BusinessDockMsgInfo::strbusinessdate() const {
  return *strbusinessdate_;
}
inline void BusinessDockMsgInfo::set_strbusinessdate(const ::std::string& value) {
  set_has_strbusinessdate();
  if (strbusinessdate_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessdate_ = new ::std::string;
  }
  strbusinessdate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessdate(const char* value) {
  set_has_strbusinessdate();
  if (strbusinessdate_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessdate_ = new ::std::string;
  }
  strbusinessdate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strbusinessdate(const char* value, size_t size) {
  set_has_strbusinessdate();
  if (strbusinessdate_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessdate_ = new ::std::string;
  }
  strbusinessdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strbusinessdate() {
  set_has_strbusinessdate();
  if (strbusinessdate_ == &::google::protobuf::internal::kEmptyString) {
    strbusinessdate_ = new ::std::string;
  }
  return strbusinessdate_;
}
inline ::std::string* BusinessDockMsgInfo::release_strbusinessdate() {
  clear_has_strbusinessdate();
  if (strbusinessdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinessdate_;
    strbusinessdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strbusinessdate(::std::string* strbusinessdate) {
  if (strbusinessdate_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinessdate_;
  }
  if (strbusinessdate) {
    set_has_strbusinessdate();
    strbusinessdate_ = strbusinessdate;
  } else {
    clear_has_strbusinessdate();
    strbusinessdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strClientName = 20;
inline bool BusinessDockMsgInfo::has_strclientname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strclientname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BusinessDockMsgInfo::clear_has_strclientname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BusinessDockMsgInfo::clear_strclientname() {
  if (strclientname_ != &::google::protobuf::internal::kEmptyString) {
    strclientname_->clear();
  }
  clear_has_strclientname();
}
inline const ::std::string& BusinessDockMsgInfo::strclientname() const {
  return *strclientname_;
}
inline void BusinessDockMsgInfo::set_strclientname(const ::std::string& value) {
  set_has_strclientname();
  if (strclientname_ == &::google::protobuf::internal::kEmptyString) {
    strclientname_ = new ::std::string;
  }
  strclientname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strclientname(const char* value) {
  set_has_strclientname();
  if (strclientname_ == &::google::protobuf::internal::kEmptyString) {
    strclientname_ = new ::std::string;
  }
  strclientname_->assign(value);
}
inline void BusinessDockMsgInfo::set_strclientname(const char* value, size_t size) {
  set_has_strclientname();
  if (strclientname_ == &::google::protobuf::internal::kEmptyString) {
    strclientname_ = new ::std::string;
  }
  strclientname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strclientname() {
  set_has_strclientname();
  if (strclientname_ == &::google::protobuf::internal::kEmptyString) {
    strclientname_ = new ::std::string;
  }
  return strclientname_;
}
inline ::std::string* BusinessDockMsgInfo::release_strclientname() {
  clear_has_strclientname();
  if (strclientname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strclientname_;
    strclientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strclientname(::std::string* strclientname) {
  if (strclientname_ != &::google::protobuf::internal::kEmptyString) {
    delete strclientname_;
  }
  if (strclientname) {
    set_has_strclientname();
    strclientname_ = strclientname;
  } else {
    clear_has_strclientname();
    strclientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCredenitialsType = 21;
inline bool BusinessDockMsgInfo::has_strcredenitialstype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strcredenitialstype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BusinessDockMsgInfo::clear_has_strcredenitialstype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BusinessDockMsgInfo::clear_strcredenitialstype() {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_->clear();
  }
  clear_has_strcredenitialstype();
}
inline const ::std::string& BusinessDockMsgInfo::strcredenitialstype() const {
  return *strcredenitialstype_;
}
inline void BusinessDockMsgInfo::set_strcredenitialstype(const ::std::string& value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcredenitialstype(const char* value) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcredenitialstype(const char* value, size_t size) {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  strcredenitialstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strcredenitialstype() {
  set_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialstype_ = new ::std::string;
  }
  return strcredenitialstype_;
}
inline ::std::string* BusinessDockMsgInfo::release_strcredenitialstype() {
  clear_has_strcredenitialstype();
  if (strcredenitialstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcredenitialstype_;
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strcredenitialstype(::std::string* strcredenitialstype) {
  if (strcredenitialstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcredenitialstype_;
  }
  if (strcredenitialstype) {
    set_has_strcredenitialstype();
    strcredenitialstype_ = strcredenitialstype;
  } else {
    clear_has_strcredenitialstype();
    strcredenitialstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCredenitialNum = 22;
inline bool BusinessDockMsgInfo::has_strcredenitialnum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strcredenitialnum() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BusinessDockMsgInfo::clear_has_strcredenitialnum() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BusinessDockMsgInfo::clear_strcredenitialnum() {
  if (strcredenitialnum_ != &::google::protobuf::internal::kEmptyString) {
    strcredenitialnum_->clear();
  }
  clear_has_strcredenitialnum();
}
inline const ::std::string& BusinessDockMsgInfo::strcredenitialnum() const {
  return *strcredenitialnum_;
}
inline void BusinessDockMsgInfo::set_strcredenitialnum(const ::std::string& value) {
  set_has_strcredenitialnum();
  if (strcredenitialnum_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialnum_ = new ::std::string;
  }
  strcredenitialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcredenitialnum(const char* value) {
  set_has_strcredenitialnum();
  if (strcredenitialnum_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialnum_ = new ::std::string;
  }
  strcredenitialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcredenitialnum(const char* value, size_t size) {
  set_has_strcredenitialnum();
  if (strcredenitialnum_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialnum_ = new ::std::string;
  }
  strcredenitialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strcredenitialnum() {
  set_has_strcredenitialnum();
  if (strcredenitialnum_ == &::google::protobuf::internal::kEmptyString) {
    strcredenitialnum_ = new ::std::string;
  }
  return strcredenitialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strcredenitialnum() {
  clear_has_strcredenitialnum();
  if (strcredenitialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcredenitialnum_;
    strcredenitialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strcredenitialnum(::std::string* strcredenitialnum) {
  if (strcredenitialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strcredenitialnum_;
  }
  if (strcredenitialnum) {
    set_has_strcredenitialnum();
    strcredenitialnum_ = strcredenitialnum;
  } else {
    clear_has_strcredenitialnum();
    strcredenitialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMediumType = 23;
inline bool BusinessDockMsgInfo::has_strmediumtype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strmediumtype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BusinessDockMsgInfo::clear_has_strmediumtype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BusinessDockMsgInfo::clear_strmediumtype() {
  if (strmediumtype_ != &::google::protobuf::internal::kEmptyString) {
    strmediumtype_->clear();
  }
  clear_has_strmediumtype();
}
inline const ::std::string& BusinessDockMsgInfo::strmediumtype() const {
  return *strmediumtype_;
}
inline void BusinessDockMsgInfo::set_strmediumtype(const ::std::string& value) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strmediumtype(const char* value) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strmediumtype(const char* value, size_t size) {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  strmediumtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strmediumtype() {
  set_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    strmediumtype_ = new ::std::string;
  }
  return strmediumtype_;
}
inline ::std::string* BusinessDockMsgInfo::release_strmediumtype() {
  clear_has_strmediumtype();
  if (strmediumtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmediumtype_;
    strmediumtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strmediumtype(::std::string* strmediumtype) {
  if (strmediumtype_ != &::google::protobuf::internal::kEmptyString) {
    delete strmediumtype_;
  }
  if (strmediumtype) {
    set_has_strmediumtype();
    strmediumtype_ = strmediumtype;
  } else {
    clear_has_strmediumtype();
    strmediumtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strMediumNum = 24;
inline bool BusinessDockMsgInfo::has_strmediumnum() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strmediumnum() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BusinessDockMsgInfo::clear_has_strmediumnum() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BusinessDockMsgInfo::clear_strmediumnum() {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    strmediumnum_->clear();
  }
  clear_has_strmediumnum();
}
inline const ::std::string& BusinessDockMsgInfo::strmediumnum() const {
  return *strmediumnum_;
}
inline void BusinessDockMsgInfo::set_strmediumnum(const ::std::string& value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strmediumnum(const char* value) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strmediumnum(const char* value, size_t size) {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  strmediumnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strmediumnum() {
  set_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    strmediumnum_ = new ::std::string;
  }
  return strmediumnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strmediumnum() {
  clear_has_strmediumnum();
  if (strmediumnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmediumnum_;
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strmediumnum(::std::string* strmediumnum) {
  if (strmediumnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strmediumnum_;
  }
  if (strmediumnum) {
    set_has_strmediumnum();
    strmediumnum_ = strmediumnum;
  } else {
    clear_has_strmediumnum();
    strmediumnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strClientRiskLevel = 25;
inline bool BusinessDockMsgInfo::has_strclientrisklevel() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strclientrisklevel() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BusinessDockMsgInfo::clear_has_strclientrisklevel() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BusinessDockMsgInfo::clear_strclientrisklevel() {
  if (strclientrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strclientrisklevel_->clear();
  }
  clear_has_strclientrisklevel();
}
inline const ::std::string& BusinessDockMsgInfo::strclientrisklevel() const {
  return *strclientrisklevel_;
}
inline void BusinessDockMsgInfo::set_strclientrisklevel(const ::std::string& value) {
  set_has_strclientrisklevel();
  if (strclientrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strclientrisklevel_ = new ::std::string;
  }
  strclientrisklevel_->assign(value);
}
inline void BusinessDockMsgInfo::set_strclientrisklevel(const char* value) {
  set_has_strclientrisklevel();
  if (strclientrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strclientrisklevel_ = new ::std::string;
  }
  strclientrisklevel_->assign(value);
}
inline void BusinessDockMsgInfo::set_strclientrisklevel(const char* value, size_t size) {
  set_has_strclientrisklevel();
  if (strclientrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strclientrisklevel_ = new ::std::string;
  }
  strclientrisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strclientrisklevel() {
  set_has_strclientrisklevel();
  if (strclientrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strclientrisklevel_ = new ::std::string;
  }
  return strclientrisklevel_;
}
inline ::std::string* BusinessDockMsgInfo::release_strclientrisklevel() {
  clear_has_strclientrisklevel();
  if (strclientrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strclientrisklevel_;
    strclientrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strclientrisklevel(::std::string* strclientrisklevel) {
  if (strclientrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    delete strclientrisklevel_;
  }
  if (strclientrisklevel) {
    set_has_strclientrisklevel();
    strclientrisklevel_ = strclientrisklevel;
  } else {
    clear_has_strclientrisklevel();
    strclientrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strProduceRiskLevel = 26;
inline bool BusinessDockMsgInfo::has_strproducerisklevel() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strproducerisklevel() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BusinessDockMsgInfo::clear_has_strproducerisklevel() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BusinessDockMsgInfo::clear_strproducerisklevel() {
  if (strproducerisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strproducerisklevel_->clear();
  }
  clear_has_strproducerisklevel();
}
inline const ::std::string& BusinessDockMsgInfo::strproducerisklevel() const {
  return *strproducerisklevel_;
}
inline void BusinessDockMsgInfo::set_strproducerisklevel(const ::std::string& value) {
  set_has_strproducerisklevel();
  if (strproducerisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strproducerisklevel_ = new ::std::string;
  }
  strproducerisklevel_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducerisklevel(const char* value) {
  set_has_strproducerisklevel();
  if (strproducerisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strproducerisklevel_ = new ::std::string;
  }
  strproducerisklevel_->assign(value);
}
inline void BusinessDockMsgInfo::set_strproducerisklevel(const char* value, size_t size) {
  set_has_strproducerisklevel();
  if (strproducerisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strproducerisklevel_ = new ::std::string;
  }
  strproducerisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strproducerisklevel() {
  set_has_strproducerisklevel();
  if (strproducerisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strproducerisklevel_ = new ::std::string;
  }
  return strproducerisklevel_;
}
inline ::std::string* BusinessDockMsgInfo::release_strproducerisklevel() {
  clear_has_strproducerisklevel();
  if (strproducerisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strproducerisklevel_;
    strproducerisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strproducerisklevel(::std::string* strproducerisklevel) {
  if (strproducerisklevel_ != &::google::protobuf::internal::kEmptyString) {
    delete strproducerisklevel_;
  }
  if (strproducerisklevel) {
    set_has_strproducerisklevel();
    strproducerisklevel_ = strproducerisklevel;
  } else {
    clear_has_strproducerisklevel();
    strproducerisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strFundType = 27;
inline bool BusinessDockMsgInfo::has_strfundtype() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strfundtype() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BusinessDockMsgInfo::clear_has_strfundtype() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BusinessDockMsgInfo::clear_strfundtype() {
  if (strfundtype_ != &::google::protobuf::internal::kEmptyString) {
    strfundtype_->clear();
  }
  clear_has_strfundtype();
}
inline const ::std::string& BusinessDockMsgInfo::strfundtype() const {
  return *strfundtype_;
}
inline void BusinessDockMsgInfo::set_strfundtype(const ::std::string& value) {
  set_has_strfundtype();
  if (strfundtype_ == &::google::protobuf::internal::kEmptyString) {
    strfundtype_ = new ::std::string;
  }
  strfundtype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfundtype(const char* value) {
  set_has_strfundtype();
  if (strfundtype_ == &::google::protobuf::internal::kEmptyString) {
    strfundtype_ = new ::std::string;
  }
  strfundtype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfundtype(const char* value, size_t size) {
  set_has_strfundtype();
  if (strfundtype_ == &::google::protobuf::internal::kEmptyString) {
    strfundtype_ = new ::std::string;
  }
  strfundtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strfundtype() {
  set_has_strfundtype();
  if (strfundtype_ == &::google::protobuf::internal::kEmptyString) {
    strfundtype_ = new ::std::string;
  }
  return strfundtype_;
}
inline ::std::string* BusinessDockMsgInfo::release_strfundtype() {
  clear_has_strfundtype();
  if (strfundtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strfundtype_;
    strfundtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strfundtype(::std::string* strfundtype) {
  if (strfundtype_ != &::google::protobuf::internal::kEmptyString) {
    delete strfundtype_;
  }
  if (strfundtype) {
    set_has_strfundtype();
    strfundtype_ = strfundtype;
  } else {
    clear_has_strfundtype();
    strfundtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strCancelBusinessType = 28;
inline bool BusinessDockMsgInfo::has_strcancelbusinesstype() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strcancelbusinesstype() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BusinessDockMsgInfo::clear_has_strcancelbusinesstype() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BusinessDockMsgInfo::clear_strcancelbusinesstype() {
  if (strcancelbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    strcancelbusinesstype_->clear();
  }
  clear_has_strcancelbusinesstype();
}
inline const ::std::string& BusinessDockMsgInfo::strcancelbusinesstype() const {
  return *strcancelbusinesstype_;
}
inline void BusinessDockMsgInfo::set_strcancelbusinesstype(const ::std::string& value) {
  set_has_strcancelbusinesstype();
  if (strcancelbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strcancelbusinesstype_ = new ::std::string;
  }
  strcancelbusinesstype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcancelbusinesstype(const char* value) {
  set_has_strcancelbusinesstype();
  if (strcancelbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strcancelbusinesstype_ = new ::std::string;
  }
  strcancelbusinesstype_->assign(value);
}
inline void BusinessDockMsgInfo::set_strcancelbusinesstype(const char* value, size_t size) {
  set_has_strcancelbusinesstype();
  if (strcancelbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strcancelbusinesstype_ = new ::std::string;
  }
  strcancelbusinesstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strcancelbusinesstype() {
  set_has_strcancelbusinesstype();
  if (strcancelbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strcancelbusinesstype_ = new ::std::string;
  }
  return strcancelbusinesstype_;
}
inline ::std::string* BusinessDockMsgInfo::release_strcancelbusinesstype() {
  clear_has_strcancelbusinesstype();
  if (strcancelbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcancelbusinesstype_;
    strcancelbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strcancelbusinesstype(::std::string* strcancelbusinesstype) {
  if (strcancelbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strcancelbusinesstype_;
  }
  if (strcancelbusinesstype) {
    set_has_strcancelbusinesstype();
    strcancelbusinesstype_ = strcancelbusinesstype;
  } else {
    clear_has_strcancelbusinesstype();
    strcancelbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTerminalIP = 29;
inline bool BusinessDockMsgInfo::has_strterminalip() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strterminalip() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BusinessDockMsgInfo::clear_has_strterminalip() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BusinessDockMsgInfo::clear_strterminalip() {
  if (strterminalip_ != &::google::protobuf::internal::kEmptyString) {
    strterminalip_->clear();
  }
  clear_has_strterminalip();
}
inline const ::std::string& BusinessDockMsgInfo::strterminalip() const {
  return *strterminalip_;
}
inline void BusinessDockMsgInfo::set_strterminalip(const ::std::string& value) {
  set_has_strterminalip();
  if (strterminalip_ == &::google::protobuf::internal::kEmptyString) {
    strterminalip_ = new ::std::string;
  }
  strterminalip_->assign(value);
}
inline void BusinessDockMsgInfo::set_strterminalip(const char* value) {
  set_has_strterminalip();
  if (strterminalip_ == &::google::protobuf::internal::kEmptyString) {
    strterminalip_ = new ::std::string;
  }
  strterminalip_->assign(value);
}
inline void BusinessDockMsgInfo::set_strterminalip(const char* value, size_t size) {
  set_has_strterminalip();
  if (strterminalip_ == &::google::protobuf::internal::kEmptyString) {
    strterminalip_ = new ::std::string;
  }
  strterminalip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strterminalip() {
  set_has_strterminalip();
  if (strterminalip_ == &::google::protobuf::internal::kEmptyString) {
    strterminalip_ = new ::std::string;
  }
  return strterminalip_;
}
inline ::std::string* BusinessDockMsgInfo::release_strterminalip() {
  clear_has_strterminalip();
  if (strterminalip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strterminalip_;
    strterminalip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strterminalip(::std::string* strterminalip) {
  if (strterminalip_ != &::google::protobuf::internal::kEmptyString) {
    delete strterminalip_;
  }
  if (strterminalip) {
    set_has_strterminalip();
    strterminalip_ = strterminalip;
  } else {
    clear_has_strterminalip();
    strterminalip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strTradeSerialNum = 30;
inline bool BusinessDockMsgInfo::has_strtradeserialnum() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strtradeserialnum() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BusinessDockMsgInfo::clear_has_strtradeserialnum() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BusinessDockMsgInfo::clear_strtradeserialnum() {
  if (strtradeserialnum_ != &::google::protobuf::internal::kEmptyString) {
    strtradeserialnum_->clear();
  }
  clear_has_strtradeserialnum();
}
inline const ::std::string& BusinessDockMsgInfo::strtradeserialnum() const {
  return *strtradeserialnum_;
}
inline void BusinessDockMsgInfo::set_strtradeserialnum(const ::std::string& value) {
  set_has_strtradeserialnum();
  if (strtradeserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strtradeserialnum_ = new ::std::string;
  }
  strtradeserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtradeserialnum(const char* value) {
  set_has_strtradeserialnum();
  if (strtradeserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strtradeserialnum_ = new ::std::string;
  }
  strtradeserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtradeserialnum(const char* value, size_t size) {
  set_has_strtradeserialnum();
  if (strtradeserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strtradeserialnum_ = new ::std::string;
  }
  strtradeserialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strtradeserialnum() {
  set_has_strtradeserialnum();
  if (strtradeserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strtradeserialnum_ = new ::std::string;
  }
  return strtradeserialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strtradeserialnum() {
  clear_has_strtradeserialnum();
  if (strtradeserialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtradeserialnum_;
    strtradeserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strtradeserialnum(::std::string* strtradeserialnum) {
  if (strtradeserialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strtradeserialnum_;
  }
  if (strtradeserialnum) {
    set_has_strtradeserialnum();
    strtradeserialnum_ = strtradeserialnum;
  } else {
    clear_has_strtradeserialnum();
    strtradeserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strFinancSerialNum = 31;
inline bool BusinessDockMsgInfo::has_strfinancserialnum() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strfinancserialnum() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BusinessDockMsgInfo::clear_has_strfinancserialnum() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BusinessDockMsgInfo::clear_strfinancserialnum() {
  if (strfinancserialnum_ != &::google::protobuf::internal::kEmptyString) {
    strfinancserialnum_->clear();
  }
  clear_has_strfinancserialnum();
}
inline const ::std::string& BusinessDockMsgInfo::strfinancserialnum() const {
  return *strfinancserialnum_;
}
inline void BusinessDockMsgInfo::set_strfinancserialnum(const ::std::string& value) {
  set_has_strfinancserialnum();
  if (strfinancserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strfinancserialnum_ = new ::std::string;
  }
  strfinancserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfinancserialnum(const char* value) {
  set_has_strfinancserialnum();
  if (strfinancserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strfinancserialnum_ = new ::std::string;
  }
  strfinancserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_strfinancserialnum(const char* value, size_t size) {
  set_has_strfinancserialnum();
  if (strfinancserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strfinancserialnum_ = new ::std::string;
  }
  strfinancserialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strfinancserialnum() {
  set_has_strfinancserialnum();
  if (strfinancserialnum_ == &::google::protobuf::internal::kEmptyString) {
    strfinancserialnum_ = new ::std::string;
  }
  return strfinancserialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_strfinancserialnum() {
  clear_has_strfinancserialnum();
  if (strfinancserialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strfinancserialnum_;
    strfinancserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strfinancserialnum(::std::string* strfinancserialnum) {
  if (strfinancserialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete strfinancserialnum_;
  }
  if (strfinancserialnum) {
    set_has_strfinancserialnum();
    strfinancserialnum_ = strfinancserialnum;
  } else {
    clear_has_strfinancserialnum();
    strfinancserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nSystemType = 32;
inline bool BusinessDockMsgInfo::has_nsystemtype() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BusinessDockMsgInfo::set_has_nsystemtype() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BusinessDockMsgInfo::clear_has_nsystemtype() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BusinessDockMsgInfo::clear_nsystemtype() {
  nsystemtype_ = 0;
  clear_has_nsystemtype();
}
inline ::google::protobuf::int32 BusinessDockMsgInfo::nsystemtype() const {
  return nsystemtype_;
}
inline void BusinessDockMsgInfo::set_nsystemtype(::google::protobuf::int32 value) {
  set_has_nsystemtype();
  nsystemtype_ = value;
}

// required int32 nBootFlag = 33;
inline bool BusinessDockMsgInfo::has_nbootflag() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BusinessDockMsgInfo::set_has_nbootflag() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BusinessDockMsgInfo::clear_has_nbootflag() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BusinessDockMsgInfo::clear_nbootflag() {
  nbootflag_ = 0;
  clear_has_nbootflag();
}
inline ::google::protobuf::int32 BusinessDockMsgInfo::nbootflag() const {
  return nbootflag_;
}
inline void BusinessDockMsgInfo::set_nbootflag(::google::protobuf::int32 value) {
  set_has_nbootflag();
  nbootflag_ = value;
}

// optional string strTermId = 34;
inline bool BusinessDockMsgInfo::has_strtermid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strtermid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BusinessDockMsgInfo::clear_has_strtermid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BusinessDockMsgInfo::clear_strtermid() {
  if (strtermid_ != &::google::protobuf::internal::kEmptyString) {
    strtermid_->clear();
  }
  clear_has_strtermid();
}
inline const ::std::string& BusinessDockMsgInfo::strtermid() const {
  return *strtermid_;
}
inline void BusinessDockMsgInfo::set_strtermid(const ::std::string& value) {
  set_has_strtermid();
  if (strtermid_ == &::google::protobuf::internal::kEmptyString) {
    strtermid_ = new ::std::string;
  }
  strtermid_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtermid(const char* value) {
  set_has_strtermid();
  if (strtermid_ == &::google::protobuf::internal::kEmptyString) {
    strtermid_ = new ::std::string;
  }
  strtermid_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtermid(const char* value, size_t size) {
  set_has_strtermid();
  if (strtermid_ == &::google::protobuf::internal::kEmptyString) {
    strtermid_ = new ::std::string;
  }
  strtermid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strtermid() {
  set_has_strtermid();
  if (strtermid_ == &::google::protobuf::internal::kEmptyString) {
    strtermid_ = new ::std::string;
  }
  return strtermid_;
}
inline ::std::string* BusinessDockMsgInfo::release_strtermid() {
  clear_has_strtermid();
  if (strtermid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtermid_;
    strtermid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strtermid(::std::string* strtermid) {
  if (strtermid_ != &::google::protobuf::internal::kEmptyString) {
    delete strtermid_;
  }
  if (strtermid) {
    set_has_strtermid();
    strtermid_ = strtermid;
  } else {
    clear_has_strtermid();
    strtermid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strTranTime = 35;
inline bool BusinessDockMsgInfo::has_strtrantime() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strtrantime() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BusinessDockMsgInfo::clear_has_strtrantime() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BusinessDockMsgInfo::clear_strtrantime() {
  if (strtrantime_ != &::google::protobuf::internal::kEmptyString) {
    strtrantime_->clear();
  }
  clear_has_strtrantime();
}
inline const ::std::string& BusinessDockMsgInfo::strtrantime() const {
  return *strtrantime_;
}
inline void BusinessDockMsgInfo::set_strtrantime(const ::std::string& value) {
  set_has_strtrantime();
  if (strtrantime_ == &::google::protobuf::internal::kEmptyString) {
    strtrantime_ = new ::std::string;
  }
  strtrantime_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtrantime(const char* value) {
  set_has_strtrantime();
  if (strtrantime_ == &::google::protobuf::internal::kEmptyString) {
    strtrantime_ = new ::std::string;
  }
  strtrantime_->assign(value);
}
inline void BusinessDockMsgInfo::set_strtrantime(const char* value, size_t size) {
  set_has_strtrantime();
  if (strtrantime_ == &::google::protobuf::internal::kEmptyString) {
    strtrantime_ = new ::std::string;
  }
  strtrantime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strtrantime() {
  set_has_strtrantime();
  if (strtrantime_ == &::google::protobuf::internal::kEmptyString) {
    strtrantime_ = new ::std::string;
  }
  return strtrantime_;
}
inline ::std::string* BusinessDockMsgInfo::release_strtrantime() {
  clear_has_strtrantime();
  if (strtrantime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtrantime_;
    strtrantime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strtrantime(::std::string* strtrantime) {
  if (strtrantime_ != &::google::protobuf::internal::kEmptyString) {
    delete strtrantime_;
  }
  if (strtrantime) {
    set_has_strtrantime();
    strtrantime_ = strtrantime;
  } else {
    clear_has_strtrantime();
    strtrantime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strAcctNo = 36;
inline bool BusinessDockMsgInfo::has_stracctno() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BusinessDockMsgInfo::set_has_stracctno() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BusinessDockMsgInfo::clear_has_stracctno() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BusinessDockMsgInfo::clear_stracctno() {
  if (stracctno_ != &::google::protobuf::internal::kEmptyString) {
    stracctno_->clear();
  }
  clear_has_stracctno();
}
inline const ::std::string& BusinessDockMsgInfo::stracctno() const {
  return *stracctno_;
}
inline void BusinessDockMsgInfo::set_stracctno(const ::std::string& value) {
  set_has_stracctno();
  if (stracctno_ == &::google::protobuf::internal::kEmptyString) {
    stracctno_ = new ::std::string;
  }
  stracctno_->assign(value);
}
inline void BusinessDockMsgInfo::set_stracctno(const char* value) {
  set_has_stracctno();
  if (stracctno_ == &::google::protobuf::internal::kEmptyString) {
    stracctno_ = new ::std::string;
  }
  stracctno_->assign(value);
}
inline void BusinessDockMsgInfo::set_stracctno(const char* value, size_t size) {
  set_has_stracctno();
  if (stracctno_ == &::google::protobuf::internal::kEmptyString) {
    stracctno_ = new ::std::string;
  }
  stracctno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_stracctno() {
  set_has_stracctno();
  if (stracctno_ == &::google::protobuf::internal::kEmptyString) {
    stracctno_ = new ::std::string;
  }
  return stracctno_;
}
inline ::std::string* BusinessDockMsgInfo::release_stracctno() {
  clear_has_stracctno();
  if (stracctno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stracctno_;
    stracctno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_stracctno(::std::string* stracctno) {
  if (stracctno_ != &::google::protobuf::internal::kEmptyString) {
    delete stracctno_;
  }
  if (stracctno) {
    set_has_stracctno();
    stracctno_ = stracctno;
  } else {
    clear_has_stracctno();
    stracctno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strIBFISSerialNum = 37;
inline bool BusinessDockMsgInfo::has_stribfisserialnum() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BusinessDockMsgInfo::set_has_stribfisserialnum() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BusinessDockMsgInfo::clear_has_stribfisserialnum() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BusinessDockMsgInfo::clear_stribfisserialnum() {
  if (stribfisserialnum_ != &::google::protobuf::internal::kEmptyString) {
    stribfisserialnum_->clear();
  }
  clear_has_stribfisserialnum();
}
inline const ::std::string& BusinessDockMsgInfo::stribfisserialnum() const {
  return *stribfisserialnum_;
}
inline void BusinessDockMsgInfo::set_stribfisserialnum(const ::std::string& value) {
  set_has_stribfisserialnum();
  if (stribfisserialnum_ == &::google::protobuf::internal::kEmptyString) {
    stribfisserialnum_ = new ::std::string;
  }
  stribfisserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_stribfisserialnum(const char* value) {
  set_has_stribfisserialnum();
  if (stribfisserialnum_ == &::google::protobuf::internal::kEmptyString) {
    stribfisserialnum_ = new ::std::string;
  }
  stribfisserialnum_->assign(value);
}
inline void BusinessDockMsgInfo::set_stribfisserialnum(const char* value, size_t size) {
  set_has_stribfisserialnum();
  if (stribfisserialnum_ == &::google::protobuf::internal::kEmptyString) {
    stribfisserialnum_ = new ::std::string;
  }
  stribfisserialnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_stribfisserialnum() {
  set_has_stribfisserialnum();
  if (stribfisserialnum_ == &::google::protobuf::internal::kEmptyString) {
    stribfisserialnum_ = new ::std::string;
  }
  return stribfisserialnum_;
}
inline ::std::string* BusinessDockMsgInfo::release_stribfisserialnum() {
  clear_has_stribfisserialnum();
  if (stribfisserialnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stribfisserialnum_;
    stribfisserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_stribfisserialnum(::std::string* stribfisserialnum) {
  if (stribfisserialnum_ != &::google::protobuf::internal::kEmptyString) {
    delete stribfisserialnum_;
  }
  if (stribfisserialnum) {
    set_has_stribfisserialnum();
    stribfisserialnum_ = stribfisserialnum;
  } else {
    clear_has_stribfisserialnum();
    stribfisserialnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strVideoEndDate = 38;
inline bool BusinessDockMsgInfo::has_strvideoenddate() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strvideoenddate() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BusinessDockMsgInfo::clear_has_strvideoenddate() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BusinessDockMsgInfo::clear_strvideoenddate() {
  if (strvideoenddate_ != &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_->clear();
  }
  clear_has_strvideoenddate();
}
inline const ::std::string& BusinessDockMsgInfo::strvideoenddate() const {
  return *strvideoenddate_;
}
inline void BusinessDockMsgInfo::set_strvideoenddate(const ::std::string& value) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strvideoenddate(const char* value) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(value);
}
inline void BusinessDockMsgInfo::set_strvideoenddate(const char* value, size_t size) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strvideoenddate() {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  return strvideoenddate_;
}
inline ::std::string* BusinessDockMsgInfo::release_strvideoenddate() {
  clear_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvideoenddate_;
    strvideoenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strvideoenddate(::std::string* strvideoenddate) {
  if (strvideoenddate_ != &::google::protobuf::internal::kEmptyString) {
    delete strvideoenddate_;
  }
  if (strvideoenddate) {
    set_has_strvideoenddate();
    strvideoenddate_ = strvideoenddate;
  } else {
    clear_has_strvideoenddate();
    strvideoenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strExtendedInfo = 39;
inline bool BusinessDockMsgInfo::has_strextendedinfo() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BusinessDockMsgInfo::set_has_strextendedinfo() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BusinessDockMsgInfo::clear_has_strextendedinfo() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BusinessDockMsgInfo::clear_strextendedinfo() {
  if (strextendedinfo_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo_->clear();
  }
  clear_has_strextendedinfo();
}
inline const ::std::string& BusinessDockMsgInfo::strextendedinfo() const {
  return *strextendedinfo_;
}
inline void BusinessDockMsgInfo::set_strextendedinfo(const ::std::string& value) {
  set_has_strextendedinfo();
  if (strextendedinfo_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo_ = new ::std::string;
  }
  strextendedinfo_->assign(value);
}
inline void BusinessDockMsgInfo::set_strextendedinfo(const char* value) {
  set_has_strextendedinfo();
  if (strextendedinfo_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo_ = new ::std::string;
  }
  strextendedinfo_->assign(value);
}
inline void BusinessDockMsgInfo::set_strextendedinfo(const char* value, size_t size) {
  set_has_strextendedinfo();
  if (strextendedinfo_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo_ = new ::std::string;
  }
  strextendedinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessDockMsgInfo::mutable_strextendedinfo() {
  set_has_strextendedinfo();
  if (strextendedinfo_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo_ = new ::std::string;
  }
  return strextendedinfo_;
}
inline ::std::string* BusinessDockMsgInfo::release_strextendedinfo() {
  clear_has_strextendedinfo();
  if (strextendedinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo_;
    strextendedinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusinessDockMsgInfo::set_allocated_strextendedinfo(::std::string* strextendedinfo) {
  if (strextendedinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo_;
  }
  if (strextendedinfo) {
    set_has_strextendedinfo();
    strextendedinfo_ = strextendedinfo;
  } else {
    clear_has_strextendedinfo();
    strextendedinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ManualSyncParameter

// required int32 nBranchInfo = 1;
inline bool ManualSyncParameter::has_nbranchinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualSyncParameter::set_has_nbranchinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualSyncParameter::clear_has_nbranchinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualSyncParameter::clear_nbranchinfo() {
  nbranchinfo_ = 0;
  clear_has_nbranchinfo();
}
inline ::google::protobuf::int32 ManualSyncParameter::nbranchinfo() const {
  return nbranchinfo_;
}
inline void ManualSyncParameter::set_nbranchinfo(::google::protobuf::int32 value) {
  set_has_nbranchinfo();
  nbranchinfo_ = value;
}

// required int32 nProduceInfo = 2;
inline bool ManualSyncParameter::has_nproduceinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualSyncParameter::set_has_nproduceinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualSyncParameter::clear_has_nproduceinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualSyncParameter::clear_nproduceinfo() {
  nproduceinfo_ = 0;
  clear_has_nproduceinfo();
}
inline ::google::protobuf::int32 ManualSyncParameter::nproduceinfo() const {
  return nproduceinfo_;
}
inline void ManualSyncParameter::set_nproduceinfo(::google::protobuf::int32 value) {
  set_has_nproduceinfo();
  nproduceinfo_ = value;
}

// required int32 nEmployeeInfo = 3;
inline bool ManualSyncParameter::has_nemployeeinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualSyncParameter::set_has_nemployeeinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualSyncParameter::clear_has_nemployeeinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualSyncParameter::clear_nemployeeinfo() {
  nemployeeinfo_ = 0;
  clear_has_nemployeeinfo();
}
inline ::google::protobuf::int32 ManualSyncParameter::nemployeeinfo() const {
  return nemployeeinfo_;
}
inline void ManualSyncParameter::set_nemployeeinfo(::google::protobuf::int32 value) {
  set_has_nemployeeinfo();
  nemployeeinfo_ = value;
}

// -------------------------------------------------------------------

// ScriptInfo

// required string strScriptId = 1;
inline bool ScriptInfo::has_strscriptid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScriptInfo::set_has_strscriptid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScriptInfo::clear_has_strscriptid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScriptInfo::clear_strscriptid() {
  if (strscriptid_ != &::google::protobuf::internal::kEmptyString) {
    strscriptid_->clear();
  }
  clear_has_strscriptid();
}
inline const ::std::string& ScriptInfo::strscriptid() const {
  return *strscriptid_;
}
inline void ScriptInfo::set_strscriptid(const ::std::string& value) {
  set_has_strscriptid();
  if (strscriptid_ == &::google::protobuf::internal::kEmptyString) {
    strscriptid_ = new ::std::string;
  }
  strscriptid_->assign(value);
}
inline void ScriptInfo::set_strscriptid(const char* value) {
  set_has_strscriptid();
  if (strscriptid_ == &::google::protobuf::internal::kEmptyString) {
    strscriptid_ = new ::std::string;
  }
  strscriptid_->assign(value);
}
inline void ScriptInfo::set_strscriptid(const char* value, size_t size) {
  set_has_strscriptid();
  if (strscriptid_ == &::google::protobuf::internal::kEmptyString) {
    strscriptid_ = new ::std::string;
  }
  strscriptid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strscriptid() {
  set_has_strscriptid();
  if (strscriptid_ == &::google::protobuf::internal::kEmptyString) {
    strscriptid_ = new ::std::string;
  }
  return strscriptid_;
}
inline ::std::string* ScriptInfo::release_strscriptid() {
  clear_has_strscriptid();
  if (strscriptid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strscriptid_;
    strscriptid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strscriptid(::std::string* strscriptid) {
  if (strscriptid_ != &::google::protobuf::internal::kEmptyString) {
    delete strscriptid_;
  }
  if (strscriptid) {
    set_has_strscriptid();
    strscriptid_ = strscriptid;
  } else {
    clear_has_strscriptid();
    strscriptid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessCode = 2;
inline bool ScriptInfo::has_strbusinesscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScriptInfo::set_has_strbusinesscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScriptInfo::clear_has_strbusinesscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScriptInfo::clear_strbusinesscode() {
  if (strbusinesscode_ != &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_->clear();
  }
  clear_has_strbusinesscode();
}
inline const ::std::string& ScriptInfo::strbusinesscode() const {
  return *strbusinesscode_;
}
inline void ScriptInfo::set_strbusinesscode(const ::std::string& value) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(value);
}
inline void ScriptInfo::set_strbusinesscode(const char* value) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(value);
}
inline void ScriptInfo::set_strbusinesscode(const char* value, size_t size) {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  strbusinesscode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strbusinesscode() {
  set_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesscode_ = new ::std::string;
  }
  return strbusinesscode_;
}
inline ::std::string* ScriptInfo::release_strbusinesscode() {
  clear_has_strbusinesscode();
  if (strbusinesscode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinesscode_;
    strbusinesscode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strbusinesscode(::std::string* strbusinesscode) {
  if (strbusinesscode_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinesscode_;
  }
  if (strbusinesscode) {
    set_has_strbusinesscode();
    strbusinesscode_ = strbusinesscode;
  } else {
    clear_has_strbusinesscode();
    strbusinesscode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBusinessType = 3;
inline bool ScriptInfo::has_strbusinesstype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScriptInfo::set_has_strbusinesstype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScriptInfo::clear_has_strbusinesstype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScriptInfo::clear_strbusinesstype() {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_->clear();
  }
  clear_has_strbusinesstype();
}
inline const ::std::string& ScriptInfo::strbusinesstype() const {
  return *strbusinesstype_;
}
inline void ScriptInfo::set_strbusinesstype(const ::std::string& value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void ScriptInfo::set_strbusinesstype(const char* value) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(value);
}
inline void ScriptInfo::set_strbusinesstype(const char* value, size_t size) {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  strbusinesstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strbusinesstype() {
  set_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    strbusinesstype_ = new ::std::string;
  }
  return strbusinesstype_;
}
inline ::std::string* ScriptInfo::release_strbusinesstype() {
  clear_has_strbusinesstype();
  if (strbusinesstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbusinesstype_;
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strbusinesstype(::std::string* strbusinesstype) {
  if (strbusinesstype_ != &::google::protobuf::internal::kEmptyString) {
    delete strbusinesstype_;
  }
  if (strbusinesstype) {
    set_has_strbusinesstype();
    strbusinesstype_ = strbusinesstype;
  } else {
    clear_has_strbusinesstype();
    strbusinesstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strScriptContent = 4;
inline bool ScriptInfo::has_strscriptcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScriptInfo::set_has_strscriptcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScriptInfo::clear_has_strscriptcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScriptInfo::clear_strscriptcontent() {
  if (strscriptcontent_ != &::google::protobuf::internal::kEmptyString) {
    strscriptcontent_->clear();
  }
  clear_has_strscriptcontent();
}
inline const ::std::string& ScriptInfo::strscriptcontent() const {
  return *strscriptcontent_;
}
inline void ScriptInfo::set_strscriptcontent(const ::std::string& value) {
  set_has_strscriptcontent();
  if (strscriptcontent_ == &::google::protobuf::internal::kEmptyString) {
    strscriptcontent_ = new ::std::string;
  }
  strscriptcontent_->assign(value);
}
inline void ScriptInfo::set_strscriptcontent(const char* value) {
  set_has_strscriptcontent();
  if (strscriptcontent_ == &::google::protobuf::internal::kEmptyString) {
    strscriptcontent_ = new ::std::string;
  }
  strscriptcontent_->assign(value);
}
inline void ScriptInfo::set_strscriptcontent(const char* value, size_t size) {
  set_has_strscriptcontent();
  if (strscriptcontent_ == &::google::protobuf::internal::kEmptyString) {
    strscriptcontent_ = new ::std::string;
  }
  strscriptcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strscriptcontent() {
  set_has_strscriptcontent();
  if (strscriptcontent_ == &::google::protobuf::internal::kEmptyString) {
    strscriptcontent_ = new ::std::string;
  }
  return strscriptcontent_;
}
inline ::std::string* ScriptInfo::release_strscriptcontent() {
  clear_has_strscriptcontent();
  if (strscriptcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strscriptcontent_;
    strscriptcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strscriptcontent(::std::string* strscriptcontent) {
  if (strscriptcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete strscriptcontent_;
  }
  if (strscriptcontent) {
    set_has_strscriptcontent();
    strscriptcontent_ = strscriptcontent;
  } else {
    clear_has_strscriptcontent();
    strscriptcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 5;
inline bool ScriptInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScriptInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScriptInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScriptInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 ScriptInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void ScriptInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 6;
inline bool ScriptInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScriptInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScriptInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScriptInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& ScriptInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void ScriptInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ScriptInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void ScriptInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* ScriptInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strExtendedInfo2 = 7;
inline bool ScriptInfo::has_strextendedinfo2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScriptInfo::set_has_strextendedinfo2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScriptInfo::clear_has_strextendedinfo2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScriptInfo::clear_strextendedinfo2() {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_->clear();
  }
  clear_has_strextendedinfo2();
}
inline const ::std::string& ScriptInfo::strextendedinfo2() const {
  return *strextendedinfo2_;
}
inline void ScriptInfo::set_strextendedinfo2(const ::std::string& value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ScriptInfo::set_strextendedinfo2(const char* value) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(value);
}
inline void ScriptInfo::set_strextendedinfo2(const char* value, size_t size) {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  strextendedinfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScriptInfo::mutable_strextendedinfo2() {
  set_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo2_ = new ::std::string;
  }
  return strextendedinfo2_;
}
inline ::std::string* ScriptInfo::release_strextendedinfo2() {
  clear_has_strextendedinfo2();
  if (strextendedinfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo2_;
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScriptInfo::set_allocated_strextendedinfo2(::std::string* strextendedinfo2) {
  if (strextendedinfo2_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo2_;
  }
  if (strextendedinfo2) {
    set_has_strextendedinfo2();
    strextendedinfo2_ = strextendedinfo2;
  } else {
    clear_has_strextendedinfo2();
    strextendedinfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OperateLogInfo

// required string strOperateLogId = 1;
inline bool OperateLogInfo::has_stroperatelogid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperateLogInfo::set_has_stroperatelogid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperateLogInfo::clear_has_stroperatelogid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperateLogInfo::clear_stroperatelogid() {
  if (stroperatelogid_ != &::google::protobuf::internal::kEmptyString) {
    stroperatelogid_->clear();
  }
  clear_has_stroperatelogid();
}
inline const ::std::string& OperateLogInfo::stroperatelogid() const {
  return *stroperatelogid_;
}
inline void OperateLogInfo::set_stroperatelogid(const ::std::string& value) {
  set_has_stroperatelogid();
  if (stroperatelogid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatelogid_ = new ::std::string;
  }
  stroperatelogid_->assign(value);
}
inline void OperateLogInfo::set_stroperatelogid(const char* value) {
  set_has_stroperatelogid();
  if (stroperatelogid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatelogid_ = new ::std::string;
  }
  stroperatelogid_->assign(value);
}
inline void OperateLogInfo::set_stroperatelogid(const char* value, size_t size) {
  set_has_stroperatelogid();
  if (stroperatelogid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatelogid_ = new ::std::string;
  }
  stroperatelogid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_stroperatelogid() {
  set_has_stroperatelogid();
  if (stroperatelogid_ == &::google::protobuf::internal::kEmptyString) {
    stroperatelogid_ = new ::std::string;
  }
  return stroperatelogid_;
}
inline ::std::string* OperateLogInfo::release_stroperatelogid() {
  clear_has_stroperatelogid();
  if (stroperatelogid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroperatelogid_;
    stroperatelogid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_stroperatelogid(::std::string* stroperatelogid) {
  if (stroperatelogid_ != &::google::protobuf::internal::kEmptyString) {
    delete stroperatelogid_;
  }
  if (stroperatelogid) {
    set_has_stroperatelogid();
    stroperatelogid_ = stroperatelogid;
  } else {
    clear_has_stroperatelogid();
    stroperatelogid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strModule = 2;
inline bool OperateLogInfo::has_strmodule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperateLogInfo::set_has_strmodule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperateLogInfo::clear_has_strmodule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperateLogInfo::clear_strmodule() {
  if (strmodule_ != &::google::protobuf::internal::kEmptyString) {
    strmodule_->clear();
  }
  clear_has_strmodule();
}
inline const ::std::string& OperateLogInfo::strmodule() const {
  return *strmodule_;
}
inline void OperateLogInfo::set_strmodule(const ::std::string& value) {
  set_has_strmodule();
  if (strmodule_ == &::google::protobuf::internal::kEmptyString) {
    strmodule_ = new ::std::string;
  }
  strmodule_->assign(value);
}
inline void OperateLogInfo::set_strmodule(const char* value) {
  set_has_strmodule();
  if (strmodule_ == &::google::protobuf::internal::kEmptyString) {
    strmodule_ = new ::std::string;
  }
  strmodule_->assign(value);
}
inline void OperateLogInfo::set_strmodule(const char* value, size_t size) {
  set_has_strmodule();
  if (strmodule_ == &::google::protobuf::internal::kEmptyString) {
    strmodule_ = new ::std::string;
  }
  strmodule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_strmodule() {
  set_has_strmodule();
  if (strmodule_ == &::google::protobuf::internal::kEmptyString) {
    strmodule_ = new ::std::string;
  }
  return strmodule_;
}
inline ::std::string* OperateLogInfo::release_strmodule() {
  clear_has_strmodule();
  if (strmodule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmodule_;
    strmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_strmodule(::std::string* strmodule) {
  if (strmodule_ != &::google::protobuf::internal::kEmptyString) {
    delete strmodule_;
  }
  if (strmodule) {
    set_has_strmodule();
    strmodule_ = strmodule;
  } else {
    clear_has_strmodule();
    strmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strOperateEvent = 3;
inline bool OperateLogInfo::has_stroperateevent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperateLogInfo::set_has_stroperateevent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperateLogInfo::clear_has_stroperateevent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperateLogInfo::clear_stroperateevent() {
  if (stroperateevent_ != &::google::protobuf::internal::kEmptyString) {
    stroperateevent_->clear();
  }
  clear_has_stroperateevent();
}
inline const ::std::string& OperateLogInfo::stroperateevent() const {
  return *stroperateevent_;
}
inline void OperateLogInfo::set_stroperateevent(const ::std::string& value) {
  set_has_stroperateevent();
  if (stroperateevent_ == &::google::protobuf::internal::kEmptyString) {
    stroperateevent_ = new ::std::string;
  }
  stroperateevent_->assign(value);
}
inline void OperateLogInfo::set_stroperateevent(const char* value) {
  set_has_stroperateevent();
  if (stroperateevent_ == &::google::protobuf::internal::kEmptyString) {
    stroperateevent_ = new ::std::string;
  }
  stroperateevent_->assign(value);
}
inline void OperateLogInfo::set_stroperateevent(const char* value, size_t size) {
  set_has_stroperateevent();
  if (stroperateevent_ == &::google::protobuf::internal::kEmptyString) {
    stroperateevent_ = new ::std::string;
  }
  stroperateevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_stroperateevent() {
  set_has_stroperateevent();
  if (stroperateevent_ == &::google::protobuf::internal::kEmptyString) {
    stroperateevent_ = new ::std::string;
  }
  return stroperateevent_;
}
inline ::std::string* OperateLogInfo::release_stroperateevent() {
  clear_has_stroperateevent();
  if (stroperateevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroperateevent_;
    stroperateevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_stroperateevent(::std::string* stroperateevent) {
  if (stroperateevent_ != &::google::protobuf::internal::kEmptyString) {
    delete stroperateevent_;
  }
  if (stroperateevent) {
    set_has_stroperateevent();
    stroperateevent_ = stroperateevent;
  } else {
    clear_has_stroperateevent();
    stroperateevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strIp = 4;
inline bool OperateLogInfo::has_strip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperateLogInfo::set_has_strip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperateLogInfo::clear_has_strip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperateLogInfo::clear_strip() {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    strip_->clear();
  }
  clear_has_strip();
}
inline const ::std::string& OperateLogInfo::strip() const {
  return *strip_;
}
inline void OperateLogInfo::set_strip(const ::std::string& value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void OperateLogInfo::set_strip(const char* value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void OperateLogInfo::set_strip(const char* value, size_t size) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_strip() {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  return strip_;
}
inline ::std::string* OperateLogInfo::release_strip() {
  clear_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strip_;
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_strip(::std::string* strip) {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    delete strip_;
  }
  if (strip) {
    set_has_strip();
    strip_ = strip;
  } else {
    clear_has_strip();
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strEmployeeId = 5;
inline bool OperateLogInfo::has_stremployeeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperateLogInfo::set_has_stremployeeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperateLogInfo::clear_has_stremployeeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperateLogInfo::clear_stremployeeid() {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    stremployeeid_->clear();
  }
  clear_has_stremployeeid();
}
inline const ::std::string& OperateLogInfo::stremployeeid() const {
  return *stremployeeid_;
}
inline void OperateLogInfo::set_stremployeeid(const ::std::string& value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void OperateLogInfo::set_stremployeeid(const char* value) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(value);
}
inline void OperateLogInfo::set_stremployeeid(const char* value, size_t size) {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  stremployeeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_stremployeeid() {
  set_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    stremployeeid_ = new ::std::string;
  }
  return stremployeeid_;
}
inline ::std::string* OperateLogInfo::release_stremployeeid() {
  clear_has_stremployeeid();
  if (stremployeeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremployeeid_;
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_stremployeeid(::std::string* stremployeeid) {
  if (stremployeeid_ != &::google::protobuf::internal::kEmptyString) {
    delete stremployeeid_;
  }
  if (stremployeeid) {
    set_has_stremployeeid();
    stremployeeid_ = stremployeeid;
  } else {
    clear_has_stremployeeid();
    stremployeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strBranchId = 6;
inline bool OperateLogInfo::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperateLogInfo::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperateLogInfo::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperateLogInfo::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& OperateLogInfo::strbranchid() const {
  return *strbranchid_;
}
inline void OperateLogInfo::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void OperateLogInfo::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void OperateLogInfo::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* OperateLogInfo::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string stOperateTime = 7;
inline bool OperateLogInfo::has_stoperatetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OperateLogInfo::set_has_stoperatetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OperateLogInfo::clear_has_stoperatetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OperateLogInfo::clear_stoperatetime() {
  if (stoperatetime_ != &::google::protobuf::internal::kEmptyString) {
    stoperatetime_->clear();
  }
  clear_has_stoperatetime();
}
inline const ::std::string& OperateLogInfo::stoperatetime() const {
  return *stoperatetime_;
}
inline void OperateLogInfo::set_stoperatetime(const ::std::string& value) {
  set_has_stoperatetime();
  if (stoperatetime_ == &::google::protobuf::internal::kEmptyString) {
    stoperatetime_ = new ::std::string;
  }
  stoperatetime_->assign(value);
}
inline void OperateLogInfo::set_stoperatetime(const char* value) {
  set_has_stoperatetime();
  if (stoperatetime_ == &::google::protobuf::internal::kEmptyString) {
    stoperatetime_ = new ::std::string;
  }
  stoperatetime_->assign(value);
}
inline void OperateLogInfo::set_stoperatetime(const char* value, size_t size) {
  set_has_stoperatetime();
  if (stoperatetime_ == &::google::protobuf::internal::kEmptyString) {
    stoperatetime_ = new ::std::string;
  }
  stoperatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_stoperatetime() {
  set_has_stoperatetime();
  if (stoperatetime_ == &::google::protobuf::internal::kEmptyString) {
    stoperatetime_ = new ::std::string;
  }
  return stoperatetime_;
}
inline ::std::string* OperateLogInfo::release_stoperatetime() {
  clear_has_stoperatetime();
  if (stoperatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stoperatetime_;
    stoperatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_stoperatetime(::std::string* stoperatetime) {
  if (stoperatetime_ != &::google::protobuf::internal::kEmptyString) {
    delete stoperatetime_;
  }
  if (stoperatetime) {
    set_has_stoperatetime();
    stoperatetime_ = stoperatetime;
  } else {
    clear_has_stoperatetime();
    stoperatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nExtendedInfo = 8;
inline bool OperateLogInfo::has_nextendedinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperateLogInfo::set_has_nextendedinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperateLogInfo::clear_has_nextendedinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperateLogInfo::clear_nextendedinfo() {
  nextendedinfo_ = 0;
  clear_has_nextendedinfo();
}
inline ::google::protobuf::int32 OperateLogInfo::nextendedinfo() const {
  return nextendedinfo_;
}
inline void OperateLogInfo::set_nextendedinfo(::google::protobuf::int32 value) {
  set_has_nextendedinfo();
  nextendedinfo_ = value;
}

// required string strExtendedInfo1 = 9;
inline bool OperateLogInfo::has_strextendedinfo1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OperateLogInfo::set_has_strextendedinfo1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OperateLogInfo::clear_has_strextendedinfo1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OperateLogInfo::clear_strextendedinfo1() {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_->clear();
  }
  clear_has_strextendedinfo1();
}
inline const ::std::string& OperateLogInfo::strextendedinfo1() const {
  return *strextendedinfo1_;
}
inline void OperateLogInfo::set_strextendedinfo1(const ::std::string& value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void OperateLogInfo::set_strextendedinfo1(const char* value) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(value);
}
inline void OperateLogInfo::set_strextendedinfo1(const char* value, size_t size) {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  strextendedinfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperateLogInfo::mutable_strextendedinfo1() {
  set_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    strextendedinfo1_ = new ::std::string;
  }
  return strextendedinfo1_;
}
inline ::std::string* OperateLogInfo::release_strextendedinfo1() {
  clear_has_strextendedinfo1();
  if (strextendedinfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strextendedinfo1_;
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperateLogInfo::set_allocated_strextendedinfo1(::std::string* strextendedinfo1) {
  if (strextendedinfo1_ != &::google::protobuf::internal::kEmptyString) {
    delete strextendedinfo1_;
  }
  if (strextendedinfo1) {
    set_has_strextendedinfo1();
    strextendedinfo1_ = strextendedinfo1;
  } else {
    clear_has_strextendedinfo1();
    strextendedinfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DiskAndConnectStatus

// required string strbranchId = 1;
inline bool DiskAndConnectStatus::has_strbranchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskAndConnectStatus::set_has_strbranchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskAndConnectStatus::clear_has_strbranchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskAndConnectStatus::clear_strbranchid() {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    strbranchid_->clear();
  }
  clear_has_strbranchid();
}
inline const ::std::string& DiskAndConnectStatus::strbranchid() const {
  return *strbranchid_;
}
inline void DiskAndConnectStatus::set_strbranchid(const ::std::string& value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void DiskAndConnectStatus::set_strbranchid(const char* value) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(value);
}
inline void DiskAndConnectStatus::set_strbranchid(const char* value, size_t size) {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  strbranchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskAndConnectStatus::mutable_strbranchid() {
  set_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    strbranchid_ = new ::std::string;
  }
  return strbranchid_;
}
inline ::std::string* DiskAndConnectStatus::release_strbranchid() {
  clear_has_strbranchid();
  if (strbranchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbranchid_;
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiskAndConnectStatus::set_allocated_strbranchid(::std::string* strbranchid) {
  if (strbranchid_ != &::google::protobuf::internal::kEmptyString) {
    delete strbranchid_;
  }
  if (strbranchid) {
    set_has_strbranchid();
    strbranchid_ = strbranchid;
  } else {
    clear_has_strbranchid();
    strbranchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nConnectStatus = 2;
inline bool DiskAndConnectStatus::has_nconnectstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskAndConnectStatus::set_has_nconnectstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskAndConnectStatus::clear_has_nconnectstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskAndConnectStatus::clear_nconnectstatus() {
  nconnectstatus_ = 0;
  clear_has_nconnectstatus();
}
inline ::google::protobuf::int32 DiskAndConnectStatus::nconnectstatus() const {
  return nconnectstatus_;
}
inline void DiskAndConnectStatus::set_nconnectstatus(::google::protobuf::int32 value) {
  set_has_nconnectstatus();
  nconnectstatus_ = value;
}

// required int32 nDiskTatolSpace = 3;
inline bool DiskAndConnectStatus::has_ndisktatolspace() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskAndConnectStatus::set_has_ndisktatolspace() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskAndConnectStatus::clear_has_ndisktatolspace() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskAndConnectStatus::clear_ndisktatolspace() {
  ndisktatolspace_ = 0;
  clear_has_ndisktatolspace();
}
inline ::google::protobuf::int32 DiskAndConnectStatus::ndisktatolspace() const {
  return ndisktatolspace_;
}
inline void DiskAndConnectStatus::set_ndisktatolspace(::google::protobuf::int32 value) {
  set_has_ndisktatolspace();
  ndisktatolspace_ = value;
}

// required int32 nDiskFreeSpace = 4;
inline bool DiskAndConnectStatus::has_ndiskfreespace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskAndConnectStatus::set_has_ndiskfreespace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskAndConnectStatus::clear_has_ndiskfreespace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskAndConnectStatus::clear_ndiskfreespace() {
  ndiskfreespace_ = 0;
  clear_has_ndiskfreespace();
}
inline ::google::protobuf::int32 DiskAndConnectStatus::ndiskfreespace() const {
  return ndiskfreespace_;
}
inline void DiskAndConnectStatus::set_ndiskfreespace(::google::protobuf::int32 value) {
  set_has_ndiskfreespace();
  ndiskfreespace_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BFIS

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BFIS_2eProtoMessageDefine_2eproto__INCLUDED
